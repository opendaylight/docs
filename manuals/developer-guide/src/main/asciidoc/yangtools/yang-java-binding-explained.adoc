=== YANG Java Binding: Mapping rules
This chapter covers the details of mapping YANG to Java.

NOTE: Source code examples does not show cannonical generated code, but rather
illustrative example. Generated classes and interfaces may differ from this
examples, but APIs are preserved.

==== General conversion rules

===== Package name of YANG model

The package name consists of the following parts: +

* *Opendaylight prefix* - Specifies the opendaylight prefix. Every package name
starts with the prefix `org.opendaylight.yang.gen.v`.
* *Java Binding version* - Specifies the YANG Java Binding version.
  Curent Binding version is `1`.
* *Namespace* - Specified by the value of `namespace` substatement.
   URI is converted to package name structure.
* *Revision* - Specifies the concatenation of word `rev` and value of `module`
  subelement `revision` argument value without leading zeros before month and day.
  For example: `rev201379`

After the package name is generated check it in if it contains any Java keywords
or start with digit. If it is so then before the token add an underscore.

List of key words which are prefixed with underscore:

abstract, assert, boolean, break, byte, case, catch, char, class, const,
continue, default, double, do, else, enum, extends, false, final, finally,
float, for, goto, if, implements, import, instanceof, int, interface, long,
native, new, null, package, private, protected, public, return, short, static,
strictfp, super, switch, synchronized, this, throw, throws, transient, true, try,
void, volatile, while

As an example suppose following yang model:

[source, yang]
----
module module {
    namespace "urn:2:case#module";
    prefix "sbd";
    organization "OPEN DAYLIGHT";
    contact "http://www.example.com/";
    revision 2013-07-09 {
    }
}
----

After applying rules (replacing digits and Java keywords) the resulting
package name is `org.opendaylight.yang.gen.v1.urn._2._case.module.rev201379`

===== Additional Packages

In cases when YANG statement contain some of specific YANG
statements additional packages are generated to designate this containment.
Table below provides details of parent statement and nested statements, which
yields additional package generation:

[options="header"]
|===
|Parent statement  | Substatement
|`list`  |list, container, choice
|`container` | list, container, choice
|`choice` | leaf, list, leaf-list, container, case
|`case`  | list, container, choice
|rpc `input` or `output` |  list, container, (choice isn't supported)
|`notification` |  list, container, (choice isn't supported)
|`augment`  | list, container, choice, case |
|===

Substatements are not  only mapped to Java fetter methods in the interface
representing parent statement, but they also generate packages with
names consisting of parent statement package name and parent statement name.

In the example YANG model considers the container statement `cont` as the direct
substatement of the module.

[source, yang]
----
 container cont {
   container cont-inner {
   }
   list outter-list {
     list list-in-list {
     }
   }
 }
----

Container `cont` is the parent statement for the substatements
`cont-inner` and `outter-list`.

Java code is generated in the following structure: +

* `org.opendaylight.yang.gen.v1.urn.module.rev201379` - package contains direct
   substatements of module statement
** `Cont.java`
* `org.opendaylight.yang.gen.v1.urn.module.rev201379.cont` - package contains
  substatements of `cont` container statement
** `ContInner.java` - interface representing container `cont-inner`
** `OutterList.java` - interface representing list `outer-list`

[source, yang]
----
 container cont {
   container cont-inner {
   }
   list outter-list {
     list list-in-list {
     }
   }
 }
----

`list outter-list` is parent statement for substatement `list-in-list`

Java code is generated in the following structure: +

* `org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.outter.list` - package
  contains substatements of outter-list list element
  ** `ListInList.java`

===== Class and interface name
Some YANG statements are mapped to Java classes and interfaces. The name of YANG
element may contain various characters which aren't permitted in Java class names.
Firstly whitespaces are trimmed from YANG name. Next characters space, -, `
are deleted and subsequent letter is capitalized. At the end first letter is
capitalized.

Transformation example:
`example-name_ without_capitalization` is mapped to
`ExampleNameWithoutCapitalization`

===== Getters and setters name
In some cases are YANG statements generated as getter or setter methods.
The process for getter is:

. name of YANG schema node is converted to Java class name style
. the word `get` is added as prefix, if resulting type is `Boolean`, name
  is prefixed with `is` prefix instead of `get`.
. return type of the getter method is set to Java type representing substatement

The process for setter is:

. name of YANG schema node is converted to Java class name style
. word `set` is added as prefix
. input parameter name is set to element's name converted to Java parameter style
. return parameter is set to builder type.

==== Statement specific mapping

===== module statement

YANG `module` statement is converted to Java as two Java classes.
Each of the class is in the separate Java file. The names of Java files are
composed as follows:
`<module name><suffix>.java` where `<suffix>` can be data or service.

====== Data Interface

Data Interface has a mapping similar to container, but contains only top level
nodes defined in module.

Data interface serves only as marker interface for type-safe APIs of
`InstanceIdentifier`.

====== Service Interface

Service Interface serves to describe RPC contract defined in the module.
This RPC contract is defined by rpc statements.

RPC implementation usually implements this interface and users of RPC uses
this interface to invoke RPCs.



===== container statement
YANG Container is mapped to Java interface which extends interfaces DataObject,
Augmentable<container`interface>, where container`interface is name of mapped
interface.

Example of mapping:

.YANG
[source, yang]
----
container cont {

}
----

====== Java Mapping

.Cont.java
[source, java]
----
public interface Cont extends ChildOf<...>, Augmentable<Cont> {
}
----

===== Leaf statement
Each leaf has to contain at least one type substatement. The leaf is mapped to
getter method of parent statement with return type equal to type substatement
value.

Example of mapping:

.YANG model
[source, yang]
----
container cont {
  leaf lf {
    type string;
  }
}
----

====== Java Mapping

.Cont.java
[source, java]
----
public interface Cont extends DataObject, Augmentable<Cont> {
    String getLf(); // <1>
}
----

<1> Represents `leaf lf`

===== leaf-list statement
Each leaf-list has to contain one type substatement. The leaf-list is mapped
to getter method of parent statement with return type equal to List of type
substatement value.

Example of mapping of leaf-list.

[source, yang]
----
container cont {
    leaf-list lf-lst {
        type string;
    }
}
----

====== Java Mapping

.Cont.java
[source, java]
----
public interface Cont extends DataObject, Augmentable<Cont> {
    List<String> getLfLst();
}
----


===== list statement

`list` statement is mapped to Java interface.
Getter method is generated in interface associated with parent statement.
Return type of getter method is Java List of objects implementing interface
generated for  list generated interfaces.
Mapping of `list` substatement to Java:

[options="header"]
|===
|Substatement|Mapping to Java
|Key|Class
|===




[source, yang]
----
container cont {
  list outter-list {
    key "leaf-in-list";
    leaf number {
      type uint64;
    }
  }
}
----

====== Java Mapping

List statement  `example-list` is mapped to Java interface `ExampleList` and in
`Cont` interface (parent of `ExampleList`) contains getter method with return
type `List<ExampleList>`. Presence of `key` statement, triggers generation
of `ExampleListKey`, which may be used to identify item in list.


.OutterList.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import Java.util.List;
import org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.outter.list.ListInList;

public interface OutterList extends DataObject, Augmentable<OutterList> {

    List<String> getLeafListInList();

    List<ListInList> getListInList();

    /*
    Returns Primary Key of Yang List Type
    */
    OutterListKey getOutterListKey();

}
----

.OutterListKey.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont;

import org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.OutterListKey;
import Java.math.BigInteger;

public class OutterListKey {

    private BigInteger _leafInList;

    public OutterListKey(BigInteger _leafInList) {
        super();
        this_leafInList = _leafInList;
    }

    public BigInteger getLeafInList() {
        return _leafInList;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((_leafInList == null) ? 0 : _leafInList.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        OutterListKey other = (OutterListKey) obj;
        if (_leafInList == null) {
            if (other._LeafInList != null) {
                return false;
            }
        } else if(!_leafInList.equals(other._leafInList)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("OutterListKey [_leafInList=");
        builder.append(_leafInList);
        builder.append("]");
        return builder.toString();
    }
}
----

===== choice and case statements
`Choice` element is mapped similarly as `list` element. Choice element is mapped
to interface (marker interface) and in the parent statement is created using
getter method with the return type `List` of this marker interfaces.

`Case` substatements are mapped to the Java interfaces which extend mentioned
 marker interface.


.YANG model
[source, yang]
----
container cont {
    choice example-choice {
        case foo-case {
          leaf foo {
            type string;
          }
        }
        case bar-case {
            leaf bar {
              type string;
            }
        }
    }
}
----

====== Java Binding

.Cont.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.ChoiceTest;

public interface Cont extends DataObject, Augmentable<Cont> {

    ExampleChoice getExampleChoice();

}
----


.ExampleChoice.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont;

import org.opendaylight.yangtools.yang.binding.DataObject;

public interface ExampleChoice extends DataContainer {
}
----

.FooCase.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.example.choice;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.ChoiceTest;

public interface FooCase extends ExampleChoice, DataObject, Augmentable<FooCase> {

    String getFoo();

}
----

.BarCase.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.example.choice;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.ChoiceTest;

public interface BarCase extends ExampleChoice, DataObject, Augmentable<BarCase> {

    String getBar();

}
----

===== grouping and uses statements
Grouping is mapped to Java interface. Uses used in some element (using of concrete grouping) are mapped as extension of interface for this element with the interface which represents grouping.
Example of grouping and uses mapping.

.YANG Model
[source, yang]
----
grouping grp {
  leaf foo {
    type string;
  }
}

container cont {
    uses grp;
}
----
====== Java Binding

.Grp.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import org.opendaylight.yangtools.yang.binding.DataObject;

public interface Grp extends DataObject {

    String getFoo();

}
----

.Cont.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;

public interface Cont extends DataObject, Augmentable<Cont>, Grp {
}
----


===== rpc, input and output statements
Rpc is mapped to Java as method of class `ModuleService.java`.
Rpc's substatement are mapped as follows:

[options="header"]
|===
|Rpc Substatement|Mapping
|input|presence of input statement triggers generation of interface
|output|presence of output statement triggers generation of interface
|===

Example of rpc mapping:

.YANG model
[source, yang]
----
rpc rpc-test1 {
    output {
        leaf lf-output {
            type string;
        }
    }
    input {
        leaf lf-input {
            type string;
        }
    }
}
----

.ModuleService.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import Java.util.concurrent.Future;
import org.opendaylight.yangtools.yang.common.RpcResult;

public interface ModuleService {

    Future<RpcResult<RpcTest1Output>> rpcTest1(RpcTest1Input input);

}
----

.RpcTest1Input.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

public interface RpcTest1Input {

    String getLfInput();

}
----

.RpcTest1Output.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

public interface RpcTest1Output {

    String getLfOutput();

}
----


===== notification statement
`notification` statement is mapped to the Java interface which extends
Notification interface.

Example of notification mapping:

.YANG model
[source, yang]
----
notification notif {
	}
----

.Notif.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379;


import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yangtools.yang.binding.Notification;

public interface Notif extends DataObject, Augmentable<Notif>, Notification {
}
----


==== augment statement
`augment` statement is mapped to the Java interface.
The interface starts with the same name as the name of augmented interface.
The suffix is order number of augmenting interface. The augmenting interface
also extends `Augmentation<>` with actual type parameter equal to augmented
interface.
Example of augment mapping. In this example is augmented interface `Cont`
so whole parametrized type is `Augmentation<Cont>`.


.YANG Model
[source, yang]
----
container cont {
}

augment "/cont" {
  leaf additional-value {
    type string;
  }
}
----

.Cont.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;

public interface Cont extends DataObject, Augmentable<Cont> {

}
----

.Cont1.java
[source, java]
----
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentation;

public interface Cont1 extends DataObject, Augmentation<Cont> {

}
----

==== YANG Type mapping

===== typedef statement
YANG typedef statement is mapped to Java class. Typedef may contain following
substatement:

[options="header"]
|===
|Substatement | Behaviour
|type| determines wrapped type and how class will be generated
|descripton| Javadoc description
|units| is not mapped
|default|is not mapped
|===

====== Valid Arguments Type

Simple values of type argument are mapped as follows:

[options="header"]
|===
|YANG Type |  Java type
|boolean| Boolean
|empty| Boolean
|int8| Byte
|int16|Short
|int32|Integer
|int64|Long
|string|String or, wrapper class (if pattern substatement is specified)
|decimal64|Double
|uint8|Short
|uint16|Integer
|uint32|Long
|uint64|BigInteger
|binary|byte[]
|===

Complex values of type argument are mapped as follows:

[options="header"]
|===
|Argument Type| Java type
|enumeration| generated java enum
|bits| generated class for bits
|leafref| same type as referenced leaf
|identityref| Class
|union| generated java class
|instance-identifier| `org.opendaylight.yangtools.yang.binding.InstanceIdentifier`
|===

===== Enumeration Substatement Enum
The YANG enumeration type has to contain some enum substatements. Enumeration is mapped as Java enum type (standalone class) and every YANG enum subelement is mapped to Java enum's predefined values.
Enum substatement can have following substatements:

[options="header"]
|===
|Enum's Substatement | Java mapping
|description|is not mapped in API
|value| mapped as input parameter for every predefined value of enum
|===

Example of maping of YANG enumeration to Java:

.YANG model
[source, yang]
----
typedef typedef-enumeration {
    type enumeration {
        enum enum1 {
            description "enum1 description";
            value 18;
        }
        enum enum2 {
            value 16;
        }
        enum enum3 {
        }
    }
}
----

.TypedefEnumeration.java
[source, java]
----
public enum TypedefEnumeration {
    Enum1(18),
    Enum2(16),
    Enum3(19);

    int value;

    private TypedefEnumeration(int value) {
        this.value = value;
    }
}
----

===== Bits's Substatement Bit
The YANG bits type has to contain some bit substatements. YANG Bits is mapped to
Java class (standalone class) and every YANG bits subelement is mapped to class
boolean attributes. In addition are overriden Object methods
`hash, toString, equals`.

.YANG Model
[source, yang]
----
typedef typedef-bits {
  type bits {
    bit first-bit {
      description "first-bit description";
        position 15;
      }
    bit second-bit;
  }
}
----

.TypedefBits.java
[source, java]
----
public class TypedefBits {

    private Boolean firstBit;
    private Boolean secondBit;

    public TypedefBits() {
        super();
    }

    public Boolean getFirstBit() {
        return firstBit;
    }

    public void setFirstBit(Boolean firstBit) {
        this.firstBit = firstBit;
    }

    public Boolean getSecondBit() {
        return secondBit;
    }

    public void setSecondBit(Boolean secondBit) {
        this.secondBit = secondBit;
    }

     @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result +
         ((firstBit == null) ? 0 : firstBit.hashCode());
        result = prime * result +
         ((secondBit == null) ? 0 : secondBit.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        TypedefBits other = (TypedefBits) obj;
        if (firstBit == null) {
            if (other.firstBit != null) {
                return false;
            }
        } else if(!firstBit.equals(other.firstBit)) {
            return false;
        }
        if (secondBit == null) {
            if (other.secondBit != null) {
                return false;
            }
        } else if(!secondBit.equals(other.secondBit)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("TypedefBits [firstBit=");
        builder.append(firstBit);
        builder.append(", secondBit=");
        builder.append(secondBit);
        builder.append("]");
        return builder.toString();
    }
}
----


===== Union's Substatement Type
If type of typedef is union it has to contain `type` substatements. Union typedef
is mapped to class and its `type` subelements are mapped to private class
attributes. For every YANG union subtype si generated own Java constructor with
a parameter which represent just one attribute.

Example to union mapping:

.YANG model
[source, yang]
----
typedef typedef-union {
    type union {
        type int32;
        type string;
    }
}
----

.TypdefUnion.java
[source, java]
----
public class TypedefUnion {

    private Integer int32;
    private String string;

    public TypedefUnion(Integer int32) {
        super();
        this.int32 = int32;
    }

    public TypedefUnion(String string) {
        super();
        this.string = string;
    }

    public Integer getInt32() {
        return int32;
    }

    public String getString() {
        return string;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((int32 == null) ? 0 : int32.hashCode());
        result = prime * result + ((string == null) ? 0 : string.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        TypedefUnion other = (TypedefUnion) obj;
        if (int32 == null) {
            if (other.int32 != null) {
                return false;
            }
        } else if(!int32.equals(other.int32)) {
            return false;
        }
        if (string == null) {
            if (other.string != null) {
                return false;
            }
        } else if(!string.equals(other.string)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("TypedefUnion [int32=");
        builder.append(int32);
        builder.append(", string=");
        builder.append(string);
        builder.append("]");
        return builder.toString();
    }
}
----

===== String Mapping
YANG String type can be detailed specified through type subelements length
and pattern which are mapped as follows:

[options="header"]
|===
|Type  subelement  |  Mapping to Java
| length | not mapped
| pattern |

. list of string constants = list of patterns +
. list of Pattern objects +
. static initialization block where list of Patterns is initialized from list of string of constants
|===

Example of YANG string mapping

.YANG model
[source, yang]
----
typedef typedef-string {
    type string {
        length 44;
        pattern "[a][.]*"
    }
}
----

.TypedefString.java
[source, java]
----
public class TypedefString {

    private static final List<Pattern> patterns = new ArrayList<Pattern>();
    public static final List<String> PATTERN`CONSTANTS = Arrays.asList("[a][.]*");

    static {
        for (String regEx : PATTERN`CONSTANTS) {
            patterns.add(Pattern.compile(regEx));
        }
    }

    private String typedefString;

    public TypedefString(String typedefString) {
        super();
        // Pattern validation
        this.typedefString = typedefString;
    }

    public String getTypedefString() {
        return typedefString;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((typedefString == null) ? 0 : typedefString.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        TypedefString other = (TypedefString) obj;
        if (typedefString == null) {
            if (other.typedefString != null) {
                return false;
            }
        } else if(!typedefString.equals(other.typedefString)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("TypedefString [typedefString=");
        builder.append(typedefString);
        builder.append("]");
        return builder.toString();
    }
}
----

==== identity statement
The purpose of the `identity` statement is to define a new globally unique,
abstract, and untyped value.

`base` substatement argument is the name of existing identity from which
the new identity is derived.

Given that, `identity` statement is mapped to *Java abstract class* and
`base` substatement is mapped as `extends` Java keyword.
The identity name is translated to class name.

.YANG Model
[source, yang]
----
identity toast-type {

}

identity white-bread {
   base toast-type;
}
----

===== Java Mapping

.ToastType.java
[source, java]
----
public abstract class ToastType extends BaseIdentity {
    protected ToastType() {
        super();
    }
}
----

.WhiteBread.java
[source, java]
----
public abstract class WhiteBread extends ToastType {
    protected WhiteBread() {
        super();
    }
}
----
