== Controller

=== OpenDaylight Controller: MD-SAL Developers' Guide

Model-Driven SAL (MD-SAL) is a set of infrastructure services aimed at providing common and generic support to application and plugin developers. 

MD-SAL currently provides infrastructure services for the following: 

* Data Services 
* RPC or Service routing 
* Notification subscription and publish services 

This model-driven infrastructure allows developers to develop applications and plugins against an API type of their choice (Java generated APIs, DOM APIs, REST APIs). The infrastructure automatically provides the other API types. 
The modelling language of choice for MD-SAL is YANG, which is an IETF standard, for modelling network element configuration. The YANGTools project and its development tools provide support for YANG.


=== API types

MD-SAL provides three API types: + 

* Java generated APIs for consumers and producers 
* DOM APIs: Mostly used by infrastucture components and usuful for XML-driven plugin and application types 
* REST APIs: https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Restconf[Restconf] that is available to consumer type applications and provides access to RPC and data stores 


=== Basic YANG concepts and their rendition in APIs

The following are the basic concepts in YANG modeling: +

* Remote Procedure (RPCs): In MD-SAL, RPCs are used for any call or invocation that crosses the plugin or module boundaries. RPCs are triggered by consumers, and usually have return values.
* Notifications: Asynchronous events, published by components for listeners.
* Configuration and Operational Data tree: The well-defined (by model) tree structure that represents the operational state of components and systems.
** Instance Identifier: The path that uniquely identifies the sub-tree in the configuration or operational space. Most of the addressing of data is done by Instance Identifier.

==== RPC
In YANG, Remote Procedure Calls (RPCs) are used to model any procedure call implemented by a Provider (Server), which exposes functionality to Consumers (Clients).

In MD-SAL terminology, the term 'RPC' is used to define the input and output for a procedure (function) that is to be provided by a Provider, and adapted by the MD-SAL.

In the context of the MD-SAL, there are three types of RPCs (RPC services): +

* Global: One service instance (implementation) per controller container or mount point
* Routed: Multiple service instances (implementations) per controller container or mount point

==== Global service 

* There is only one instance of a Global Service per controller instance. (Note that a controller instance can consist of a cluster of controller nodes.)

*Routing* +

* Binding-Aware MD-SAL (sal-binding)
** **Rpc Type**: Identified by a generated RpcService class and a name of a method invoked on that interface
* Binding-Independent MD-SAL (sal-dom)
** **Rpc Type**: Identified by a QName

==== Routed service ====

* There can be multiple instances (implementations) of a service per controller instance 
* Can be used for southbound plugins or for horizontal scaling (load-balancing) of northbound plugins (services) 

*Routing* +

Routing is done based on the contents of a message, for example, 'Node Reference'. The field in a message that is used for routing is specified in a YANG model by using the routing-reference statement from the yang-ext model. + 

* Binding Aware MD-SAL (sal-binding)
* RPC Type: Identified by an RpcService subclass and the name of the method invoked on that interface
* Instance Identifier: In a data tree, identifies the element instance that will be used as the route target. 
The used class is: +
----
org.opendaylight.yang.binding.InstanceIdentifier
----       

The Instance Identifier is learned from the message payload and from the model. +

* Binding Independent MD-SAL (sal-dom)
* RPC Type: Identified by a QName

* Instance Identifier: In a data tree, identifies the element instance that will be used as the route target. The used class is: +
----
org.opendaylight.yang.data.api.InstanceIdentifier
----
RPCs in various API types: +

* Java Generated APIs: For each model there is *Service interface. See https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping#Rpc[YANG Tools: Yang to Java mapping-RPC]  to understand how YANG statements maps to Service interface.
** Providers expose their implementation of *Service by registering their implementation to RpcProviderRegistry.
** Consumers get the *Service implementation from RpcConsumerRegistry. If the implementer uses a different API type, MD-SAL automatically translates data in the background.
* DOM APIs: RPCs are identified by QName.
** Providers expose their implementation of RPC identified by QName registering their RpcImplementation to RpcProvisionRegistry.
** Consumers get the *Service implementation from RpcConsumerRegistry. If the implementer uses different API type, MD-SAL automatically translates data in the background.
* REST APIs: RPCs are identified by the model name and their name.
* Consumers invoke RPCs by invoking POST operation to /restconf/operations/model-name:rpc-name.

==== Notification 
In YANG, Notifications represent asynchronous events, published by providers for listeners.

RPCs in various API types: +

* Java Generated APIs: For each model, there is *Listener interface and transfer object for each notification. See https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping#Notification[YANG Tools: Yang to Java mapping-Notification] to understand how YANG statements map to the Notifications interface.
** Providers publish notifications by invoking the publish method on NotificationPublishService.
** To receive notifications, consumers register their implementation of *Listener to NotificationBrokerService. If the notification publisher uses a different API type, MD-SAL automatically translates data in the background.
* DOM APIs: Notifications are represented only by XML Payload.
** Providers publish notifications by invoking the publish method on NotificationPublishService.
** To receive notifications, consumers register their implementation of *Listener to NotificationBrokerService. If the notification publisher uses a different API type, MD-SAL automatically translates data in the background.
* REST APIs: Notifications are currently not supported.

==== Instance Identifier

The Instance Identifier is the unique identifier of an element (location) in the yang data tree: basically, it is the *path* to the node that uniquely identifies all the parent nodes of the node. The unique identification of list elements requires the specification of key values as well.

MD-SAL currently provides three different APIs to access data in the common data store: +

* Binding APIs (Java generated DTOs)
* DOM APIs
* https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Restconf[OpenDaylight Controller:MD-SAL Restconf APIs]
 
*Example* +

Consider the following simple YANG model for inventory: +
----
module inventory {
    namespace "urn:opendaylight:inventory";
    prefix inv;
    revision "2013-06-07";
    container nodes {
        list node {
            key "id";
            leaf "id" {
                type "string";
            }
        }
    }
}
----
*An example having one instance of node with the name _foo_* +

Let us assume that we want to create an instance identifier for the node foo in the following bindings or formats: +


*  **YANG / XML / XPath version**
----
/inv:nodes/inv:node[id="foo"]
----
* **Binding-Aware version (generated APIs)**
----
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.Nodes;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.Node;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.NodeKey;

import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;

InstanceIdentifier<Node> identifier = InstanceIdentifier.builder(Nodes.class).child(Node.class,new NodeKey("foo")).toInstance();
----
NOTE: The last call, _toInstance()_ does not return an instance of the node, but the Java version of Instance identifier which uniquely identifies the node *foo*.

* **HTTP Restconf APIs** +
----
http://localhost:8080/restconf/config/inventory:nodes/node/foo
----
NOTE: We assume that HTTP APIs are exposed on localhost, port 8080.

* **Binding Independent version (yang-data-api)**
----
import org.opendaylight.yang.common.QName;
import org.opendaylight.yang.data.api.InstanceIdentifier;

QName nodes = QName.create("urn:opendaylight:inventory","2013-06-07","nodes");
QName node = QName.create(nodes,"nodes");
QName idName = QName.create(nodes,"id");
InstanceIdentifier = InstanceIdentifier.builder()
    .node(nodes)
    .nodeWithKey(node,idName,"foo")
    .toInstance();
----
NOTE: The last call, _toInstance()_ does not return an instance of node, but the Java version of Instance identifier which uniquely identifies the node *foo*.

=== MD-SAL: Plugin types
MD-SAL has four component-types that differ in complexity, expose different models, and use different subsets of the MD-SAL functionality.

* Southbound Protocol Plugin: Responsible for handling multiple sessions to the southbound network devices and providing common abstracted interface to access various type of functionality provided by these network devices
* Manager-type application: Responsible for managing the state and the configuration of a particular functionality which is exposed by southbound protocol plugins
* Protocol Library: Responsible for handling serialization or de-serialization between the wire protocol format and the Java form of the protocol 
* Connector Plugin: Responsible for connecting consumers (and providers) to Model-driven SAL (and other components) by means of different wire protocol or set of APIs

==== Southbound protocol plugin

The responsibilities of the Southbound Protocol plugin include the following :

* Handling multiple sessions to southbound network devices
* Providing a common abstracted interface to access various type of functionality provided by the network devices

The Southbound Protocol Plugin should be stateless. The only preserved state (which is still transient) is the list of connected devices or sessions. Models mostly use RPCs and Notifications to describe plugin functionality
Example plugins: Openflow Southbound Plugin, Netconf Southbound Plugin, BGP Southbound Plugin, and PCEP Southbound Plugin.

==== Manager-type application

The responsibilities of the Manager-type applications include the following:

* Providing configuration-like functionality to set or modify the behaviour of network elements or southbound plugins
* Coordinating flows and provide higher logic on top of stateless southbound plugins

Manager-type Applications preserve state. Models mostly use Configuration Data and Runtime Data to describe component functionality.

=== Protocol library
The OpenFlow Protocol Library is a component in OpenDaylight, that mediates communication between the OpenDaylight controller and the hardware devices supporting the OpenFlow protocol. The primary goal of the library is to provide user (or upper layers of OpenDaylight) communication channel, that can be used for managing network hardware devices. 

=== MD-SAL: Southbound plugin development guide 
The southbound controller plugin is a functional component. 

The plugin: +

* Provides an abstraction of network devices functionality
* Normalizes their APIs to common contracts
* Handles session and connections to them

The plugin development process generally moves through the following phases: +

. Definition of YANG models (API contracts): For Model-Driven SAL, the API contracts are defined by YANG models and the Java interfaces generated for these models. A developers opts for one of the following: +
** Selects from existing models
** Creates new models 
** Augments (extends) existing models
[start=2]
. Code Generation: The Java Interfaces, implementation of Transfer Objects, and mapping to Binding-Independent form is generated for the plugin. This phase requires the proper configuration of the Maven build and YANG Maven Tools.
. Implementation of plugin: The actual implementation of the plugin functionality and plugin components.

NOTE: The order of steps is not definitive, and it is up to the developer to find the most suitable workflow. For additional information, see <<_best_practices>>.

=== Definition of YANG models

In this phase, the developer selects from existing models (provided by controller or other plugins), writes new models, or augments existing ones. A partial list of available models could be found at:
https://wiki.opendaylight.org/view/YANG_Tools:Available_Models[YANG Tools:Available Models].

The mapping of YANG to Java is documented at: https://wiki.opendaylight.org/view/Yang_Tools:YANG_to_Java_Mapping[Yang Tools:YANG to Java Mapping.] This mapping provides an overview of how YANG is mapped to Java.

Multiple approaches to model the functionality of the southbound plugin are available: +

* Using RPCs and Notifications
* Using Configuration Data Description
* Using Runtime Data Description
* Combining approaches

=== RPCs

RPCs can model the functionality invoked by consumers (applications) that use the southbound plugin. Although RPCs can model any functionality, they are usually used to model functionality that cannot be abstracted as configuration data, for example, PacketOut, or initiating a new session to a device (controller-to-device session).

RPCs are modeled with an RPC statement in the following form: +
+rpc foo {}+ +
This statement is mapped to method. +

*RPC input* +
To define RPC input, use an input statement inside RPC. The structure of the input is defined with the same statements as the structure of notifications, configuration, and so on.
----
 rpc foo {
    input {
       ...
    }
 }
----
*RPC output* +
To define the RPC output (structure of result), use the RPC output statement. +
----
 rpc foo {
   output {
      ...
   }
 }
----
*Notifications* +
Use notifications to model events originating in a network device or southbound plugin which is exposed to consumers to listen.


A notification statement defines a notification:
----
   notification foo {
      ...
   }
----
*Configuration data* +

Configuration data is good for the following purposes: +

* Model or provide CRUD access to the state of protocol plugin and/or network devices 
* Model any functionality which could be exposed as a configuration to the consumers or applications

Configuration data in YANG is defined by using the config substatement with a true argument. For example: +
----
  container foo {
     config true;
     ...
  }
----
*Runtime (read-only) data* +
Runtime (read-only) data is good to model or provide read access to the state of the protocol plugin and networtk devices, or network devices. This type of data is good to model statistics or any state data, which cannot be modified by the consumers (applications), but needs exposure (for example, learned topology, or list of connected switches).

Runtime data in YANG is defined by using config subsatement with a false argument:
----
  container foo {
     config false;
  }
----
*Structural elements* +
The structure of RPCs, notifications, configuration data, and runtime data is modelled using structural elements (data schema nodes). Structural elements define the actual structure of XML, DataDOM documents, and Java APIs for accessing or storing these elements. The most commonly used structural elements are: +

* Container
* List
* Leaf
* Leaf-list
* Choice

=== Augmentations +
Augmentations are used to extend existing models by providing additional structural elements and semantics. Augmentation cannot change the mandatory status of nodes in the original model, or introduce any new mandatory statements.

=== Best practices

* YANG models must be located under the src/main/yang folder in your project.
* Design your models so that they are reusable and extendible by third-parties.
* Always try to reuse existing models and types provided by these models. See https://wiki.opendaylight.org/view/YANG_Tools:Available_Models[YANG Tools:Available Models] or others if there is no model which provides you with data structures and types you need.

*Code generation* +
To configure your project for code generation, your build system needs to use Maven. For the configuration of java API generation, see https://wiki.opendaylight.org/view/Yang_Tools:Maven_Plugin_Guide[Yang Tools:Maven Plugin Guide].

*Artefacts generated at compile time* +
The following artefacts are generated at compile time: +

* Service interfaces
* Transfer object interfaces
* Builders for transfer objects and immutable versions of transfer objects

=== Implementation +
This step uses generated artefacts to implement the intended functionality of the southbound plugin. +

*Provider implementation* +
To expose functionality through binding-awareness, the MD-SAL plugin needs to be compiled against these APIs, and must at least implement the BindingAwareProvider interface.
The provider uses APIs which are available in the SAL-binding-api Maven artifact. To use this dependency, insert the following dependency into your pom.xml:
----
<dependency>
       <groupId>org.opendaylight.controller</groupId>
       <artifactId>sal-binding-api</artifactId>
       <version>1.0-SNAPSHOT</version>
   </dependency>
----

*BindingAwareProvider implementation* +
A BindingAwareProvider interface requires the implementation of four methods, and registering an instance with BindingAwareBroker. Use AbstractBindingAwareProvider to simplify the implementation.

* void onSessionInitialized(ConsumerContext ctx): This callback is called when Binding-Aware Provider is initialized and ConsumerContext is injected into it. ConsumerContext serves to access all functionality which the plugin is to consume from other controller components.
* void onSessionInitialized(ProviderContext ctx): This callback is called when Binding-Aware Provider is initialized and ProviderContext is injected into it. ProviderContext serves to access all functionality which the plugin could use to provide its functionality to controller components.
* Collection<? extends RpcService> getImplementations(): Shorthand registration of an already instantiated implementations of global RPC services. Automated registration is currently not supported.
* public Collection<? extends ProviderFunctionality> getFunctionality(): Shorthand registration of an already instantiated implementations of ProviderFunctionality. Automated registration is currently not supported.
NOTE: You also need to set your implementation of AbstractBindingAwareProvider set as Bundle Activator for MD-SAL to properly load it.

=== Notifications 
To publish events, request an instance of NotificationProviderService from ProviderContext. Use the following:
----
   ExampleNotification notification = (new ExampleNotificationBuilder()).build();
   NotificationProviderService notificationProvider = providerContext.getSALService(NotificationProviderService.class);
   notificationProvider.notify(notification);
----
*RPC implementations* +
To implement the functionality exposed as RPCs, implement the generated RpcService interface. Register the implementation within ProviderContext included in the provider.

If the generated RpcInterface is FooService, and the implementation is FooServiceImpl:
----
   @Override
   public void onSessionInitiated(ProviderContext context) {
       context.addRpcImplementation(FooService.class, new FooServiceImpl());
   }
----
=== Best practices

RPC Service interface contract requires you to return http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html[Future object] (to make it obvious that call may be asynchronous), but it is not specified how this Future is implemented. Consider using existing implementations provided by JDK or Google Guava. Implement your own Future only if necessary.

Consider using http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/SettableFuture.html[SettableFuture] if you intend not to use http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/FutureTask.html[FutureTask] or submit http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html[Callables] to http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html[ExecutorService].

IMPORTANT: Do not implement transfer object interfaces unless necessary. Choose already generated builders and immutable versions. If you want to implement transfer objects, ensure that instances exposed outside the plugin are immutable.

=== OpenDaylight Controller: MD-SAL FAQs

*Q-1: What is the overall MD-SAL architecture?*

* **What is the overall architecture, components, and functionality?** 
* **Who supplies which components, and how are the components plumbed?**

*A-1:* The overall Model-Driven SAL (MD-SAL) architecture did not really change from the API-Driven SAL (AD-SAL). As with the AD-SAL, plugins can be data providers, or data consumers, or both (although the AD-SAL did not explicitly name them as such). Just like the AD-SAL, the MD-SAL connects data consumers to appropriate data providers and (optionally) facilitates data adaptation between them. 

Now, in the AD-SAL, the SAL APIs request routing between consumers and providers, and data adaptations are all statically defined at compile or build time. In the MD-SAL, the SAL APIs and request routing between consumers and providers are defined from models, and data adaptations are provided by 'internal' adaptation plugins. The API code is generated from models when a plugin is compiled. When the plugin OSGI bundle is loaded into the controller, the API code is loaded into the controller along with the rest of the plugin containing the model.

.AD-SAL and MD-SAL
image::MD-SAL.png[]

The AD-SAL provides request routing (selects an SB plugin based on service type) and optionally provides service adaptation, if an NB (Service, abstract) API is different from its corresponding SB (protocol) API. For example, in the above figure, the AD-SAL routes requests from NB-Plugin 1 to SB Plugins 1 and 2. Note that the plugin SB and NB APIs in this example are essentially the same (although both of them need to be defined). Request routing is based on plugin type: the SAL knows which node instance is served by which plugin. When an NB Plugin requests an operation on a given node, the request is routed to the appropriate plugin which then routes the request to the appropriate node. The AD-SAL can also provide service abstractions and adaptations. For example, in the above figure, NB Plugin 2 is using an abstract API to access the services provided by SB Plugins 1 and 2. The translation between the SB Plugin API and the abstract NB API is done in the Abstraction module in the AD-SAL.

The MD-SAL provides request routing and the infrastructure to support service adaptation. However, it does not provide service adaptation itself: service adaptation is provided by plugins. From the point of view of MD-SAL, the Adaptation Plugin is a regular plugin. It provides data to the SAL, and consumes data from the SAL through APIs generated from models. An Adaptation Plugin basically performs model-to-model translations between two APIs. Request Routing in the MD-SAL is done on both protocol type and node instances, since node instance data is exported from the plugin into the SAL (the model data contains routing information). 

The simplest MD-SAL APIs generated from models (RPCs and Notifications, both supported in the yang modeling language) are functionally equivalent to AD-SAL function call APIs. Additionally, the MD-SAL can store data for models defined by plugins. Provider and consumer plugins can exchange data through the MD-SAL storage. Data in the MD-SAL is accessed through getter and setter APIs generated from models. Note that this is in contrast to the AD-SAL, which is stateless.

Note that in the above figure, both NB AD-SAL Plugins provide REST APIs to controller client applications.

The functionality provided by the MD-SAL is basically to facilitate the plumbing between providers and consumers. A provider or a consumer can register itself with the MD-SAL. A consumer can find a provider that it is interested in. A provider can generate notifications; a consumer can receive notifications and issue RPCs to get data from providers. A provider can insert data into SAL storage; a consumer can read data from SAL storage. 

Note that the structure of SAL APIs is different in the MD-SAL from that in the AD-SAL. The AD-SAL typically has both NB and SB APIs even for functions or services that are mapped 1:1 between SB Plugins and NB Plugins. For example, in the current AD-SAL implementation of the OpenFlow Plugin and applications, the NB SAL APIs used by OF applications are mapped 1:1 onto SB OF Plugin APIs. The MD-SAL allows both the NB plugins and SB plugins to use the same API generated from a model. One plugin becomes an API (service) provider; the other becomes an API (service) Consumer. This eliminates the need to define two different APIs and to provide three different implementations even for cases where APIs are mapped to each other 1:1. The MD SAL provides instance-based request routing between multiple provider plugins. 

*Q-2: What functionality does the MD-SAL assume? For example, does the SAL assume that the network model is a part of the SAL?*

*A-2:* The MD-SAL does not assume any model. All models are provided by plugins. The MD-SAL only provides the infrastructure and the plumbing for the plugins.


*Q-3: What is the "day in the life" of an MD-SAL plugin?*


*A-3:* All plugins (protocol, application, adaptation, and others) have the same lifecycle. The life of a plugin has two distinct phases: design and operation. + 
During the design phase, the plugin designer performs the following actions:  +

* The designer decides which data will be consumed by the plugin, and imports the SAL APIs generated from the API provider’s models. Note that the topology model is just one possible data type that may be consumed by a plugin. The list of currently available data models and their APIs can be found in YANG_Tools:Available_Models. 
* The designer decides which data and how it will be provided by the plugin, and designs the data model for the provided data. The data model (expressed in yang) is then run through the https://wiki.opendaylight.org/view/YANG_Tools:Available_Models[YANG Tools], which generate the SAL APIs for the model. 
* The implementations for the generated consumer and provider APIs, along with other plugin features and functionality, are developed. The resulting code is packaged in a “plugin” OSGI bundle. Note that a developer may package the code of a subsystem in multiple plugins or applications that may communicate with each other through the SAL. 
* The generated APIs and a set of helper classes are also built and packaged in an “API” OSGI bundle. 

The plugin development process is shown in the following figure. +

.Plugin development process
image::plugin-dev-process.png[]

When the OSGI bundle of a plugin is loaded into the controller and activated, the operation phase begins. The plugin operation is probably best explained with a few examples describing the operation of the OF Protocol plugin and OF applications, such as the Flow Programmer Service, the ARP Handler, or the Topology Manager. The following figure shows a scenario where a “Flow Deleted” notification from a switch arrives at the controller.

.Flow deleted at controller
image::flow-deleted-at-controller.png[]

The scenario is as follows: +

. The Flow Programmer Service registers with the MD SAL for the `Flow Deleted' notification. This is done when the Controller and its plugins or applications are started. 
. A `Flow Deleted' OF packet arrives at the controller. The OF Library receives the packet on the TCP/TLS connection to the sending switch, and passes it to the OF Plugin. 
. The OF Plugin parses the packet, and uses the parsed data to create a `Flow Deleted' SAL notification. The notification is actually an immutable `Flow Deleted' Data Transfer Object (DTO) that is created or populated by means of methods from the model-generated OF Plugin API. 
. The OF Plugin sends the `Flow Deleted' SAL notification (containing the notification DTO) into the SAL. The SAL routes the notification to registered consumers, in this case, the Flow Programmer Service. 
. The Flow Programmer Service receives the notification containing the notification DTO. 
. The Flow Programmer Service uses methods from the API of the model-generated OF Plugin to get data from the immutable notification DTO received in Step 5. The processing is the same as in the AD-SAL. 

Note that other packet-in scenarios, where a switch punts a packet to the controller, such as an ARP or an LLDP packet, are similar. Interested applications register for the respective notifications. The OF plugin generates the notification from received OF packets, and sends them to the SAL. The SAL routes the notifications to the registered recipients. +
The following figure shows a scenario where an external application adds a flow by means of the NB REST API of the controller. 

.External app adds flow
image::md-sal-faqs-add_flow.png[]

The scenario is as follows: +

. Registrations are performed when the Controller and its plugins or applications are started. 

.. The Flow Programmer Service registers with the MD SAL for Flow configuration data notifications.
.. The OF Plugin registers (among others) the ‘AddFlow’ RPC implementation with the SAL. 
Note that the RPC is defined in the OF Plugin model, and the API is generated during build time. + 
[start=2]
. A client application requests a flow add through the REST API of the Controller. (Note that in the AD-SAL, there is a dedicated NB REST API on top of the Flow Programming Service. The MD-SAL provides a common infrastructure where data and functions defined in models can be accessed by means of a common REST API. For more information, see http://datatracker.ietf.org/doc/draft-bierman-netconf-restconf/). The client application provides all parameters for the flow in the REST call. 
. Data from the ‘Add Flow’ request is deserialized, and a new flow is created in the Flow Service configuration data tree. (Note that in this example the configuration and operational data trees are separated; this may be different for other services). Note also that the REST call returns success to the caller as soon as the flow data is written to the configuration data tree. 
. Since the Flow Programmer Service is registered to receive notifications for data changes in the Flow Service data tree, the MD-SAL generates a ‘data changed’ notification to the Flow Programmer Service. 
. The Flow Programmer Service reads the newly added flow, and performs a flow add operation (which is basically the same as in the AD-SAL). 
. At some point during the flow addition operation, the Flow Programmer Service needs to tell the OF Plugin to add the flow in the appropriate switch. The Flow Programmer Service uses the OF Plugin generated API to create the RPC input parameter DTO for the “AddFlow” RPC of the OF Plugin. 
. The Flow Programmer Service gets the service instance (actually, a proxy), and invokes the “AddFlow” RPC on the service. The MD-SAL will route the request to the appropriate OF Plugin (which implements the requested RPC). 
. The `AddFlow' RPC request is routed to the OF Plugin, and the implementation method of the “AddFlow” RPC is invoked. 
. The `AddFlow' RPC implementation uses the OF Plugin API to read values from the DTO of the RPC input parameter. (Note that the implementation will use the getter methods of the DTO generated from the yang model of the RPC to read the values from the received DTO.) 
. The `AddFlow' RPC is further processed (pretty much the same as in the AD-SAL) and at some point, the corresponding flowmod is sent to the corresponding switch. 

*Q-4: Is there a document that describes how code is generated from the models for the MD-SAL?*

*A-4:* https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping[Yangtools] documents the Yang to Java generation, including examples of how the yang constructs are mapped into Java classes. You can write unit tests against the generated code. You will have to write implementations of the generated RPC interfaces. The generated code is just Java, and it debugs just like Java. 

If you want to play with generating Java from Yang there is a maven archetype to help you get going: https://wiki.opendaylight.org/view/Maven_Archetypes:odl-model-project[Maven Archetypes: ODL Model Project]. +
Or, you can try creating a project in Eclipse as explained at: http://sdntutorials.com/yang-to-java-conversion-how-to-create-maven-project-in-eclipse/[YANG to Java conversion: How to create Maven project in Eclipse]. 

*Q-5: The code generation tools mention 'producers' and consumers'. How are these related to 'southbound' and 'northbound SAL plugins?*

*A-5:* The difference between southbound and northbound plugins is that the southbound plugins talk protocols to network nodes, and northbound plugins talk application APIs to the controller applications. As far as the SAL is concerned, there is really no north or south. The SAL is basically a data exchange and adaptation mechanism between plugins. The plugin SAL roles (consumer or producer) are defined with respect to the data being moved around or stored by the SAL. A producer implements an API, and provides the data of the API: a consumer uses the API, and consumes the data of the API. +
While 'northbound' and 'southbound' provide a network engineer's view of the SAL, 'consumer' and 'producer' provide a software engineer's view of the SAL, and is shown in the following figure: 

.SAL consumer and producer view

image::mdsal-sal-sw-eng.png[]

*Q-6: Where can I find models that have already been defined in OpenDaylight?*

*A-6:* The list of models that have been defined for the SAL and in various plugins can be found in https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Model_Reference[MD-SAL Model Reference].

*Q-7: How do I migrate my existing plugins and services to MD-SAL?*

*A-7:* The migration guide can be found in the https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Application_Migration_Guide[MD-SAL Application Migration Guide].

*Q-8: Where can I find SAL example code?*

*A-8:* The toaster sample provides a simple yet complete example of a model, a service provider (toaster), and a service consumer. It provides the model of a programmable toaster, a sample consumer application that uses MD-SAL APIs; a sample southbound plugin (a service provider) that implements toaster; and a unit test suite. 

The toaster example is in _controller.git_ under _opendaylight/md-sal/samples_.

*Q-9: Where is the REST API code for the example?*

*A-9:* The REST APIs are derived from models. You do not have to write any code for it. The controller will implement the http://datatracker.ietf.org/doc/draft-bierman-netconf-restconf/[RESTCONF protocol] which defines access to yang-formatted data through REST. Basically, all you need to do is define your service in a model, and expose that model to the SAL. REST access to your modeled data will then be provided by the SAL infrastructure. However, if you want to, you can create your own REST API (for example, to be compliant with an existing API). 

*Q-10: How can one use RESTCONF to access the MD-SAL datastore?*

*A-10:* For information on accessing the MD-SAL datastore, see https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Restconf[MD-SAL Restconf].
 
=== OpenDaylight Controller Configuration: Java Code Generator

==== YANG to Java code generator

The Java code for the configuration system is generated by the yang-maven-plugin and the yang-jmx-generator-plugin. 
The input Yang module files are converted to java files by the definition of the module and the specified templates. the generated java code can represent interfaces, classes, or abstract classes used for configuration. 

=== Service interfaces generating

Service interfaces (SI) are generated from YANG "service-types". Each SI must be defined as "identity" with a "base" statement set to "config:service-type", or another SI. This is because a service must have a globally unique name.
 Each SI must be annotated with @ServiceInterfaceAnnotation, and must extend AbstractServiceInterface. 

*Sample YANG module representing service interface* +
 
----
module config-test {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:test";
    prefix "test";
 
    import config { prefix config; revision-date 2013-04-05; }
 
    description
        "Testing API";
 
    revision "2013-06-13" {
        description
            "Initial revision";
    }
 
    identity testing {
        description
            "Test api";
 
        base "config:service-type";
        config:java-class "java.lang.AutoCloseable";
    }
}
----
The "description" node of identity is generated as javadoc in the service interface. +
The "config:java-class" is generated as *ServiceInterfaceAnnotation*. It specifies java classes or interfaces in the "osgiRegistrationTypes" parameter. The module implementing this service interface must instantiate a java object that can be cast to any of the java types defined in "osgiRegistrationTypes".

*Generated java source file: AutoCloseableServiceInterface* +
----
package %prefix%.test;
 
/**
* Test api
*/
@org.opendaylight.controller.config.api.annotations.Description(value = "Test api")
@org.opendaylight.controller.config.api.annotations.ServiceInterfaceAnnotation(value = "testing", osgiRegistrationType = java.lang.AutoCloseable.class)
public interface AutoCloseableServiceInterface extends org.opendaylight.controller.config.api.annotations.AbstractServiceInterface
{
 
}
---- 

==== Module stubs generating

Modules are constructed during configuration transaction. A module implements the ModuleMXBean interface. The ModuleMXBean interface represents getters and setters for attributes that will be exposed to the configuration registry by means of JMX. Attributes can either be simple types, or composite types.

Each ModuleMXBean must be defined in yang as "identity" with the base statement set to "config:module-type". Not only are ModuleMXBeans generated, but also ModuleFactory and Module stubs. Both are first generated as abstract classes with almost full functionality. Then their implementations, which are allowed to be modified by users, are generated, but only once. 

=== Runtime beans generating

Runtime JMX beans are purposed to be the auditors: they capture data about running module instances. A module can have zero or more runtime beans. Runtime beans are hierarchically ordered, and each must be uniquely identified. 
 A runtime bean is defined as a configuration augment of a module, from which interface RuntimeMXBean, RuntimeRegistrator, and RuntimeRegistretion are generated. Augment definition contains arguments representing the data of a module that must be watched. 

==== RPCs

Method calls in yang must be specified as top level elements. The context, where an RPC operation exits, must be defined in the RPC definition itself, and in the runtime bean that provides method implementation.

=== OpenDaylight Controller MD-SAL: Restconf

==== Restconf operations overview

Restconf allows access to datastores in the controller. +
There are two datastores: +

* Config: Contains data inserted via controller 
* Operational: Contains other data 

NOTE: Each request must start with the URI /restconf. + 
Restconf listens on port 8080 for HTTP requests.

Restconf supports *OPTIONS*, *GET*, *PUT*, *POST*, and *DELETE* operations. Request and response data can either be in the XML or JSON format. XML structures according to yang are defined at: http://tools.ietf.org/html/rfc6020[XML-YANG]. JSON structures are defined at: http://tools.ietf.org/html/draft-lhotka-netmod-yang-json-02[JSON-YANG]. Data in the request must have a correctly set *Content-Type* field in the http header with the allowed value of the media type. The media type of the requested data has to be set in the *Accept* field. Get the media types for each resource by calling the OPTIONS operation. 
Most of the paths of the pathsRestconf endpoints use https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Concepts#Instance_Identifier[Instance Identifier]. +<identifier>+ is used in the explanation of the operations. 

*<identifier>* +

* It must start with <moduleName>:<nodeName> where <moduleName> is a name of the module and <nodeName> is the name of a node in the module. It is sufficient to just use <nodeName> after <moduleName>:<nodeName>. Each <nodeName> has to be separated by /. 
* <nodeName> can represent a data node which is a list or container yang built-in type. If the data node is a list, there must be defined keys of the list behind the data node name for example, <nodeName>/<valueOfKey1>/<valueOfKey2>. 
* The format <moduleName>:<nodeName> has to be used in this case as well: + 
Module A has node A1. Module B augments node A1 by adding node X. Module C augments node A1 by adding node X. For clarity, it has to be known which node is X (for example: C:X). 
For more details about encoding, see: http://tools.ietf.org/html/draft-bierman-netconf-restconf-02#section-5.3.1[Restconf 02 - Encoding YANG Instance Identifiers in the Request URI.] 

=== Mount point
A Node can be behind a mount point. In this case, the URI has to be in format <identifier>/*yang-ext:mount*/<identifier>. The first <identifier> is the path to a mount point and the second <identifier> is the path to a node behind the mount point. A URI can end in a mount point itself by using <identifier>/*yang-ext:mount*. +
More information on how to actually use mountpoints is available at: https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:Netconf[ OpenDaylight Controller:Config:Examples:Netconf].

==== HTTP methods

===== OPTIONS /restconf +
 
* Returns the XML description of the resources with the required request and response media types in Web Application Description Language (WADL) 

===== GET /restconf/config/<identifier> +

* Returns a data node from the Config datastore. 
* <identifier> points to a data node which must be retrieved. 

===== GET /restconf/operational/<identifier> +

* Returns the value of the data node from the Operational datastore. 
* <identifier> points to a data node which must be retrieved. 

===== PUT /restconf/config/<identifier>

* Updates or creates data in the Config datastore and returns the state about success. 
* <identifier> points to a data node which must be stored.

*Example:* +
---- 
PUT http://<controllerIP>:8080/restconf/config/module1:foo/bar
Content-Type: applicaton/xml
<bar>
  …
</bar>
----
*Example with mount point:* +
---- 
PUT http://<controllerIP>:8080/restconf/config/module1:foo1/foo2/yang-ext:mount/module2:foo/bar
Content-Type: applicaton/xml
<bar>
  …
</bar>
----
===== POST /restconf/config
* Creates the data if it does not exist 

For example: +
----
POST URL: http://localhost:8080/restconf/config/
content-type: application/yang.data+json
JSON payload:

   {
     "toaster:toaster" :
     {
       "toaster:toasterManufacturer" : "General Electric",
       "toaster:toasterModelNumber" : "123",
       "toaster:toasterStatus" : "up"
     }
  }
----
===== POST /restconf/config/<identifier>

* Creates the data if it does not exist in the Config datastore, and returns the state about success. 
* <identifier> points to a data node where data must be stored. 
* The root element of data must have the namespace (data are in XML) or module name (data are in JSON.) 

*Example:* +
----
POST http://<controllerIP>:8080/restconf/config/module1:foo
Content-Type: applicaton/xml/
<bar xmlns=“module1namespace”>
  …
</bar>
----
*Example with mount point:*
---- 
http://<controllerIP>:8080/restconf/config/module1:foo1/foo2/yang-ext:mount/module2:foo
Content-Type: applicaton/xml
<bar xmlns=“module2namespace”>
  …
</bar>
----
===== POST /restconf/operations/<moduleName>:<rpcName>
 
* Invokes RPC. 
* <moduleName>:<rpcName> - <moduleName> is the name of the module and <rpcName> is the name of the RPC in this module. 
* The Root element of the data sent to RPC must have the name “input”. 
* The result can be the status code or the retrieved data having the root element “output”. 

*Example:* +
---- 
POST http://<controllerIP>:8080/restconf/operations/module1:fooRpc
Content-Type: applicaton/xml
Accept: applicaton/xml
<input>
  …
</input>

The answer from the server could be:
<output>
  …
</output>
----
*An example using a JSON payload:* +
----
POST http://localhost:8080/restconf/operations/toaster:make-toast
Content-Type: application/yang.data+json
{
  "input" :
  {
     "toaster:toasterDoneness" : "10",
     "toaster:toasterToastType":"wheat-bread" 
  }
}
----

NOTE: Even though this is a default for the toasterToastType value in the yang, you still need to define it. 

===== DELETE /restconf/config/<identifier>

* Removes the data node in the Config datastore and returns the state about success. 
* <identifier> points to a data node which must be removed. 

More information is available in the http://tools.ietf.org/html/draft-bierman-netconf-restconf-02[Restconf RFC].

==== How Restconf works
Restconf uses these base classes: +

InstanceIdentifier:: Represents the path in the data tree 
ConsumerSession:: Used for invoking RPCs 
DataBrokerService:: Offers manipulation with transactions and reading data from the datastores 
SchemaContext:: Holds information about yang modules 
MountService:: Returns MountInstance based on the InstanceIdentifier pointing to a mount point 
MountInstace:: Contains the SchemaContext behind the mount point 
DataSchemaNode:: Provides information about the schema node 
SimpleNode:: Possesses the same name as the schema node, and contains the value representing the data node value 
CompositeNode:: Can contain CompositeNode-s and SimpleNode-s 

==== GET in action
Figure 1 shows the GET operation with URI restconf/config/M:N where M is the module name, and N is the node name.


.Get
image::Get.png[width=500]

. The requested URI is translated into the InstanceIdentifier which points to the data node. During this translation, the DataSchemaNode that conforms to the data node is obtained. If the data node is behind the mount point, the MountInstance is obtained as well. 
. Restconf asks for the value of the data node from DataBrokerService based on InstanceIdentifier. 
. DataBrokerService returns CompositeNode as data. 
. StructuredDataToXmlProvider or StructuredDataToJsonProvider is called based on the *Accept* field from the http request. These two providers can transform CompositeNode regarding DataSchemaNode to an XML or JSON document. 
. XML or JSON is returned as the answer on the request from the client. 

==== PUT in action

Figure 2 shows the PUT operation with the URI restconf/config/M:N where M is the module name, and N is the node name. Data is sent in the request either in the XML or JSON format.

.Put

image::Put.png[width=500] 

. Input data is sent to JsonToCompositeNodeProvider or XmlToCompositeNodeProvider. The correct provider is selected based on the Content-Type field from the http request. These two providers can transform input data to CompositeNode. However, this CompositeNode does not contain enough information for transactions. 
. The requested URI is translated into InstanceIdentifier which points to the data node. DataSchemaNode conforming to the data node is obtained during this translation. If the data node is behind the mount point, the MountInstance is obtained as well. 
. CompositeNode can be normalized by adding additional information from DataSchemaNode. 
. Restconf begins the transaction, and puts CompositeNode with InstanceIdentifier into it. The response on the request from the client is the status code which depends on the result from the transaction. 

=== Something practical

. Create a new flow on the switch openflow:1 in table 2. 

*HTTP request* +
----
Operation: POST
URI: http://192.168.11.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:1/table/2
Content-Type: application/xml
----
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<flow 
    xmlns="urn:opendaylight:flow:inventory">
    <strict>false</strict>
    <instructions>
        <instruction>
          	<order>1</order>
            <apply-actions>
                <action>
                  <order>1</order>
                    <flood-all-action/>
                </action>
            </apply-actions>
        </instruction>
    </instructions>
    <table_id>2</table_id>
    <id>111</id>
    <cookie_mask>10</cookie_mask>
    <out_port>10</out_port>
    <installHw>false</installHw>
    <out_group>2</out_group>
    <match>
        <ethernet-match>
            <ethernet-type>
                <type>2048</type>
            </ethernet-type>
        </ethernet-match>
        <ipv4-destination>10.0.0.1/24</ipv4-destination>
    </match>
    <hard-timeout>0</hard-timeout>
    <cookie>10</cookie>
    <idle-timeout>0</idle-timeout>
    <flow-name>FooXf22</flow-name>
    <priority>2</priority>
    <barrier>false</barrier>
</flow>
---- 
*HTTP response* +
---- 
Status: 204 No Content
----
[start=2]
. Change _strict_ to _true_ in the previous flow.

*HTTP request* +
----
Operation: PUT
URI: http://192.168.11.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:1/table/2/flow/111
Content-Type: application/xml
----
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<flow 
    xmlns="urn:opendaylight:flow:inventory">
    <strict>true</strict>
    <instructions>
        <instruction>
          	<order>1</order>
            <apply-actions>
                <action>
                  <order>1</order>
                    <flood-all-action/>
                </action>
            </apply-actions>
        </instruction>
    </instructions>
    <table_id>2</table_id>
    <id>111</id>
    <cookie_mask>10</cookie_mask>
    <out_port>10</out_port>
    <installHw>false</installHw>
    <out_group>2</out_group>
    <match>
        <ethernet-match>
            <ethernet-type>
                <type>2048</type>
            </ethernet-type>
        </ethernet-match>
        <ipv4-destination>10.0.0.1/24</ipv4-destination>
    </match>
    <hard-timeout>0</hard-timeout>
    <cookie>10</cookie>
    <idle-timeout>0</idle-timeout>
    <flow-name>FooXf22</flow-name>
    <priority>2</priority>
    <barrier>false</barrier>
</flow>
----
*HTTP response* + 
----
Status: 200 OK
----
[start=3]
. Show flow: check that _strict_ is _true_.

*HTTP request* + 
----
Operation: GET
URI: http://192.168.11.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:1/table/2/flow/111
Accept: application/xml
----
*HTTP response* + 
----
Status: 200 OK
----

----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<flow 
    xmlns="urn:opendaylight:flow:inventory">
    <strict>true</strict>
    <instructions>
        <instruction>
          	<order>1</order>
            <apply-actions>
                <action>
                  <order>1</order>
                    <flood-all-action/>
                </action>
            </apply-actions>
        </instruction>
    </instructions>
    <table_id>2</table_id>
    <id>111</id>
    <cookie_mask>10</cookie_mask>
    <out_port>10</out_port>
    <installHw>false</installHw>
    <out_group>2</out_group>
    <match>
        <ethernet-match>
            <ethernet-type>
                <type>2048</type>
            </ethernet-type>
        </ethernet-match>
        <ipv4-destination>10.0.0.1/24</ipv4-destination>
    </match>
    <hard-timeout>0</hard-timeout>
    <cookie>10</cookie>
    <idle-timeout>0</idle-timeout>
    <flow-name>FooXf22</flow-name>
    <priority>2</priority>
    <barrier>false</barrier>
</flow>
----
[start=4]
. Delete the flow created.

*HTTP request* +
----
Operation: DELETE
URI: http://192.168.11.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:1/table/2/flow/111
----
*HTTP response* + 
----
Status: 200 OK
----
=== OpenDaylight Controller: Configuration
The Controller configuration operation has three stages:

* First, a Proposed configuration is created. Its target is to replace the old configuration. 
* Second, the Proposed configuration is validated, and then committed. If it passes validation successfully, the Proposed configuration state will be changed to Validated. 
* Finally, a Validated configuration can be Committed, and the affected modules can be reconfigured.

In fact, each configuration operation is wrapped in a transaction. Once a transaction is created, it can be configured, that is to say, a user can abort the transaction during this stage. After the transaction configuration is done, it is committed to the validation stage. In this stage, the validation procedures are invoked.
 If one or more validations fail, the transaction can be reconfigured. Upon success, the second phase commit is invoked. 
 If this commit is successful, the transaction enters the last stage, committed. After that, the desired modules are reconfigured. If the second phase commit fails, it means that the transaction is unhealthy - basically, a new configuration instance creation failed, and the application can be in an inconsistent state.
 
.Configuration states 
image::configuration.jpg[width=500]
 
.Transaction states
image::Transaction.jpg[width=500]

==== Validation
To secure the consistency and safety of the new configuration and to avoid conflicts, the configuration validation process is necessary. 
Usually, validation checks the input parameters of a new configuration, and mostly verifies module-specific relationships. 
The validation procedure results in a decision on whether the proposed configuration is healthy.

==== Dependency resolver
Since there can be dependencies between modules, a change in a module configuration can affect the state of other modules. Therefore, we need to verify whether dependencies on other modules can be resolved. 
The Dependency Resolver acts in a manner similar to dependency injectors. Basically, a dependency tree is built.

=== APIs and SPIs
This section describes configuration system APIs and SPIs.


==== SPIs
*Module* org.opendaylight.controller.config.spi. Module is the common interface for all modules: every module must implement it. The module is designated to hold configuration attributes, validate them, and create instances of service based on the attributes. 
This instance must implement the AutoCloseable interface, owing to resources clean up. If the module was created from an already running instance, it contains an old instance of the module. A module can implement multiple services. If the module depends on other modules, setters need to be annotated with @RequireInterface.

*Module creation* 

. The module needs to be configured, set with all required attributes. 
. The module is then moved to the commit stage for validation. If the validation fails, the module attributes can be reconfigured. Otherwise, a new instance is either created, or an old instance is reconfigured. 
A module instance is identified by ModuleIdentifier, consisting of the factory name and instance name.

*ModuleFactory* org.opendaylight.controller.config.spi. The ModuleFactory interface must be implemented by each module factory. +
A module factory can create a new module instance in two ways: +

* From an existing module instance
* An entirely new instance + 
ModuleFactory can also return default modules, useful for populating registry with already existing configurations. 
A module factory implementation must have a globally unique name.

==== APIs

|===
| ConfigRegistry | Represents functionality provided by a configuration transaction (create, destroy module, validate, or abort transaction).
| ConfigTransactionController | Represents functionality for manipulating with configuration transactions (begin, commit config).
| RuntimeBeanRegistratorAwareConfiBean | The module implementing this interface will receive RuntimeBeanRegistrator before getInstance is invoked.
|===

==== Runtime APIs

|===
| RuntimeBean | Common interface for all runtime beans
| RootRuntimeBeanRegistrator | Represents functionality for root runtime bean registration, which subsequently allows hierarchical registrations
| HierarchicalRuntimeBeanRegistration | Represents functionality for runtime bean registration and unreregistration from hierarchy
|===

==== JMX APIs

JMX API is purposed as a transition between the Client API and the JMX platform. +

|===
| ConfigTransactionControllerMXBean | Extends ConfigTransactionController, executed by Jolokia clients on configuration transaction.
| ConfigRegistryMXBean | Represents entry point of configuration management for MXBeans.
| Object names | Object Name is the pattern used in JMX to locate JMX beans. It consists of domain and key properties (at least one key-value pair). Domain is defined as "org.opendaylight.controller". The only mandatory property is "type".
|===

==== Use case scenarios

A few samples of successful and unsuccessful transaction scenarios follow: +

*Successful commit scenario*

. The user creates a transaction calling creteTransaction() method on ConfigRegistry.
. ConfigRegisty creates a transaction controller, and registers the transaction as a new bean.
. Runtime configurations are copied to the transaction. The user can create modules and set their attributes.
. The configuration transaction is to be committed.
. The validation process is performed.
. After successful validation, the second phase commit begins.
. Modules proposed to be destroyed are destroyed, and their service instances are closed.
. Runtime beans are set to registrator.
. The transaction controller invokes the method getInstance on each module.
. The transaction is committed, and resources are either closed or released.

*Validation failure scenario* +
The transaction is the same as the previous case until the validation process. +

. If validation fails, (that is to day, illegal input attributes values or dependency resolver failure), the validationException is thrown and exposed to the user.
. The user can decide to reconfigure the transaction and commit again, or abort the current transaction.
. On aborted transactions, TransactionController and JMXRegistrator are properly closed.
. Unregistration event is sent to ConfigRegistry.

==== Default module instances
The configuration subsystem provides a way for modules to create default instances. A default instance is an instance of a module, that is created at the module bundle start-up (module becomes visible for 
configuration subsystem, for example, its bundle is activated in the OSGi environment). By default, no default instances are produced.

The default instance does not differ from instances created later in the module life-cycle. The only difference is that the configuration for the default instance cannot be provided by the configuration subsystem. 
The module has to acquire the configuration for these instances on its own. It can be acquired from, for example, environment variables. 
After the creation of a default instance, it acts as a regular instance and fully participates in the configuration subsystem (It can be reconfigured or deleted in following transactions.).

=== OpenDaylight Controller configuration: Initial
The Initial configuration of the controller involves two methods.

=== Initial configuration for controller
The two ways of configuring the controller: +

* Using the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:config.ini[config.ini] property file to pass configuration properties to the OSGi bundles besides the config subsystem. 
* Using the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Configuration:Initial#Configuration_Persister[configuration persister] to push the initial configuration for modules managed by the config subsystem.

==== Using the config.ini property file

The config.ini property file can be used to provide a set of properties for any OSGi bundle deployed to the controller. It is usually used to configure bundles that are not managed by the config subsystem. For details, see <<_opendaylight_controller_configuration_config_ini>>.

==== Using configuration persister

Configuration persister is a default service in the controller, and is started automatically using the OSGi Activator. Its purpose is to load the initial configuration for the config subsystem and store a snapshot for every new configuration state pushed to the config-subsystem from external clients. 
For details, see <<_opendaylight_controller_configuration_persister>>.

=== OpenDaylight Controller configuration: config.ini

Various parts of the system that are not under the configuration subsystem use the file config.ini. Changes to this file apply after a server restart. The tabulation of several important configuration keys and values follows: 

[cols="2*", width="75%"]
|===

|Setting | Description
| yangstore.blacklist=.\*controller.model.* | This regular expression (can be OR-ed using pipe character) tells netconf to exclude the yang files found in the matching bundle symbolic name from the hello message. This is helpful when dealing with a netconf client that has parsing problems.
| netconf.config.persister.* settings  | See <<_opendaylight_controller_configuration_initial>>.
| netconf.tcp.address=0.0.0.0 netconf.tcp.port=8383 + 

netconf.ssh.address=0.0.0.0 netconf.ssh.port=1830 netconf.ssh.pk.path = ./configuration/RSA.pk +

netconf.tcp.client.address=127.0.0.1 netconf.tcp.client.port=8383 | These settings specify the netconf server bindings. IP address 0.0.0.0 is used when all available network interfaces must be used by the netconf server. When starting the ssh server, the user must provide a private key. The actual authentication is done in the user admin module. By default, users admin:admin and netconf:netconf can be used to connect by means of ssh. Since the ssh bridge acts as a proxy, one needs to specify the netconf plaintext TCP address and port. These settings must normally be identical to those specified by netconf.tcp.* .
|===
=== OpenDaylight Controller: Configuration Persister
One way of configuring the controller is to use the configuration persister to push the initial configuration for modules managed by the config subsystem. 

==== Using configuration persister

The configuration persister is a default service in the controller, and is started automatically using the OSGi Activator. 
Its purpose: +

* Load the initial configuration for the config subsystem.
* Store a snapshot for every new configuration state pushed to the config-subsystem from external clients. +

It retrieves the base configuration from the config.ini property file, and tries to load the configuration for the config subsystem.
The configuration for the config subsystem is pushed as a set of edit-config netconf rpcs followed by a commit rpc since the config persister acts as a netconf client. 

*Configuration persister lifecycle:* +

. Start the config persister service at _config-persister-impl_ bundle startup. 
. Retrieve the base configuration of the adapters from the config.ini property file. 
. Initialize the backing storage adapters. 
. Initialize the netconf client, and connect to the netconf endpoint of the config subsystem. 
. Load the initial configuration snapshots from the latest storage adapter. 
. Send the edit-config rpc with the initial configuration snapshots. 
. Send the commit rpc. 
. Listen for any of the following changes to the configuration and persist a snapshot. 

*Configuration Persister interactions:* +

.Persister
image::Persister.jpg[width=500]

=== Current configuration for controller distribution

The _config.ini_ property file contains the following configuration for the configuration persister: +
----
netconf.config.persister.active=1,2
 
netconf.config.persister.1.storageAdapterClass=org.opendaylight.controller.config.persist.storage.directory.autodetect.AutodetectDirectoryStorageAdapter 

netconf.config.persister.1.properties.directoryStorage=configuration/initial/ 

netconf.config.persister.1.readonly=true 

 
netconf.config.persister.2.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.xml.XmlFileStorageAdapter 

netconf.config.persister.2.properties.fileStorage=configuration/current/controller.currentconfig.xml 

netconf.config.persister.2.properties.numberOfBackups=1 
----

With this configuration, the configuration persister initializes two adapters: +

* AutodetectDirectoryStorageAdapter to load the initial configuration files from the _configuration/initial/_ folder. These files will be pushed as the initial configuration for the config subsystem. Since this adapter is Read only, it will not store any configuration snapshot during the controller lifecycle. 
* XmlFileStorageAdapter to store snapshots of the current configuration after any change in the file _configuration/current/controller.currentconfig.xml_ (Only 1 snapshot backup is kept; every new change overwrites the previous one). +
The initial configuration in the controller distribution consists of 2 files in the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Configuration:Initial#Persisted_snapshot_format[xml format]. +
* configuration/initial/00-netty.xml: +
----
<snapshot>
    <required-capabilities>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty?module=netty&amp;revision=2013-11-19</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty:eventexecutor?module=netty-event-executor&amp;revision=2013-11-12</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty:threadgroup?module=threadgroup&amp;revision=2013-11-07</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty:timer?module=netty-timer&amp;revision=2013-11-19</capability>
    </required-capabilities>
    <configuration>
 
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty:threadgroup">netty:netty-threadgroup-fixed</type>
                    <name>global-boss-group</name>
                </module>
                <module>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty:threadgroup">netty:netty-threadgroup-fixed</type>
                    <name>global-worker-group</name>
                </module>
                <module>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty:timer">netty:netty-hashed-wheel-timer</type>
                    <name>global-timer</name>
                </module>
                <module>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty:eventexecutor">netty:netty-global-event-executor</type>
                    <name>global-event-executor</name>
                </module>
            </modules>
 
            <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <service>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-threadgroup</type>
                    <instance>
                        <name>global-boss-group</name>
                        <provider>/modules/module[type='netty-threadgroup-fixed'][name='global-boss-group']</provider>
                    </instance>
                    <instance>
                        <name>global-worker-group</name>
                        <provider>/modules/module[type='netty-threadgroup-fixed'][name='global-worker-group']</provider>
                    </instance>
                </service>
                <service>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-event-executor</type>
                    <instance>
                        <name>global-event-executor</name>
                        <provider>/modules/module[type='netty-global-event-executor'][name='global-event-executor']</provider>
                    </instance>
                </service>
                <service>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-timer</type>
                    <instance>
                        <name>global-timer</name>
                        <provider>/modules/module[type='netty-hashed-wheel-timer'][name='global-timer']</provider>
                    </instance>
                </service>
            </services>
        </data>
 
    </configuration>
</snapshot>
----
This configuration snapshot instantiates netty utilities, which will be utilized by the controller components that use netty internally. + 

*configuration/initial/01-md-sal.xml:* +
----
<snapshot>
 
    <configuration>
 
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl">prefix:schema-service-singleton</type>
                    <name>yang-schema-service</name>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl">prefix:hash-map-data-store</type>
                    <name>hash-map-data-store</name>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl">prefix:dom-broker-impl</type>
                    <name>dom-broker</name>
                    <data-store xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl">
                        <type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:dom-data-store</type>
                        <!-- to switch to the clustered data store, comment out the hash-map-data-store <name> and uncomment the cluster-data-store one -->
                        <name>hash-map-data-store</name>
                        <!-- <name>cluster-data-store</name> -->
                    </data-store>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-broker-impl</type>
                    <name>binding-broker-impl</name>
                    <notification-service xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">
                        <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-notification-service</type>
                        <name>binding-notification-broker</name>
                    </notification-service>
                    <data-broker xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">
                        <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
                        <name>binding-data-broker</name>
                    </data-broker>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:runtime-generated-mapping</type>
                    <name>runtime-mapping-singleton</name>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-notification-broker</type>
                    <name>binding-notification-broker</name>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-data-broker</type>
                    <name>binding-data-broker</name>
                    <dom-broker xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">
                        <type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:dom-broker-osgi-registry</type>
                        <name>dom-broker</name>
                    </dom-broker>
                    <mapping-service xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">
                        <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">binding:binding-dom-mapping-service</type>
                        <name>runtime-mapping-singleton</name>
                    </mapping-service>
                </module>
 
            </modules>
 
            <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                	<service>
				<type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:schema-service</type>
				<instance>
					<name>yang-schema-service</name>
					<provider>/modules/module[type='schema-service-singleton'][name='yang-schema-service']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-notification-service</type>
				<instance>
					<name>binding-notification-broker</name>
					<provider>/modules/module[type='binding-notification-broker'][name='binding-notification-broker']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:dom-data-store</type>
				<instance>
					<name>hash-map-data-store</name>
					<provider>/modules/module[type='hash-map-data-store'][name='hash-map-data-store']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-broker-osgi-registry</type>
				<instance>
					<name>binding-osgi-broker</name>
					<provider>/modules/module[type='binding-broker-impl'][name='binding-broker-impl']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
				<instance>
					<name>binding-rpc-broker</name>
					<provider>/modules/module[type='binding-broker-impl'][name='binding-broker-impl']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding-impl="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">binding-impl:binding-dom-mapping-service</type>
				<instance>
					<name>runtime-mapping-singleton</name>
					<provider>/modules/module[type='runtime-generated-mapping'][name='runtime-mapping-singleton']</provider>
				</instance>
			</service>
			<service>
			<type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:dom-broker-osgi-registry</type>
				<instance>
					<name>dom-broker</name>
					<provider>/modules/module[type='dom-broker-impl'][name='dom-broker']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
				<instance>
					<name>binding-data-broker</name>
					<provider>/modules/module[type='binding-data-broker'][name='binding-data-broker']</provider>
				</instance>
			</service>
 
            </services>
        </data>
 
    </configuration>
 
    <required-capabilities>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty:eventexecutor?module=netty-event-executor&amp;revision=2013-11-12</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:threadpool?module=threadpool&amp;revision=2013-04-09</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding?module=opendaylight-md-sal-binding&amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom?module=opendaylight-md-sal-dom&amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl?module=opendaylight-sal-binding-broker-impl&amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl?module=opendaylight-sal-dom-broker-impl&amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:common?module=opendaylight-md-sal-common&amp;revision=2013-10-28</capability>
    </required-capabilities>
 
</snapshot>
----
This configuration snapshot instantiates md-sal modules. 

After the controller is started, all these modules will be instantiated and configured. They can be further referenced from the new modules as dependencies, reconfigured, or even deleted. 
These modules are considered to be the base configuration for the controller and the purpose of them being configured automatically is to simplify the process of controller configuration for users, since the base modules will already be ready for use.

=== Adding custom initial configuration

There are multiple ways to add the custom initial confguration to the controller distribution: 

. Manually create the config file, and put it in the initial configuration folder. 
. Reconfigure the running controller using the yuma yangcli tool. The XmlFileStorageAdapter adapter will store the current snapshot, and on the next startup of the controller (assuming it was not rebuilt since), it will load the configuration containing the changes. 

==== Custom initial configuration in bgpcep distribution

The BGPCEP project will serve as an example for adding the custom initial configuration. The bgpcep project contains the custom initial configuration that is based on the initial configuration from the controller. It adds new modules, which depend on MD-SAL and netty modules created with the initial config files of the controller. There are multiple config files in the bgpcep project. Only the 30-programming.xml file located under the programming-parent/controller-config project will be described in this section. This file contains the configuration for an instance of the instruction-scheduler module:

----
<?xml version="1.0" encoding="UTF-8"?>
<!-- vi: set et smarttab sw=4 tabstop=4: -->
<!--
      Copyright (c) 2013 Cisco Systems, Inc. and others.  All rights reserved.
 
 This program and the accompanying materials are made available under the
 terms of the Eclipse Public License v1.0 which accompanies this distribution,
 and is available at http://www.eclipse.org/legal/epl-v10.html.
-->
<snapshot>
	<required-capabilities>
		<capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding?module=opendaylight-md-sal-binding&amp;revision=2013-10-28</capability>
		<capability>urn:opendaylight:params:xml:ns:yang:controller:netty?module=netty&amp;revision=2013-11-19</capability>
		<capability>urn:opendaylight:params:xml:ns:yang:controller:programming:impl?module=config-programming-impl&amp;revision=2013-11-15</capability>
		<capability>urn:opendaylight:params:xml:ns:yang:controller:programming:spi?module=config-programming-spi&amp;revision=2013-11-15</capability>
	</required-capabilities>
	<configuration>
 
		<data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
			<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
				<module>
					<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:programming:impl">prefix:instruction-scheduler-impl</type>
					<name>global-instruction-scheduler</name>
					<data-provider>
						<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
						<name>binding-data-broker</name>
					</data-provider>
					<notification-service>
						<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-notification-service</type>
						<name>binding-notification-broker</name>
					</notification-service>
					<rpc-registry>
						<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
						<name>binding-rpc-broker</name>
					</rpc-registry>
					<timer>
						<type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-timer</type>
						<name>global-timer</name>
					</timer>
				</module>
			</modules>
 
			<services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
				<service>
					<type xmlns:pgmspi="urn:opendaylight:params:xml:ns:yang:controller:programming:spi">pgmspi:instruction-scheduler</type>
					<instance>
						<name>global-instruction-scheduler</name>
						<provider>/modules/module[type='instruction-scheduler-impl'][name='global-instruction-scheduler']</provider>
					</instance>
				</service>
			</services>
		</data>
 
	</configuration>
</snapshot>
----
Instruction-scheduler is instantiated as a module of type _instruction-scheduler-impl_ with the name *global-instruction-scheduler:* + 
----
<module>
       <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:programming:impl">prefix:instruction-scheduler-impl</type>
       <name>global-instruction-scheduler</name>
       ...
----
There is also an alias created for this module instancfe, and the alias is *global-instruction-scheduler* of type _instruction-scheduler_: +
----
...
<service>
	<type xmlns:pgmspi="urn:opendaylight:params:xml:ns:yang:controller:programming:spi">pgmspi:instruction-scheduler</type>
	<instance>
		<name>global-instruction-scheduler</name>
		<provider>/modules/module[type='instruction-scheduler-impl'][name='global-instruction-scheduler']</provider>
	</instance>
</service>
...
----
The type of the alias is instruction-scheduler. This type refers to a certain service that is implemented by the instruction-scheduler-impl module. With this service type, the global-instruction-scheduler instance can be injected into any other module that requires instruction-scheduler as a dependency. 
One module can provide (implement) multiple services, and each of these services can be assigned an alias. This alias can be later used to reference the implementation it is pointing to. 
If no alias is assigned by the user, a default alias will be assigned for each provided service. 
The default alias is constructed from the name of the module instance with a prefix *ref_* and a possible suffix containing a number to resolve name clashes. 
It is recommended that users provide aliases for each service of every module instance, and use these aliases for dependency injection. References to the alias global-instruction-scheduler can be found in subsequent config files in the bgpcep project for example, _32-pcep.xml_ located under the _pcep-parent/pcep-controller-config_ project. 

The configuration contains four dependencies on the MD-SAL and the netty modules: +
----
...
<data-provider>
	<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
	<name>binding-data-broker</name>
</data-provider>
<notification-service>
	<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-notification-service</type>
	<name>binding-notification-broker</name>
</notification-service>
<rpc-registry>
	<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
	<name>binding-rpc-broker</name>
</rpc-registry>
<timer>
	<type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-timer</type>
	<name>global-timer</name>
</timer>
...
----

MD-SAL dependencies: +

* Data-provider dependency 
* Notification-service dependency 
* Rpc-registry dependency 

All MD-SAL dependencies can be found in the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Configuration:Initial#Current_configuration_for_controller_distribution[MD-SAL initial configuration file]. For example, rpc-registry dependency points to an alias binding-rpc-broker of the type binding-rpc-registry. This alias further points to an instance of the binding-broker-impl named binding-broker-impl. 
The Yang module that defines the binding-broker-impl module : https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/sal-binding-broker/src/main/yang/opendaylight-binding-broker-impl.yang;a=blob[opendaylight-binding-broker-impl.yang]. 

*Netty dependencies:* +

* Timer dependency 

This configuration expects these dependencies to be already up and ready. It is the responsibility of the configuration subsystem to find the dependency and inject it. 
If the configuration of a module points to a non-existing dependency, the configuration subsystem will produce an exception during the validation phase. 
Every user-created configuration needs to point to existing dependencies. In the case of multiple initial configuration files that depend on one another, the resolution order can be ensured by the names of the files. Files are sorted by their names in ascending order. This means that every configuration file will have the visibility of modules from all previous configuration files by means of aliases.

NOTE: The configuration provided by initial config files can also be pushed to the controller at runtime using netconf client. The whole configuration located under the data tag needs to be inserted into the config tag in the edit-config rpc. For more information, see https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Main#Examples[Examples]. 

==== Configuration Persister

As a part of the configuration subsystem, the purpose of the persister is to save and load a permanent copy of a configuration. The Persister interface represents basic operations over a storage - persist configuration and load last config, configuration snapshot is represented as string and set of it's capabilities. StorageAdapter represents an adapter interface to the ConfigProvider - subset of BundleContext, allowing access to the OSGi framework system properties. 

===== Persister implementation

Configuration persister implementation is part of the Controller Netconf. PersisterAggregator class is the implementation of the Presister interface. The functionality is delegated to the storage adapters. Storage adapters are low level persisters that do the heavy lifting for this class. Instances of storage adapters can be injected directly by means of the constructor, or instantiated from a full name of its class provided in a properties file. There can be many persisters configured, and varying numbers of them can be used. 

*Example of presisters configuration:* +
----
netconf.config.persister.active=2,3
 # read startup configuration
 netconf.config.persister.1.storageAdapterClass=org.opendaylight.controller.config.persist.storage.directory.xml.XmlDirectoryStorageAdapter
 netconf.config.persister.1.properties.fileStorage=configuration/initial/
 
 netconf.config.persister.2.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.FileStorageAdapter
 netconf.config.persister.2.readonly=true
 netconf.config.persister.2.properties.fileStorage=configuration/current/controller.config.1.txt
 
 netconf.config.persister.3.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.FileStorageAdapter
 netconf.config.persister.3.properties.fileStorage=configuration/current/controller.config.2.txt
 netconf.config.persister.3.properties.numberOfBackups=3
----

During server startup, ConfigPersisterNotificationHandler requests the last snapshot from the underlying storages. Each storage can respond by giving a snapshot or an absent response. The PersisterAggregator#loadLastConfigs() will search for the first non-absent response from storages ordered backwards as user specified (first '3', then '2'). When a commit notification is received, '2' will be omitted because the read-only flag is set to true, so only '3' will have a chance to persist the new configuration. 
If read-only was false, or not specified, both storage adapters would be called in the order specified by 'netconf.config.persister' property. 

=== Persister Notification Handler

ConfigPersisterNotificationHandler class is responsible for listening for netconf notifications containing the latest committed configuration. 
The listener can handle incoming notifications, or delegates the configuration saving or loading to the persister. 

==== Storage Adapter implementations

*XML File Storage* +

The XmlFileStorageAdapter implementation stores configuration in an xml file.

*XML Directory Storage* +

XmlDirectoryStorageAdapter retrieves the initial configuration from a directory. If multiple xml files are present, files are ordered based on the file names and pushed in this order (for example, 00.xml, then 01.xml..) Each file defines its required capabilities, so it will be pushed when those capabilities are advertized by ODL. Writing to this persister is not supported. 

*No-Operation Storage* +

NoOpStorageAdapter serves as a dummy implementation of the storage adapter. 

*Obsolete storage adapters* +

* File Storage

* FileStorageAdapter implements StorageAdapter, and provides file based configuration persisting. 
File path and name is stored as a property and a number of stored backups, expressing the count of the last configurations to be persisted too. 
The implementation can handle persisting input configuration, and load the last configuration.

* Directory Storage

* DirectoryStorageAdapter retrieves initial configurations from a directory. If multiple files are present, snapshot and required capabilities will be merged together. See configuration later on this page for details. Writing to this persister is not supported. 

* Autodetect Directory Storage

* AutodetectDirectoryStorageAdapter retrieves initial configuration from a directory (exactly as Xml Directory Storage) but supports xml as well as plaintext format for configuration files. Xml and plaintext files can be combined in one directory. Purpose of this persister is to keep backwards compatibility for plaintext configuration files. 

IMPORTANT: This functionality will be removed in later releases since Plaintext File/Directory adapters are deprecated, and will be fully replaced by xml storage adapters. 

===== Persisted snapshot format

Configuration snapshots are persisted in xml files for both file and directory adapters. They share the same format: +
----
<snapshot>
    <required-capabilities>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty?module=netty&amp;revision=2013-11-19</capability>
        ...
    </required-capabilities>
    <configuration>
 
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
             ...    
            </modules>
 
            <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
             ...    
            </services>
 
        </data>
 
    </configuration>
</snapshot>
----
The whole snapshot is encapsulated in the snapshot tag that contains two children elements: +

* The required-capabilities tag contains the list of yang capabilities that are required to push configurations located under the configuration tag. The config persister will not push the configuration before the netconf endpoint for the config subsystem reports all needed capabilities. Every yang model that is referenced within this xml file (as namespace for xml tag) must be referenced as a capability in this list. 
* The configuration tag contains the configurations to be pushed to the config subsystem. It is wrapped in a data tag with the base netconf namespace. The whole data tag, with all its child elements, will be inserted into an edit-config rpc as config tag. For more information about the structure of configuration data, see  base yang model for the config subsystem and all the configuration yang files for the controller modules as well as those provided examples. Examples contain multiple explained edit-config rpcs that change the configuration.

NOTE:  XML File adapter adds additional tags to the xml format since it supports multiple snapshots per file. 

The xml format for xml file adapter: +
----
<persisted-snapshots>
   <snapshots>
      <snapshot>
         <required-capabilities>
            <capability>urn:opendaylight:params:xml:ns:yang:controller:shutdown:impl?module=shutdown-impl&amp;revision=2013-12-18</capability>
         </required-capabilities>
         <configuration>
            <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
               <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                 ....
               </modules>
               <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                 ...
               </services>
            </data>
         </configuration>
      </snapshot>
      <snapshot>
         <required-capabilities>
            <capability>urn:opendaylight:params:xml:ns:yang:controller:shutdown:impl?module=shutdown-impl&amp;revision=2013-12-18</capability>
         </required-capabilities>
         <configuration>
            <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
               <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                 ....
               </modules>
               <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                 ...
               </services>
            </data>
         </configuration>
      </snapshot>
   </snapshots>
</persisted-snapshots>
----
=== MD-SAL architecture: Clustering Notifications
MD-SAL supports two kinds of messaging exchange pattern: +

* Request/Reply
* Publish/Subscribe
The RPC module implements the Request/Reply pattern. The notification module implements the Publish/Subscribe functionality. The implementation details are provided at: https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Explained:Messaging_Patterns[OpenDaylight Controller:MD-SAL:Explained:Messaging Patterns].
The focus now is on Publish/Subscribe implementation.An earlier implementation assumed a single VM deployment of the controller.The message exchange happens only within a VM in memory. The current requirement is to enable these notifications across nodes in the cluster.

Publish/Subscribe notifications are of two kinds: +

* Data Change events
* Yang notifications
In both cases, the notifications are broadcast to all "listeners". +
*Requirements* +
Some of the requirements: +

* Ability to publish notifications to any subscriber in the cluster
* Subscriber ability to specify delivery policy
* 1 of N: Delivery of the notification to any one of N instances of application running in the cluster
* N of N: Broadcasts
* Local only: Notifying events generated on the same node as the application instance
* Load Balancing: Round robin, least loaded etc
* Content Based or any other application specified custom logic
* Publisher capability to attach properties to the message
* Message priority
* Delivery guarantee
* Ability to plug-in external systems such as AMQP based systems

==== Proposed change
Based on the requirements, a change in the aPI was proposed: +
----
 Yang notification
 publish(Notification notification, MessageProperties props);
 registerNotificationListener(org.opendaylight.yangtools.yang.binding.NotificationListener.NotificationListener listener, Selector selector);
 registerNotificationListener(Class notificationType, org.opendaylight.controller.sal.binding.api.NotificationListener listener, Selector selector);
 Data change notification
 registerDataChangeListener(LogicalDatastoreType store, P path, L listener, DataChangeScope triggeringScope, "Selector selector");
public interface MessageProperties{
 public Priority priority();
 ...[add more properties]
}
public enum Priority { HIGH, NORMAL, LOW};
public interface Selector {
 public List<InstanceLocator> select(Notification event, List<InstanceLocator> instances);
}
----

=== MD-SAL Architecture: DOM
There are several issues that impede the reliability and performance of mD-SAL: + 

* Data structures (defined in yang-data-api) are like XML structures. Therefore, it is hard to implement an optimized datastore atop them. Instead, YANG-defined data structures must be used in the data store. YANG-defined data structures are already being used in the MD-SAL: in the Java DTOs generated by YangTools, and in other components.
* The current MD-SAL data contracts do not provide enough capabilities to more accurately specify an the intent of an application and to perform optimizations to clients (for example, 'do not unnecessarily deserialize data', or 'compute only necessary change sets'). The current datastore implementation prevents atomic updates on subtrees.

==== MD-SAL DOM Data Broker
The current DOM Data Broker design does not include an assumption of a intelligent in-memory cache with tree-like structures that would:

* Be able to track dependencies
* Calculate change sets 
* Maintain the relationships between commit handlers, notification listeners and the actual data.
This may lead to an inefficient implementation of the two-phase commit, where all state tracking during the is done by the Data Broker itself as follows: +
. Calculate the affected subtrees.
. Filter the commit handlers by the affected subtrees.
. Filter data change listeners by the affected subtrees.
. Capture the initial state for data change listeners (one read per data change listener set).
. Start Request Commit of all the affected commit handlers.
. Finish Commit on all the affected commit handlers.
. Capture the final state for data change listeners (one read per data change listener set).
. Publish the Data Change events to the affected data change listeners.
The states that the current DOM Data Broke keeps and maintains are mapping of subtree paths to:  *

* Registered commit handlers
* Registered data change listeners
* Registered data readers
DOM Data Broker has the following state keeping responsibilities: *

* Read request routing for data readers
* Two phase commit coordination
* Publish Data Change Events
* Capture Before and After state

=== MD-SAL: Infinispan Data Store

==== Components of Infinispan Data Store
Infinispan Data Store comprises the following major components: +

* Encoding or Decoding a Normalized Node into and from the Infinispan TreeCache
* Managing transactions
* Managing DataChange notifications

==== Encoding or Decoding a Normalized Node into and from the Inifinispan TreeCache +
A NormalizedNode represents a tree whose structure closely models the yang model of a bunch of modules. The NormalizedNode tree typically has values either placed in: +

* A LeafNode (corresponding to a leaf in yang) 
* A LeafSetEntryNode (corresponding to a leaflist in yang) +
The encoding logic walks the NormalizedNode tree looking for LeafNodes and LeafSetEntryNodes.When the logic finds a LeafNode or a LeafSetEntryNode, it records the finding in a map with the following: +

* Instance Identifier of the parent as the key 
* The value of the leaf or leafset entry store in a map where:
** The NodeIdentifier of the leaf/leafsetentry is the key.
** The value of the leaf/leafsetentry is the value.
The decoding process involves the following steps: + 

. Uses the interface of TreeCache to get to a certain node in the tree
. Walks through the tree, and reconstructs the NormalizedNode based on the key and value in the Infinispan TreeCache
. Validates the NormalizedNode against the schema

==== Managing Transactions +
To ensure read-write isolation level, and for other reasons, an infinispan (JTA) transaction for each datastore transaction is created. Since a single thread may be used for multiple JTA transactions, 
the implementation has to ensure the suspension and resumption of the JTA transactions appropriately.
However, this does not seem to have an impact on performance.

==== Managing DataChange notifications +
The current interface for data change notifications supports the registering of listeners for the following notifications: +

* Data changes at Node (consider node of a tree) level
* Events for any changes that happen at *one* level (meaning immediate children) 
* Any change at the subtree level
The event sent to the listener requires that the following snapshots of the tree be maintained: +

* Before data change
* After data change 

NOTE: This process is very expensive. It means maintaining a Normalized Node representing a snapshot of the tree. It involves converting the tree in Infinispan to NormalizeNode object tree required by the consumer at the start of each transaction.

*To maintain the data changes:* +

. At the begin of transaction, get a NormalizedNode Object tree of the current tree in ISPN TreeCache (This is mandated by the current DataChangeEvent interface.)
. For each CUD operations that happens within the transaction, maintain a transaction log.
. When the pre-commit of the 3PhaseCommit Transaction Interface is called, prepare data changes. This involves: +
.. Comparing the transaction log items with the Snapshot Tree one taken at the beginning of the transactions
.. Preparing the DataChangeEvent lists based on what level the listeners have registered
. Upon a commit, send the events to the listeners in a separate executor, that is asynchronously.

*Suggested changes* +

* Remove the requirement for sending the `before transaction tree' or the `after transaction tree' within each event.
* Send the changed paths of tree to the consumer, and let the consumer do the reading.

==== Building the POC +
To build or run the POC, you need the latest version of the following: +

* Yangtools
* Controller
* OpenFlow plugin

==== To get yangtools +

. Get the latest yangtools sources, and then create a branch of it using the following command:
: git checkout 306ffd9eea5a52556b4877debd2a79ca0573ff0c -b infinispan-data-store +
. Build using the following command:
: mvn clean install -DskipTests +

==== To get the Controller

. Get the latest controller, and then create a branch using the following command:
: git checkout 259b65622b8c29c49235c2210609b9f7a68826eb -b infinispan-data-store +
. Apply the following gerrit. 
: https://git.opendaylight.org/gerrit/#/c/5900/
. Build using the following command:
: mvn clean install -DskipTests +
. If the build should fails, use the following commang:
: cd opendaylight/md-sal/sal-ispn-datastore +
. Build using the following command:
+mvn clean install+
. Return to the controller directory, and build using:
: mvn clean install -DskipTests or resume build +

==== To get the OpenFlowplugin

. Get the latest openflowplugin code and then create a branch using the following command:
: git checkout 6affeefef4de51ce4b7de86fd9ccf51add3922f7 -b infinispan-data-store +
. Build using the following command:
: mvn clean install -DskipTests +
. Copy the sal-ispn-datastore jar to the plugins folder.

==== Running the POC +
*Prerequisite* +
Ensure that the 01-md-sal.xml file has been changed to use the new MD-SAL datastore. +

* Run the controller with the infinispan datastore. The section, <<_comparison_of_in_memory_and_infinispan_datastore>> provides information about cbench testing.

NOTE: If you want to see performance numbers similar to those documented, disable datachange notifications. 
The only way to do that in the POC is to change the code in ReadWriteTransactionImpl. Look for the FIXME comments.

=== State of the POC +

* Encoding and Decoding a Normalized Node into an Infinispan TreeCache works
* Integrated with the controller
* Eventing works
* With Data Change events disabled, the Infinispan based datastore performs the same, or better than, the custom In-Memory Datastore. Although initially slow, with time it seems to perform more consistently than the In-Memory Datastore.,
* Not fully tested

=== Infinispan-related learnings +

*Below par functioning of TreeCache#removeNode API* +
The Infinispan removeNode API failed to remove nodes in the tree, as was promised, correctly. This means, for example, that when a mininet topology changes, some nodes may not be removed from inventory and topology.
This behaviour has not been properly evaluated, and no remedy is currently available.

=== Datastore-related learnings +

*Multiple transactions can be created per thread* +
This is a problem because if the backing datastore (infinispan) uses JTA transactions, only one transaction can be active per thread. 
Although this does not necessarily mean the usage of one thread per transaction, it calls for the suspension of one transaction and the resumption of another.
TIP::
* Allow only one active transaction per thread.
* Add an explicit suspend or resume method to a transaction.

=== No clarity on the closing of Read-Only transactions +
For every DataStore transaction, a JTA transaction needs to be created. This is to ensure isolation (repeatable reads). When the transaction is done, it must be committed, rolled back, or closed in some fashion. Read-only transactions may not close. This leads to JTA transactions being open until they are timed out.

TIP:: 

* A DataStore may need to do time-outs as well.
* Call _close_ explicitly for read-only transactions.

==== Write and Delete methods in a read-write transaction do not return a Future
The Write and Delete methods on the DOMWriteTransaction return a void instead of a Future, creating the impression that these methods are synchronous. This is not necessarily true in all cases: for example, in the infinispan datastore, the write was actually done in a separate thread to support multiple transactions on a single thread.
TIP: Return a ListenableFuture for both Write and Delete methods.

==== Expense of creating a DataChange event +
Creating a DataChange event is very expensive because it needs to pass the Original Sub tree and the Modified Sub tree. +
A NormalizedNode object needs to be created to create a DataChange event. The NormalizedNode object may be a snapshot of the complete modules data to facilitate the sending of the original subtree to DataChange listeners. The prohibitive expense prevents this implementation in every transaction. This is a problem not only in the infinispan datastore but also in a distributed system. A distributed system shards data to collocate it on a different node on the cluster with applications and datachange listeners. For example, while a system may have shards collocated with the inventory application; the topology application may be a datachange listener for datachange events. In this case, the original subtree and the modified sub tree would need to be serialized in some form, and sent to the topology listener.
TIP: Remove the getOriginalSubtree and getModifiedSubtree methods from the datachange listener; understand the use case for providing them; and find a cheaper alternative.

==== Complications of reconstructing a Normalized Node from different data-structures +
The reconstruction of a Normalized Node from a different data-structure, like a map or a key-value store, is complicated or may appear complicated.
A NormalizedNode is the binding-independent equivalent of data that gets stored in the datastore. For the in-memory datastore, it is the native storage format. It is a complicated structure that basically mirrors the model as defined in yang. Understanding it and properly decoding it could be a challenge for the implemention of an alternate datastore.
TIP: Create utility classes to construct a normalized node from a simple tree structure. The Old CompositeNode or the Infinispan Node for example is a much simpler structure to follow.

==== Comparison of In-Memory and Infinispan Datastore
Cbench was used to compare the performance of the two datastores.
To prepare the controller for testing: +

IMPORTANT: Use the openflow plugin distribution.

. Remove the simple forwarding, arp handler, and md-sal statistics manager bundles.
. Set the log level to ERROR. 
. Run the controller with the following command: +
:  ./run.sh -Xmx4G -Xms2G -XX:NewRatio=5 -XX:+UseG1GC -XX:MaxPermSize=256m 
. From the osgi command prompt, use *dropAllPackets on*.

==== Running cbench +
For both the in-memory and infinispan datastore versions, cbench was run 11 times. The first run is ignored in both cases.

* Use the cbench command: +
: cbench -c <controller ip> -p 6633 -m 1000 -l 10 -s 16 -M 1000
This was a latency test and the arguments roughly translate to this: +
: -m 1000 : use 1000 milliseconds per test -l 10 : use 10 loops per test -s 16 : fake 16 switches -M 1000 : use 1000 hosts per switch
 </div>

==== The results for In-Memory Datastore +
To test the in-memory datastore, a pre-built openflow plugin distribution from Jenkins was downloadedon and on which was enabled the new in-memory datastore. +
*In-Memory Datastore Results*
[options="header",width="75%"]
|===
| Run | Min | Max | Avg | StdDev
| 1 | 365 | 1049 | 715 | 04
| 2 | 799 | 1044 | 953 | 71
| 3 | 762 | 949 | 855 | 59
| 4 | 616 | 707 | 666 | 27
| 5 | 557 | 639 | 595 | 24
| 6 | 510 | 583 | 537 | 25
| 7 | 455 | 535 | 489 | 22
| 8 | 351 | 458 | 420 | 38
| 9 | 396 | 440 | 417 | 14
| 10 | 376 | 413 | 392 | 13
|===

==== Infinispan Datastore +
The Infinispan Datastore was built of a master a month old. Since the In-Memory datastore was hardcoded at that time the in-memory datastore was swapped for the the infinispan datastore by modifying the sal-broker-impl sources.


Listed are some steps that were either completed to isolate the changes that were being made, or to tweak performance:  +

* Infinispan 5.3 was used because to isolate changes to utilize tree cache to the infinispan datastore bundles. Attempting to use version 6.0 caused a problem in loading some classes from infinispan.Ideally, to use infinispan as a backing store, tweak clustering services to obtain a treecache.
* Added an exists method onto the In-Memory ReadTransaction API. This was because it was found that in one place in the BA Broker was code which checked for the existence of nodes in the tree by doing a read. Reads are a little expensive on the Infinispan datastore because of the need to convert to a NormalizedNode. An exists method was added to the interface to just check for node-existence.
* When a transaction was used to read data it was not being closed causing the Infinispan JTA transactions to persist. Again, a change in the broker was made to close a transaction after it was concluded so that it dis not persist and trigger a clean by the reaper.

*Infinispan Datastore Results*
[cols="5*",^,options="header",width="75%"]
|===
| Run | Min | Max | Avg | StdDev
| 1 | 43 | 250 | 186 | 61
| 2 | 266 | 308 | 285 | 13
| 3 | 300 | 350 | 325 | 12
| 4 | 378 | 446 | 412 | 24
| 5 | 609 | 683 | 644 | 26
| 6 | 492 | 757 | 663 | 76
| 7 | 794 | 838 | 816 | 11
| 8 | 645 | 845 | 750 | 60
| 9 | 553 | 829 | 708 | 100
| 10 | 615 | 910 | 710 | 86
|===

=== OpenDaylight Controller configuration: FAQs
====  Generic questions about the configuration subsystem
*There is already JMX. Why do we need another system?* 

Java Management Extensions (JMX) provides programmatic access to management data, defining a clear structure on the level of a single object (MBeans). It provides the mechanism to query and set information exposed from these MBeans, too. It is adequate for replacing properties, but it does not treat the JVM container for what it is: a collection of applications working in concert. When the configuration problem is taken to the level of an entire system, there are multiple issues which JMX does not solve:

* The need to validate that a proposed system is semantically valid before an attempt to change is made
* The ability to synchronize modification multiple properties at the same time, such that both occur at the same time
* The ability to express dependencies between applications
* Machine-readable descriptions of layouts of configuration data

*Why use YANG?*

The problem of configuring a device has been tackled in https://ietf.org/[IETF] for many years now, initially using https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol[SNMP] (with https://en.wikipedia.org/wiki/Management_information_base[MIB] as the data definition language). While the protocol has been successful for monitoring devices, it has never gained traction as the unified way of configuring devices. The reasons for this have been https://tools.ietf.org/html/rfc3535[analyzed] and https://datatracker.ietf.org/doc/rfc6241/[NETCONF] was standardized as the successor protocol. NETCONF provides the abstractions to deal with configuration validation, and relies on http://tools.ietf.org/html/rfc6020[YANG] as its data modeling language. The configuration subsystem is designed to completely align with NETCONF such that it can be used as the native transport with minimal translation.

=== OpenDaylight Controller configuration: Component map
[cols="5,5a",^,options="header",width="75%"]
|===
| Component | Description
| config-subsystem-core | Config subsystem core. 
			Manages the configuration of the controller.
			
Responsibilities:


* Scanning of bundles for ModuleFactories.

* Transactional management of lifecycle and dependency injection for config modules.

* Exposure of modules and their configuration into JMX.
| netty-config| Config modules for netty related resources, for example, netty-threadgroup, netty-timer and others. 

Contains config module definition in the form of yang schemas + generated code binding for the config subsystem.
| controller-shutdown | Controller shutdown mechanism. 

Brings down the whole OSGi container of the controller. 

Authorization required in the form of a "secret string".

Also contains config module definition in the form of yang schemas + generated code binding for the config subsystem. This makes it possible to invoke shutdown by means of the config-subsystem.
| threadpool-config | Config modules for threading related resources, for example, threadfactories, fixed-threadpool, and others.
 
Contains config module definition in the form of yang schemas + generated code binding for the config subsystem.
| logback-config | Config modules for logging (logback) related resources, for example, loggers, appenders, and others. 

Contains config module definition in the form of yang schemas + generated code binding for the config subsystem.
| netconf-config-dispatcher-config | Config modules for netconf-dispatcher(from netconf subsystem). 

Contains config module definition in the form of yang schemas + generated code binding for the config subsystem.
| yang-jmx-config-generator | Maven plugin that generates the config subsystem code binding from provided yang schemas. This binding is required when the bundles want to participate in the config subsystem.
| yang-jmx-config-generator-testing-modules | Testing resources for the maven plugin.
| config-persister | Contains the api definition for an extensible configuration persister(database for controller configuration). 

The persister (re)stores the configuration for the controller. Persister implementation can be found in the netconf subsystem. 

The adapter bundles contain concrete implementations of storage extension. They store the config as xml files on the filesystem.
| config-module-archetype | Maven archetype for "config subsystem aware" bundles. 

This archetype contains blueprints for yang-schemas, java classes, and other files(for example, pom.xml) required for a bundle to participate in the config subsystem. 

This archetype generates a bundle skeleton that can be developed into a full blown "config subsystem aware" bundle.
|===

=== OpenDaylight Controller: Netconf component map

[cols="2", options="header", width="75%"]
|===
|Component | Description 

| netconf-server | Implementation of the generic (extensible) netconf server over tcp/ssh. Handles the general communication over the network, and forwards the rpcs to its extensions that implement the specific netconf rpc handles (For example: get-config).
| netconf-to-config-mapping | API definition for the netconf server extension with the base implementation that transforms the netconf rpcs to java calls for the config-subsystem (config-subsystem netconf extension). 
| netconf-client | Netconf client basic implementation. Simple netconf client that supports netconf communication with remote netconf devices using xml format. 
| netconf-monitoring | Netconf-monitoring yang schemas with the implementation of a netconf server extension that handles the netconf-monitoring related handlers (For example: adding netconf-state to get rpc) 
| config-persister-impl | Extensible implementation of the config persister that persists the configuration in the form of xml,(easy to inject to edit-config rpc) and loads the initial configuration from the persisted files. The configuration is stored after every successful commit rpc. 
| netconf-cli | Prototype of a netconf cli. 
|=== 

=== OpenDaylight Controller Configuration: Examples sample project
*Sample maven project* +

In this example, we will create a maven project that provides two modules, each implementing one service. We will design a simple configuration, as well as runtime data for each module using yang. 
A sample maven project called config-demo was created. This project contains two Java interfaces: Foo and Bar. Each interface has one default implementation per interface, FooImpl and BarImpl. Bar is the producer in our example and produces integers when the method getNextEvent() is called. Foo is the consumer, and its implementation depends on a Bar instance. Both implementations require some configuration that is injected by means of constructors. 

* Bar.java: 
----
package org.opendaylight.controller.config.demo;
 
public interface Bar {
 
    int getNextEvent();
 
}
----
* BarImpl.java:
----
package org.opendaylight.controller.config.demo;
 
public class BarImpl implements Bar {
 
    private final int l1, l2;
    private final boolean b;
 
    public BarImpl(int l1, int l2, boolean b) {
        this.l1 = l1;
        this.currentL = l1;
        this.l2 = l2;
        this.b = b;
    }
 
    private int currentL;
 
    @Override
    public int getNextEvent() {
        if(currentL==l2)
            return -1;
        return currentL++;
    }
}
----
* Foo.java: 
----
package org.opendaylight.controller.config.demo;
 
public interface Foo {
 
    int getEventCount();
}
----
* FooImpl.java: 
----
package org.opendaylight.controller.config.demo;
 
public class FooImpl implements Foo {
 
    private final String strAttribute;
    private final Bar barDependency;
    private final int intAttribute;
 
    public FooImpl(String strAttribute, int intAttribute, Bar barDependency) {
        this.strAttribute = strAttribute;
        this.barDependency = barDependency;
        this.intAttribute = intAttribute;
    }
 
    @Override
    public int getEventCount() {
        int count = 0;
        while(barDependency.getNextEvent() != intAttribute) {
            count++;
        }
        return count;
    }
}
----
* pom.xml (config-demo project is defined as a sub-module of the controller project, and at this point contains only the configuration for maven-bundle-plugin): 
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
 
    <parent>
        <artifactId>commons.opendaylight</artifactId>
        <groupId>org.opendaylight.controller</groupId>
        <version>1.4.1-SNAPSHOT</version>
        <relativePath>../commons/opendaylight/pom.xml</relativePath>
    </parent>
    <groupId>org.opendaylight.controller</groupId>
    <version>0.1.1-SNAPSHOT</version>
    <artifactId>config-demo</artifactId>
    <packaging>bundle</packaging>
    <name>${project.artifactId}</name>
    <prerequisites>
        <maven>3.0.4</maven>
    </prerequisites>
 
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.felix</groupId>
                <artifactId>maven-bundle-plugin</artifactId>
                <version>2.4.0</version>
                <extensions>true</extensions>
                <configuration>
                    <instructions>
                        <Bundle-Name>${project.groupId}.${project.artifactId}</Bundle-Name>
                        <Export-Package>
                            org.opendaylight.controller.config.demo,
                        </Export-Package>
                    </instructions>
                </configuration>
            </plugin>
        </plugins>
    </build>
 
</project>
----

==== Describing the module configuration using yang
In order to fully leverage the utilities of the configuration subsystem, we need to describe the services, modules, their configurations, and the runtime state using the yang modeling language. We will define two services and two modules, which will be used to configure the instances of FooImpl and BarImpl. This definition will be split into two yang files: config-demo.yang (service definition) and config-demo-impl.yang (module definition).

* config-demo.yang 
----
module config-demo {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo";
    prefix "demo";
 
    import config { prefix config; revision-date 2013-04-05; }
 
    description
        "Service definition for config-demo";
 
    revision "2013-10-14" {
        description
            "Initial revision";
    }
 
    // Service definition for service foo that encapsulates instances of org.opendaylight.controller.config.demo.Foo
    identity foo {
        description
            "Foo service definition";
 
        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Foo";
    }
 
    identity bar {
        description
            "Bar service definition";
 
        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Bar";
    }
}
----
The config yang module needs to be imported in order to define the services. There are two services defined, and these services correspond to the Java interfaces Foo and Bar (specified by the config:java-class extension). 

* config-demo-impl.yang
----
module config-demo-impl {
 
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo:java";
    prefix "demo-java";
 
    // Dependency on service definition for config-demo
    /* Service definitions could be also located in this yang file or even
     * in a separate maven project that is marked as maven dependency
     */
    import config-demo { prefix demo; revision-date 2013-10-14;}
 
    // Dependencies on config subsystem definition
    import config { prefix config; revision-date 2013-04-05; }
    import rpc-context { prefix rpcx; revision-date 2013-06-17; }
 
 
    description
        "Service implementation for config-demo";
 
    revision "2013-10-14" {
        description
            "Initial revision";
    }
                                                                      //----- module foo-impl ----- //
    // Module implementing foo service                                                              //
    identity foo-impl {                                                                             //
        base config:module-type;                                                                    //
        config:provided-service demo:foo;                                                           //
        config:java-name-prefix FooImpl;                                                            //
    }                                                                                               //
                                                                                                    //
    // Configuration for foo-impl module                                                            //
    augment "/config:modules/config:module/config:configuration" {                                  //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
            leaf str-attribute {                                                                    //
                type string;                                                                        //
            }                                                                                       //
                                                                                                    //
            leaf int-attribute {                                                                    //
                type int32;                                                                         //
            }                                                                                       //
                                                                                                    //
                                                                                                    //
            // Dependency on bar service instance                                                   //
            container bar-dependency {                                                              //
                uses config:service-ref {                                                           //
                    refine type {                                                                   //
                        mandatory true;                                                             //
                        config:required-identity demo:bar;                                          //
                    }                                                                               //
                }                                                                                   //
            }                                                                                       //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                                    //
    // Runtime state definition for foo-impl module                                                 //
    augment "/config:modules/config:module/config:state" {                                          //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                      // ---------- //
    // Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:bar;
        config:java-name-prefix BarImpl;
    }
 
    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";
 
            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }
 
                leaf int-attribute2 {
                    type int32;
                }
 
                leaf bool-attribute {
                    type boolean;
                }
            }
 
        }
    }
 
    augment "/config:modules/config:module/config:state" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";
 
        }
    }
 
}
----
The config yang module as well as the config-demo yang module need to be imported. There are two modules defined: foo-impl and bar-impl. Their configuration (defined in the augment "/config:modules/config:module/config:configuration" block) corresponds to the configuration of the FooImpl and BarImpl Java classes. In the constructor of FooImpl.java, we see that the configuration of foo-impl module defines three similar attributes. These arguments are used to instantiate the FooImpl class. These yang files are placed under the src/main/yang folder. 

==== Updating the maven configuration in pom.xml

The yang-maven-plugin must be added to the pom.xml. This plugin will process the yang files, and generate the configuration code for the defined modules. Plugin configuration: +
----
<plugin>
    <groupId>org.opendaylight.yangtools</groupId>
    <artifactId>yang-maven-plugin</artifactId>
    <version>${yangtools.version}</version>
    <executions>
        <execution>
            <goals>
                <goal>generate-sources</goal>
            </goals>
            <configuration>
                <codeGenerators>
                    <generator>
                        <codeGeneratorClass>
                            org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                        </codeGeneratorClass>
                        <outputBaseDir>${project.build.directory}/generated-sources/config</outputBaseDir>
                        <additionalConfiguration>
                            <namespaceToPackage1>
                                urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                            </namespaceToPackage1>
                        </additionalConfiguration>
                    </generator>
                </codeGenerators>
                <inspectDependencies>true</inspectDependencies>
            </configuration>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>org.opendaylight.controller</groupId>
            <artifactId>yang-jmx-generator-plugin</artifactId>
            <version>${config.version}</version>
        </dependency>
    </dependencies>
</plugin>
----
The configuration important for the plugin: the output folder for the generated files, and the mapping between the yang namespaces and the java packages (Inspect dependencies must be set to true.). The default location for the yang files is under the src/main/yang folder. This plugin is backed by the artifact yang-jmx-generator-plugin and its class org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator is responsible for code generation. This artifact is part of the configuration subsystem. 

In addition to the yang-maven-plugin, it is neccessary to add the build-helper-maven-plugin in order to add the generated sources to the build process: 
----
<plugin>
   <groupId>org.codehaus.mojo</groupId>
   <artifactId>build-helper-maven-plugin</artifactId>
   <version>1.8</version>
   <executions>
       <execution>
           <id>add-source</id>
           <phase>generate-sources</phase>
           <goals>
               <goal>add-source</goal>
           </goals>
           <configuration>
               <sources>
                  <source>${project.build.directory}/generated-sources/config</source>;
               </sources>
           </configuration>
       </execution>
   </executions>
</plugin>
----
Earlier, the configuration yang module in the yang files was imported. In order to acquire this yang module, we need to add a dependency to the pom file: 
----
<dependency>
    <groupId>org.opendaylight.controller</groupId>
    <artifactId>config-api</artifactId>
    <version>${config.version}</version>
</dependency>
----
In addition, a couple of utility dependencies must be added:
----
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
</dependency>
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
</dependency>
----
Run *mvn clean install*. 

==== Generated java files

A set of new source files divided into two groups is seen. The first group is located under the ${project.build.directory}/generated-sources/config directory, which was specified in the yang-maven-plugin configuration. The second group is located under the src/main/java directory. Both groups then define the package org.opendaylight.controller.config.yang.config.demo.impl. The first group contains code that must not be edited in any way, since this code can be regenerated by the plugin if necessary. The code that needs to be edited belongs to the second group and is located under src/main/java.

===== Generated config source files examples

* BarImplModuleMXBean.java 
----
public interface BarImplModuleMXBean
{
    public org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute getDtoAttribute();
 
    public void setDtoAttribute(org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute dtoAttribute);
 
}
----
The BarImplModuleMXBean interface represents the getter and the setter for dtoAttribute that will be exported to the configuration registry by means of JMX. The attribute was defined in the yang model: in this case, it is the composite type which was converted to OpenType. 

* Attribute definition from config-demo-impl.yang 
----
// Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:foo;
        config:java-name-prefix BarImpl;
    }
 
    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";
 
            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }
 
                leaf int-attribute2 {
                    type int32;
                }
 
                leaf bool-attribute {
                    type boolean;
                }
            }
 
        }
    }
----
From the container dto-attribute, the DtoAttribute java file was generated. The Class contains the plain constructor, and the getters and setters for the attributes defined as container leaves.
Not only is ModuleMXBean generated from this module definition, but also BarImplModuleFactory and BarImplModule stubs (in fact AbstractBarImplModuleFactory and AbstractBarImplModule are generated too.). 

* AbstractBarImplModule.java +
This abstract class is almost fully generated: only the method validate() has an empty body and the method createInstance() is abstract. The user must implement both methods by user. AbstractBarImplModule implements its ModuleMXBean, Module, RuntimeBeanRegistratorAwareModule, and the dependent service interface as defined in yang. Moreover, the class contains two types of constructors: one for the module created from the old module instance, and the second for module creation from scratch. 

* AbstractBarImplModuleFactory.java +
Unlike AbstractModule, AbstractFactory is fully generated, but it is still an abstract class. The factory is responsible for module instances creation, and provides two type of instantiateModule methods for both module constructor types. It implements the ModuleFactory interface. 

Next, create the runtime bean for FooImplModule. Runtime beans are designated to capture data about the running module. 

* Add runtime bean definition to config-demo-impl.yang +

===== Modifying generated sources

Generated source files: +

* src/main/java/**/BarImplModule 
* src/main/java/**/BarImplModuleFactory 
* src/main/java/**/FooImplModule 
* src/main/java/**/FooImplModuleFactory 

*BarImplModule* +
We will start by modifying BarImplModule. Two constructors and two generated methods are seen: 
----
@Override
    public void validate(){
        super.validate();
        // Add custom validation for module attributes here.
    }
 
    @Override
    public java.lang.AutoCloseable createInstance() {
        //TODO:implement
        throw new java.lang.UnsupportedOperationException("Unimplemented stub method");
    }
----
In *validate*, specify the validation for configuration attributes, for example:
----
@Override
    public void validate(){
        super.validate();  
        Preconditions.checkNotNull(getDtoAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getBoolAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute2());
        Preconditions.checkState(getDtoAttribute().getIntAttribute() > getDtoAttribute().getIntAttribute2());
    }
----
In *createInstance* you need to create a new instance of the bar service => Bar interface, for example:
----
@Override
    public java.lang.AutoCloseable createInstance() {
        return new BarImpl(getDtoAttribute().getIntAttribute(), getDtoAttribute().getIntAttribute2(), getDtoAttribute()
                .getBoolAttribute());
    }
----
===== Notes: 

* createInstance returns AutoCloseable so the returned type needs to implement it. (You can make BarImpl implement AutoCloseable, or create a Wrapper class around the BarImpl instance that implements AutoCloseable, or even extend the BarImpl class and make it implement it.) 
* You can access all the configuration attributes by means of the getter methods. 
* In config-demo-impl.yang, we defined the bar-impl configuration as a container dto-attribute. The code generator creates a transfer object DtoAttribute that you can access by means of the getDtoAttribute() method, and retrieve configuration data from it. You can even add a new constructor to BarImpl that takes this transfer object, and reduces the number of arguments. 

*FooImplModule* +
We will not add any custom validation in this module. The createInstance method will look as follows: +
----
 @Override
    public java.lang.AutoCloseable createInstance() {
        return new FooImpl(getStrAttribute(), getIntAttribute(), getBarDependencyDependency());
    }
----
===== Adding support for default instances

In order to provide a default instance of module bar-impl, we need to further modify the generated code by the overriding method getDefaultModules in src/main/java/**/BarImplModuleFactory class. The body of this class is empty thus far, and it inherits the default behaviour from its parent abstract factory. Use the following code to replace the empty body: 
----
public static final ModuleIdentifier defaultInstance1Id = new ModuleIdentifier(NAME, "defaultInstance1");
 
    @Override
    public Set<BarImplModule> getDefaultModules(DependencyResolverFactory dependencyResolverFactory, BundleContext bundleContext) {
        DependencyResolver depResolver1 = dependencyResolverFactory.createDependencyResolver(defaultInstance1Id);
        BarImplModule defaultModule1 = new BarImplModule(defaultInstance1Id, depResolver1);
        defaultModule1.setDtoAttribute(getDefaultConfiguration(bundleContext));
 
        return Sets.newHashSet(defaultModule1);
    }
 
    private DtoAttribute getDefaultConfiguration(BundleContext bundleContext) {
        DtoAttribute defaultConfiguration = new DtoAttribute();
 
        String property = bundleContext.getProperty("default.bool");
        defaultConfiguration.setBoolAttribute(property == null ? false : Boolean.parseBoolean(property));
 
        property = bundleContext.getProperty("default.int1");
        defaultConfiguration.setIntAttribute(property == null ? 55 : Integer.parseInt(property));
 
        property = bundleContext.getProperty("default.int2");
        defaultConfiguration.setIntAttribute2(property == null ? 0 : Integer.parseInt(property));
 
        return defaultConfiguration;
    }
----
The _getDefaultModules_ method now produces an instance of the bar-impl module with the name _defaultInstance1_. (It is possible to produce multiple default instances since the return type is a Set of module instances.) Note the getDefaultConfiguration method. It provides the default configuration for default instances by trying to retrieve system properties from bundleContext (or provides hardcoded values in case the system property is not present). 

For the controller distribution, system properties can be fed by means of _config.ini_ file. 

The method _getDefaultModules_ is called automatically after a bundle containing this factory is started in the OSGi environment. Its default implementation returns an empty Set. 

The default instances approach is similar to the Activator class approach in OSGi with the advantage of default instances being managed by the configuration subsystem. This approach can either replace the Activator class approach, or be used along with it. 

*Verifying the default instances in distribution* +

If we add the config-demo bundle to the opendaylight distribution, we can verify the presence of the default instance. The file pom.xml under the opendaylight/distribution/opendaylight folder needs to be modified by adding the config-demo dependency: 
----
<dependency>
    <groupId>${project.groupId}</groupId>
    <artifactId>config-demo</artifactId>
    <version>0.1.1-SNAPSHOT</version>
</dependency>
----
Now we need to rebuild the conf-demo module using mvn clean install. Then, we can build the distribution using the same mvn command under the _opendaylight/distribution/opendaylight_ folder. If we go to the _opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight_ folder, and execute run.sh, the opendaylight distribution should start. 

We can check the presence of the default instances by means of JMX using a tool such as _jvisualvm_.

=== OpenDaylight Controller:Configuration examples user guide
==== Configuring thread pools with yangcli-pro
Requirements: yangcli-pro version 13.04-9.2 or later +

===== Connecting to plaintext TCP socket and ssh
Currently SSH is exposed by the controller. The network interface and port are configured in configuration/config.ini . The current configuration of netconf is as follows: +
----
# Netconf startup configuration
#netconf.tcp.address=127.0.0.l
#netconf.tcp.port=8383
 
netconf.ssh.address=0.0.0.0
netconf.ssh.port=1830
----
To connect the yangcli-pro client, use the following syntax: +
----
yangcli-pro --user=admin --password=admin --transport=ssh --ncport=1830 --server=localhost
----
If the plaintext TCP port is not commented out, one can use the following: +
----
yangcli-pro --user=a --password=a --transport=tcp --ncport=8383 --server=localhost
----
Authentication in this case is ignored.

For better debugging, include following arguments: +
----
--log=/tmp/yuma.log --log-level=debug4 --log-console
----

NOTE:  When the log file is set, the output will not appear on stdout.

===== Configuring threadfactory
The threadfactory is a service interface that can be plugged into threadpools, defined in config-threadpool-api (see the https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=blob;f=opendaylight/config/threadpool-config-api/src/main/yang/threadpool.yang;h=8f3064822be319dfee6fd7c7061c8bee14db268f;hb=refs/heads/master[yang file].
The implementation to be used is called threadfactory-naming. This implementation will set a name for each thread created using a configurable prefix and auto incremented index. See the https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=blob;f=opendaylight/config/threadpool-config-impl/src/main/yang/threadpool-impl.yang;h=a2366f285a0c0b8682b1093f18fb5ee184c9cde3;hb=refs/heads/master[Yang file].

. Launch yangcli-pro and connect to the server.
. Enter *get-config source=running* to see the current configuration. +
Example output: +
----
rpc-reply {
  data {
    modules {
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
    }
    services {
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----
[start=3]
. Enter the merge /modules/module.
. At the prompt, enter the string value for the leaf <name>. This is the name of the config module. Enter threadfactory-bgp.
. Set the identityref for the leaf <type>. Press Tab to see a list of available module names. Enter threadfactory-naming.
. At the prompt, choose the case statement. Example output:
----
 1: case netty-threadgroup-fixed:
       leaf thread-count
  2: case netty-hashed-wheel-timer:
       leaf tick-duration
       leaf ticks-per-wheel
       container thread-factory
  3: case async-eventbus:
       container threadpool
  4: case threadfactory-naming:
       leaf name-prefix
  5: case threadpool-fixed:
       leaf max-thread-count
       container threadFactory
  6: case threadpool-flexible:
       leaf max-thread-count
       leaf minThreadCount
       leaf keepAliveMillis
       container threadFactory
  7: case threadpool-scheduled:
       leaf max-thread-count
       container threadFactory
  8: case logback:
       list file-appenders
       list rolling-appenders
       list console-appenders
       list loggers
----
In this case, we chose 4. +
[start=7]
. Next fill in the string value for the leaf <name-prefix>. Enter bgp.
: (You should get an OK response from the server.)
[start=8]
. Optionally issue get-config source=candidate to verify the change.
. Issue commit.
. Issue get-config source=running. Example output: +
----
rpc-reply {
  data {
    modules {
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
      module  threadfactory-bgp {
        type th-java:threadfactory-naming
        name threadfactory-bgp
        name-prefix bgp
      }
    }
    services {
      service  th:threadfactory {
        type th:threadfactory
        instance  ref_threadfactory-bgp {
          name ref_threadfactory-bgp
          provider /modules/module[type='threadfactory-naming'][name='threadfactory-bgp']
        }
      }
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----
==== Configuring fixed threadpool

Service interface threadpool is defined in the config-threadpool-api. The implementation used is called threadpool-fixed that is defined in config-threadpool-impl. This implementation creates a threadpool of fixed size. There are two mandatory attributes: size and dependency on a threadfactory.

. Issue get-config source=running. As you can see in the last step of configuring threadfactory, /services/service, the node associated with it has instance name ref_threadfactory-bgp.
. Issue merge /modules/module.
. Enter the name bgp-threadpool.
. Enter the type threadpool.
. Select the appropriate case statement.
. Enter the value for leaf <max-thread-count>: 100.
. Enter the threadfactory for attribute threadfactory/type. This is with reference to /services/service/type, in other words, the service interface.
. Enter ref_threadfactory-bgp.
Server response must be an OK message.
[start=9]
. Issue commit.
. Issue get-config source=running.
Example output: +
----
rpc-reply {
  data {
    modules {
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
      module  bgp-threadpool {
        type th-java:threadpool-fixed
        name bgp-threadpool
        threadFactory {
          type th:threadfactory
          name ref_threadfactory-bgp
        }
        max-thread-count 100
      }
      module  threadfactory-bgp {
        type th-java:threadfactory-naming
        name threadfactory-bgp
        name-prefix bgp
      }
    }
    services {
      service  th:threadpool {
        type th:threadpool
        instance  ref_bgp-threadpool {
          name ref_bgp-threadpool
          provider /modules/module[type='threadpool-fixed'][name='bgp-threadpool']
        }
      }
      service  th:threadfactory {
        type th:threadfactory
        instance  ref_threadfactory-bgp {
          name ref_threadfactory-bgp
          provider /modules/module[type='threadfactory-naming'][name='threadfactory-bgp']
        }
      }
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----
To see the actual netconf messages, use the logging arguments described at the top of this page. To validate that a threadpool has been created, a tool like VisualVM can be used.

==== Logback configuration - Yuma
This approach to configure logback will utilize a 3rd party cli netconf client from Yuma. We will modify existing console appender in logback and then call reset rpc on logback to clear its status list.

For initial configuration of the controller and startup parameters for yuma, see the threadpool example: https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:Threadpool[Threadpool configuration using Yuma].

Start the controller and yuma cli client as in the previous example.

There is no need to initialize the configuration module wrapping logback manually, since it creates a default instance. Therefore you should see the output containing logback configuration after the execution of get-config source=running command in yuma:
----
rpc-reply {
  data {
    modules {
      module  singleton {
        type logging:logback
        name singleton
        console-appenders {
          threshold-filter ERROR
          name STDOUT
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{36} - %msg%n'
        }
        file-appenders {
          append true
          file-name logs/audit.log
          name audit-file
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} %msg %n'
        }
        loggers {
          level WARN
          logger-name org.opendaylight.controller.logging.bridge
        }
        loggers {
          level INFO
          logger-name audit
          appenders audit-file
        }
        loggers {
          level ERROR
          logger-name ROOT
          appenders STDOUT
          appenders opendaylight.log
        }
        loggers {
          level INFO
          logger-name org.opendaylight
        }
        loggers {
          level WARN
          logger-name io.netty
        }
        rolling-appenders {
          append true
          max-file-size 10MB
          file-name logs/opendaylight.log
          name opendaylight.log
          file-name-pattern logs/opendaylight.%d.log.zip
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{35} - %msg%n'
          clean-history-on-start false
          max-history 1
          rolling-policy-type TimeBasedRollingPolicy
        }
      }
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
    }
    services {
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----

===== Modifying existing console appender in logback
. Start edit-config with merge option:
----
merge /modules/module
----
[start=2]
. For Name of the module, enter *singleton*.
. For Type, enter *logback*.
. Pick the corresponding case statement with the name logback.
We do not want to modify file-appenders, rolling-appenders and loggers lists, so the answer to questions from yuma is N (for no):
----
Filling optional case /modules/module/configuration/logback:
Add optional list 'file-appenders'?
Enter Y for yes, N for no, or C to cancel: [default: Y]
----
[start=5]
. As we want to modify console-appenders, the answer to the question from Yuma is Y:
----
Filling optional case /modules/module/configuration/logback:
Add optional list 'console-appenders'?
Enter Y for yes, N for no, or C to cancel: [default: Y]
----
[start=6]
. This will start a new configuration process for console appender and we will fill following values:

* <encoder-pattern> %date{"yyyy-MM-dd HH:mm:ss.SSS z"} %msg %n
* <threshold-filter> INFO
* <name> STDOUT
[start=7]
. Answer N to the next question.
----
Add another list?
Enter Y for yes, N for no, or C to cancel: [default: N]
----
Notice that we changed the level for threshold-filter for STDOUT console appender from ERROR to INFO. Now issue a commit command to commit the changed configuration, and the response from get-config source=running command should look like this:
----
rpc-reply {
  data {
    modules {
      module  singleton {
        type logging:logback
        name singleton
        console-appenders {
          threshold-filter INFO
          name STDOUT
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{36} - %msg%n'
        }
        file-appenders {
          append true
          file-name logs/audit.log
          name audit-file
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} %msg %n'
        }
        loggers {
          level WARN
          logger-name org.opendaylight.controller.logging.bridge
        }
        loggers {
          level INFO
          logger-name audit
          appenders audit-file
        }
        loggers {
          level ERROR
          logger-name ROOT
          appenders STDOUT
          appenders opendaylight.log
        }
        loggers {
          level INFO
          logger-name org.opendaylight
        }
        loggers {
          level WARN
          logger-name io.netty
        }
        rolling-appenders {
          append true
          max-file-size 10MB
          file-name logs/opendaylight.log
          name opendaylight.log
          file-name-pattern logs/opendaylight.%d.log.zip
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{35} - %msg%n'
          clean-history-on-start false
          max-history 1
          rolling-policy-type TimeBasedRollingPolicy
        }
      }
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
    }
    services {
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----
==== Invoking RPCs
*Invoking Reset RPC on logback* +
The configuration module for logback exposes some information about its current state(list of logback status messages). This information can be accessed using get netconf operation or get command from yuma. Example response after issuing get command in yuma:
----
rpc-reply {
  data {
    modules {
      module  singleton {
        type logging:logback
        name singleton
        status {
          message 'Found resource [configuration/logback.xml] at
[file:/.../controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-
osgipackage/opendaylight/configuration/logback.xml]'
          level INFO
          date 2479534352
        }
        status {
          message 'debug attribute not set'
          level INFO
          date 2479534441
        }
        status {
          message 'Will scan for changes in
[[/.../controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-
osgipackage/opendaylight/configuration/logback.xml]] 
every 60 seconds.'
          level INFO
          date 2479534448
        }
        status {
          message 'Adding ReconfigureOnChangeFilter as a turbo filter'
          level INFO
          date 2479534448
        }
 ...
----
Logback also exposes an rpc called reset that wipes out the list of logback status messages and to invoke an rpc with name reset on module named singleton of type logback, following command needs to be issued in yuma:
----
reset context-instance="/modules/module[type='logback' and name='singleton']"
----
After an ok response, issuing get command should produce response with empty logback status message list:
----
rpc-reply {
  data {
    modules {
      module  singleton {
        type logging:logback
        name singleton
      }
    }
  }
}
----
This response confirms successful execution of the reset rpc on logback.

*Invoking shutdown RPC* +
This command entered in yuma will shut down the server. If all bundles do not stop correctly within 10 seconds, it will force the process to exit.
----
shutdown context-instance="/modules/module[type='shutdown' and name='shutdown']",input-secret="",max-wait-time="10000",reason="reason"
----
=== OpenDaylight Controller Configuration: Logback Examples
==== Logback Configuration Example

The Logback logger configuration is part of the config subsystem. This module allows changes to the Logback configuration at runtime. It is used here as an example to demonstrate the YANG to Java code generator and to show how the configuration transaction works. 

==== Java code generation
The logging configuration YANG module definition can be found in the config-logging.yang file. The code is generated by the yang-maven-plugin and yang-jmx-generator-plugin. The output java files are located as defined in the plugin configuration, where additional configuration parameters can be set. The logback module is defined as identity, with the base "config:module-type"; it does not provide or depend on any service interface. 
----
identity logback {
    description
        "Actual state of logback configuration.";
    base config:module-type;
    config:java-name-prefix Logback;
}
----
The next logback module attributes are defined in the "/config:modules/config:module/config:configuration" augment as the snippet below shows. 
----
augment "/config:modules/config:module/config:configuration" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";
 
        list console-appenders {
 
            leaf encoder-pattern {
                type string;
                mandatory true;
            }
 
            leaf threshold-filter {
                type string;
                default 'ALL';
            }
 
            leaf name {
                type string;
                mandatory true;
            }
            config:java-name-prefix ConsoleAppenderTO;
        }
         ...
----
Now LogbackModule and LogbackModuleFactory can be generated. In fact, three more java files related to this module will be generated. By the augment definition, TypeObjects too are generated (that is to say, ConsoleAppenderTO). They are regular java classes with getters and setters for arguments defined as leaves.

* *LogbackModuleMXBean* is the interface containing getters and setters for attributes defined in the configuration augment.
* *AbstractLogbackModule* is the abstract java class, which implements Module, RuntimeBeanRegistratorAwareModule, and LogbackModuleMXBean. It contains almost all functionality, except validate and createInstance methods. 
* *AbstractLogbackModuleFactory* is the abstract java class responsible for creating module instances. It implements the ModuleFactory interface.
* *LogbackModule* class extends AbstractLogbackModule. It is located in a different place (source/main/java) and can be modified by the user, so that the abstract method is implemented and the validate method is overridden. 
* *LogbackModuleFactory* class extends AbstractLogbackModuleFactory and overrides its instantiateModule methods.
Next, the runtime bean is defined in the "/config:modules/config:module/config:state" augment. +
----
augment "/config:modules/config:module/config:state" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";
 
        rpcx:rpc-context-instance "logback-rpc";
 
        list status {
            config:java-name-prefix StatusTO;
 
            leaf level {
                type string;
            }
 
            leaf message {
                type string;
            }
 
            leaf date {
                type uint32;
            }
        }
    }
}
----
* The *Generator* plugin creates another set of java files. 
* *LogbackRuntimeMXBean* is the interface extending RuntimeBean. It contains the getter method for the argument defined in the augment. 
* *LogbackRuntimeRegistrator* class serves as the registrator for runtime beans. 
* *LogbackRuntimeRegistration* class serves as the registration ticket. An instance is returned after registration. 

The Logback config also defines logback-rpc with the reset method. It is also defined in the state augment, owing to the context. 
----
identity logback-rpc;
rpc reset {
    input {
        uses rpcx:rpc-context-ref {
            refine context-instance {
                rpcx:rpc-context-instance logback-rpc;
            }
        }
    }
}
----
The Reset method is defined in the LogbackRuntimeMXBean interface.

==== Logback configuration: Jolokia

To create configuration on the running OSGi server: Jolokia (http://www.jolokia.org/) is used as a JMX-HTTP bridge, which listens at http://localhost:8080/controller/nb/v2/jolokia and curl to request over HTTP. 

. Start the controller. Find more here: https://wiki.opendaylight.org/view/OpenDaylight_Controller:Pulling,_Hacking,_and_Pushing_the_Code_from_the_CLI 
. Request Jolokia: 
----
curl http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The response must resemble the following: +
----
{
    "timestamp": 1382425537,
    "status": 200,
    "request": {
        "type": "version"
    },
    "value": {
        "protocol": "7.0",
        "agent": "1.1.1",
        "info": {
            "product": "equinox",
            "vendor": "Eclipse",
            "version": "3.8.1.v20120830-144521"
        }
    }
}
----
Jolokia is working. 
To configure Logback, first, create a configuration transaction. ConfigResgistryModule offers the operation beginConfig(), and to invoke it: 
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":[],"operation":"beginConfig"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The configuration transaction was created. The response received: +
----
{
    "timestamp": 1383034210,
    "status": 200,
    "request": {
        "operation": "beginConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction"
    }
}
----
At this stage, the transaction can be aborted, but we want to create the module bean to be configured. In the created ConfigTransaction call createModule method, the module identifier is logback, and the name must be singleton as only one instance of the Logback configuration is needed.
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction","arguments":["logback","singleton"],"operation":"createModule"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The LogbackModule bean was created. The response returned: 
----
{
    "timestamp": 1383034580,
    "status": 200,
    "request": {
        "operation": "createModule",
        "mbean": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction",
        "arguments": [
            "logback",
            "singleton"
        ],
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,instanceName=singleton,moduleFactoryName=logback,type=Module"
    }
}
----
* The configuration bean attributes are set to values obtained from the loggers configuration, with which the server was started. To see attributes, request: 
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"read", "mbean":"org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
In the response body, the value contains all attributes (CompositeData) and its nested attribute values. 
* Now, the proposed configuration can be committed.
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":["org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"],"operation":"commitConfig"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The configuration was successfully validated and committed, and the module instance created.
----
{
    "timestamp": 1383034793,
    "status": 200,
    "request": {
        "operation": "commitConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "arguments": [
            "org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"
        ],
        "type": "exec"
    },
    "value": {
        "newInstances": [
            {
                "objectName": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=Module"
            }
        ],
        "reusedInstances": [],
        "recreatedInstances": []
    }
}
----
* The runtime bean was registered, and can provide the status information of the configuration and rpc operation reset. To see the status, try requesting:
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"read","mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The entire logback status is in the response body. 

* To invoke the rpc method reset: 
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec",
"mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback",
"operation":"reset","arguments":[]}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The answer:
----
{
    "timestamp": 1383035001,
    "status": 200,
    "request": {
        "operation": "reset",
        "mbean": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=RuntimeBean",
        "type": "exec"
    },
    "value": null
}
----
Now, the runtime bean status attribute will be empty: 
----
{
    "timestamp": 1383035126,
    "status": 200,
    "request": {
        "mbean": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=RuntimeBean",
        "type": "read"
    },
    "value": {
        "StatusTO": []
    }
}
----
==== Logback configuration: Netconf

In this case, NETCONF RPCs are used to configure logback. The Netconf server listens at port 8383. To communicate over TCP, telnet is used. More about NETCONF is available at: http://tools.ietf.org/html/rfc6241. Netconf implementation is a part of the Controller - netconf-subsystem. The RPCs of Netconf are XML, and the operations are mapped to JMX operations. 
* A server re-start is required. The procedure is the same as above. 
* Open a terminal and connect to the server:
----
telnet localhost 8383
----
A Hello message received from the server contains the server capabilities and session-id. To establish connection to the client,send a hello message: 
----
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <capabilities>
        <capability>urn:ietf:params:netconf:base:1.0</capability>
    </capabilities>
</hello>
]]>]]>
----
* With the connection created, the client and server can communicate. To see the running modules and services, send an RPC to the server:
----
<rpc id="a" a="64" xmlnx="a:b:c:d" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <running/>
        </source>
    </get-config>
</rpc>
]]>]]>
----

* To configure logback, create a configuration transaction, and create a configuration module. It can be done in one step (in client point of view): 
----
<rpc message-id="a" a="64" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
        <target>
            <candidate/>
        </target>
        <default-operation>merge</default-operation>
        <config>
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <name>singleton</name>
                    <type xmlns:logging="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
                        logging:logback
                    </type>
                </module>
            </modules>
        </config>
    </edit-config>
</rpc>
]]>]]>
----

If the configuration worked, the client receives a positive response: 

----
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
<ok/>
</rpc-reply>
]]>]]>
----

* The Logback configuration bean attributes contain values loaded from the running Logback configuration. Send a request to the server with an RPC:
----
<rpc id="a" a="64" xmlnx="a:b:c:d" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <candidate/>
        </source>
    </get-config>
</rpc>
]]>]]>
----

* The reply includes the entire configuration that started the server. Assume that we want to change the RollingFileAppender named opendaylight.log attributes - maxFileSize, filename, and maxHistory. ( attribute of TimeBasedRollingPolicy). The proposed configuration: 

----
<rpc message-id="a" a="64" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
        <target>
            <candidate/>
        </target>
        <default-operation>merge</default-operation>
        <config>
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <name>singleton</name>
                    <type xmlns:logging="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
                        logging:logback
                    </type>
		    <rolling-appenders xmlns="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
			<append>true</append>
			<max-file-size>5MB</max-file-size>
			<file-name>logs/opendaylight-new.log</file-name>
			<name>opendaylight.log</name>
			<file-name-pattern>logs/opendaylight.%d.log.zip</file-name-pattern>
			<encoder-pattern>%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{35} - %msg%n</encoder-pattern>
			<clean-history-on-start>false</clean-history-on-start>
			<max-history>7</max-history>
			<rolling-policy-type>TimeBasedRollingPolicy</rolling-policy-type>
		    </rolling-appenders>
                </module>
            </modules>
        </config>
    </edit-config>
</rpc>
]]>]]>
----
This configuration is merged with the proposed module configuration. If it passes the validation process successfully, an "ok" reply is received. 

* The configuration bean is ready to be committed:
----
<rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <commit></commit>
</rpc>
]]>]]>
---- 
If successful, the ok message is received obtained, and the logback configuration is set. To verify, look into the logs directory to find a new log file named opendaylight-new.log 

* Correctly close the session with the session-id: 
----
<rpc message-id="2" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <close-session xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"/>
</rpc>
]]>]]>
----
===== Logback configuration - Yuma

For a yangcli-pro example, see the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:User_guide[user guide]. 

=== Opendaylight Controller: Configuration Logback.xml
Logging in ODL container is done by means of http://logback.qos.ch/[Logback]. Comprehensive documentation is available at http://logback.qos.ch/documentation.html.

By default, logging messages are appended to stdout of the java process and to file logs/opendaylight.log. When debugging a problem it might be useful to increase logging level:
----
<logger name="org.opendaylight.controller" level="DEBUG"/>
----
Logger tags can be appended under root node <configuration/>. Name of logger is used to select all loggers to which specified rules should apply. Loggers are usually named after class in which they reside. The example above matches all loggers in controller - they all are starting with org.opendaylight.controller . There are 5 logging levels: TRACE,DEBUG,INFO, WARN, ERROR. Additionally one can specify which appenders should be used for given loggers. This might be helpful to redirect certain log messages to another file or send them to syslog or over SMTP. 
== OpenDaylight Controller Configuration: Examples of Threadpool

=== Configuration example of thread pools using yangcli-pro

For a yangcli-pro example, see the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:User_guide[Examples User Guide].

=== Configuration example of thread pools using telnet
It is also possible to manipulate the configuration without the yuma cli. With just a telnet or ssh connection, it is possible to send the plain text containing netconf rpcs encoded in the xml format and achieve the same results as with yuma cli. 

This example reproduces the configuration of a threadpool and a threadfactory from the previous example using just a telnet connection. We can also use ssh connection, with the netconf rpcs sending procedure remaining the same. For detailed information about initial configuration for the controller as well as the configuration process, see the example using yuma cli. 

=== Connecting to plaintext TCP socket

. Open a telnet connection:
----
telnet 127.0.0.1 8383
----
[start=2]
. Open an ssh connection: 
----
ssh netconf@127.0.0.1 -p 1830 -s netconf
----
The password for user netconf is : netconf, and the separator for the messages is: +
----
]]>]]>
----
Every message needs end with these 6 characters. 

The server sends a hello message: +
----
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
<capabilities>
<capability>urn:ietf:params:netconf:base:1.0</capability>
<capability>urn:ietf:params:netconf:capability:exi:1.0</capability>
<capability>urn:opendaylight:l2:types?module=opendaylight-l2-types&amp;revision=2013-08-27</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:netty:threadgroup?module=threadgroup&amp;revision=2013-11-07</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding?module=opendaylight-md-sal-binding&amp;revision=2013-10-28</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:threadpool?module=threadpool&amp;revision=2013-04-09</capability>
<capability>urn:ietf:params:netconf:capability:candidate:1.0</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:config?module=config&amp;revision=2013-04-05</capability>
<capability>urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring?module=ietf-netconf-monitoring&amp;revision=2010-10-04</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:netty:eventexecutor?module=netty-event-executor&amp;revision=2013-11-12</capability>
<capability>urn:ietf:params:xml:ns:yang:rpc-context?module=rpc-context&amp;revision=2013-06-17</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl?module=opendaylight-sal-binding-broker-impl&amp;revision=2013-10-28</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:netty:timer?module=netty-timer&amp;revision=2013-11-19</capability>
<capability>urn:ietf:params:xml:ns:yang:ietf-inet-types?module=ietf-inet-types&amp;revision=2010-09-24</capability>
<capability>urn:ietf:params:netconf:capability:rollback-on-error:1.0</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl?module=threadpool-impl&amp;revision=2013-04-05</capability>
<capability>urn:ietf:params:xml:ns:yang:ietf-yang-types?module=ietf-yang-types&amp;revision=2010-09-24</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:logback:config?module=config-logging&amp;revision=2013-07-16</capability>
<capability>urn:opendaylight:params:xml:ns:yang:iana?module=iana&amp;revision=2013-08-16</capability>
<capability>urn:opendaylight:yang:extension:yang-ext?module=yang-ext&amp;revision=2013-07-09</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:netty?module=netty&amp;revision=2013-11-19</capability>
<capability>http://netconfcentral.org/ns/toaster?module=toaster&amp;revision=2009-11-20</capability>
<capability>urn:opendaylight:params:xml:ns:yang:ieee754?module=ieee754&amp;revision=2013-08-19</capability>
<capability>urn:opendaylight:params:xml:ns:yang:nps-concepts?module=nps-concepts&amp;revision=2013-09-30</capability>
</capabilities>
 
<session-id>4</session-id>
</hello>
]]>]]>
----
[start=3]
. As the client, you must respond with a hello message: 
----
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <capabilities>
        <capability>urn:ietf:params:netconf:base:1.0</capability>
    </capabilities>
</hello>
]]>]]>
----
Although there is no response to the hello message, the session is already established. 

=== Configuring threadfactory

. The following is the Xml equivalent to *get-config source=running*: + 
----
<rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <running/>
        </source>
    </get-config>
</rpc>
]]>]]>
----
The response containing the current configuration: +
----
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
	<data>
		<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<module>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-broker-impl-singleton</type>
				<name>binding-broker-singleton</name>
			</module>
		</modules>
		<services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<service>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">prefix:binding-broker-osgi-registry</type>
				<instance>
					<name>ref_binding-broker-singleton</name>
					<provider>/modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']</provider>
				</instance>
			</service>
		</services>
	</data>
</rpc-reply>]]>]]>
----
[start=2]
. To create an instance of threadfactory-naming with the name threadfactory-bgp, and the attribute name-prefix set to bgp, send the message: 
----
<rpc message-id="101" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
	<edit-config>
		<target>
			<candidate/>
		</target>
		<default-operation>merge</default-operation>
		<config>
			<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
				<module xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="merge">
					<name>threadfactory-bgp</name>
					<type xmlns:th-java="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">th-java:threadfactory-naming</type>
					<name-prefix xmlns="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">bgp</name-prefix>
				</module>
			</modules>
		</config>
	</edit-config>
</rpc>]]>]]>
----
[start=3]
. To commit the threadfactory instance, send a commit message: 
----
<rpc message-id="101" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
	<commit/>
</rpc>]]>]]>
----
The Netconf endpoint should respond with ok to edit-config, as well as the commit message: +

----
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
        <ok/>
</rpc-reply>]]>]]>
----
[start=4]
. The response to the get-config message (the same as the first message sent in this example) should contain the commited instance of threadfactory-naming: 
----
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
	<data>
		<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<module>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-broker-impl-singleton</type>
				<name>binding-broker-singleton</name>
			</module>
 
			<module>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">prefix:threadfactory-naming</type>
				<name>threadfactory-bgp</name>
				<name-prefix xmlns="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">bgp</name-prefix>
			</module>
		</modules>
 
		<services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<service>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:threadpool">prefix:threadfactory</type>
				<instance>
					<name>ref_threadfactory-bgp</name>
					<provider>/modules/module[type='threadfactory-naming'][name='threadfactory-bgp']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">prefix:binding-broker-osgi-registry</type>
				<instance>
					<name>ref_binding-broker-singleton</name>
					<provider>/modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']</provider>
				</instance>
			</service>
		</services>
	</data>
</rpc-reply>]]>]]>
----
=== Configuring fixed threadpool

* To create an instance of *threadpool-fixed* , with the same configuration and the same dependency as before, send the following message: 

----
<rpc message-id="101" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
	<edit-config>
		<target>
			<candidate/>
		</target>
		<default-operation>merge</default-operation>
		<config>
			<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
				<module xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="merge">
					<name>bgp-threadpool</name>
					<type xmlns:th-java="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">th-java:threadpool-fixed</type>
					<max-thread-count xmlns="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">100</max-thread-count>
					<threadFactory xmlns="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">
						<type xmlns:th="urn:opendaylight:params:xml:ns:yang:controller:threadpool">th:threadfactory</type>
						<name>ref_th-bgp</name>
					</threadFactory>
				</module>
			</modules>
 
			<services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<service>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:threadpool">prefix:threadfactory</type>
				<instance>
					<name>ref_th-bgp</name>
					<provider>/modules/module[type='threadfactory-naming'][name='threadfactory-bgp']</provider>
				</instance>
			</service>
		</services>
		</config>
	</edit-config>
</rpc>]]>]]>
----
Notice the _services_ tag. If an instance is to be referenced as a dependency by another module, it needs to be placed under this tag as a service instance with a unique reference name. Tag _provider_ points to a unique instance that is already present in the config subsystem, or is created within the current edit-config operation. 
The tag _name_ contains the reference name that can be referenced by other modules to create a dependency. In this case, a new instance of threadpool uses this reference in its configuration under the _threadFactory_ tag).

You should get an ok response again, and the configuration subsystem will inject the dependency into the threadpool. Now you can commit the configuration (ok response once more) and the process is finished. The config subsystem is now in the same state as it was at the end of the previous example.

=== OpenDaylight Controller MD-SAL: Model reference

A full list of models, with links to the yang, descriptions, JavaDoc and REST APIs, see the OpenDaylight wiki page here: https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Model_Reference

////
==== Model reference

===== Yang extensions
[cols="5*",^]
|===
| Model | Description | ODL component 2+^| API definition

|https://git.opendaylight.org/gerrit/gitweb?p=yangtools.git;f=model/yang-ext/src/main/yang/yang-ext.yang;a=blob[yang-ext.yang] | Yang Extensions for OpenDaylight | https://wiki.opendaylight.org/view/YANG_Tools:Main[YANG Tools] 
| https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/yang-ext/target/apidocs/index.html[Javadoc] | https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/yang-ext/target/site/restconf/yang-ext.html[REST]
|===
===== Base types

[options="header"]
|===
| Model | Description | ODL component | API definition
| https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=concepts/src/main/yang/iana.yang;a=blob[iana.yang] | IANA definition of private enterprise number | https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS\PCEP] | --| --
| https://git.opendaylight.org/gerrit/gitweb?p=yangtools.git;f=model/iana/iana-afn-safi/src/main/yang/iana-afn-safi@2013-07-04.yang;a=blob[iana-afn-safi yang] | Definitions for the 'AFN' and 'SAFI' IANA-registered enumerations http://datatracker.ietf.org/doc/draft-ietf-netmod-iana-afn-safi/[Draft] | https://wiki.opendaylight.org/view/YANG_Tools:Main[Yang tools] | https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/iana/iana-afn-safi/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/iana/iana-afn-safi/target/site/restconf/iana-afn-safi.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=yangtools.git;f=model/iana/iana-if-type/src/main/yang/iana-if-type@2013-07-04.yang;a=blob[iana-if-type yang] | Definitions for IANA-registered interface types http://datatracker.ietf.org/doc/rfc7224/[Draft-ietf-netmod-iana-if-type]| https://wiki.opendaylight.org/view/YANG_Tools:Main[Yang tools]| https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/iana/iana-if-type/target/apidocs/index.html[JavaDoc]| https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/iana/iana-if-type/target/site/restconf/iana-if-type.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=concepts/src/main/yang/ieee754.yang;a=blob[ieee754.yang] | Definitions of IEEE754 floating point types | https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]| --| --
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=concepts/src/main/yang/network-concepts.yang;a=blob[network-concepts.yang] | Base network types | https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS\PCEP] | --| --
|===
===== Configuration subsystem
[cols="5*",^]
|===
| Model | Description | ODL component 2+^| API definition

5+^|Base types

| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/config-api/src/main/yang/config.yang;a=blob[config.yang] | Base YANG definitions for configuration subsystem | https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller] | https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/config-api/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config/config-api/target/site/models/config.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/config-api/src/main/yang/rpc-context.yang;a=blob[rpc-context.yang]| Base YANG definitions for rpc context reference used for rpc routing | https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]| https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/config-api/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config/config-api/target/site/models/rpc-context.html[REST]
5+^|Base modules
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/netty-threadgroup-config/src/main/yang/netty-threadgroup.yang;a=blob[netty-threadgroup.yang]| Base YANG definitions for netty threadgroup implementation |  https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller] | https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/netty-threadgroup-config/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config/netty-threadgroup-config/target/site/models/threadgroup.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/threadpool-config-impl/src/main/yang/threadpool-impl-flexible.yang;a=blob[threadpool-impl-flexible.yang] |Base YANG definitions for thread services pure Java implementation| https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller] | https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/threadpool-config-impl/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config/threadpool-config-impl/target/site/models/threadpool-impl-flexible.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/threadpool-config-impl/src/main/yang/threadpool-impl-scheduled.yang;a=blob[threadpool-impl-scheduled.yang] | Base YANG definitions for thread services pure Java implementation | https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]| https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/threadpool-config-impl/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config/threadpool-config-impl/target/site/models/threadpool-impl-scheduled.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/threadpool-config-impl/src/main/yang/threadpool-impl.yang;a=blob[threadpool-impl.yang] | Base YANG definitions for thread services pure Java implementation | https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]| https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/threadpool-config-impl/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config/threadpool-config-impl/target/site/models/threadpool-impl.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/threadpool-config-impl/src/main/yang/threadpool-impl-fixed.yang;a=blob[threadpool-impl-fixed.yang] |Base YANG definitions for thread services pure Java implementation | https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]| https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/threadpool-config-impl/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config/threadpool-config-impl/target/site/models/threadpool-impl-fixed.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/netty-config-api/src/main/yang/netty.yang;a=blob[netty.yang] | Base YANG definitions for netty services | https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]| JavaDoc| https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config/netty-config-api/target/site/models/netty.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/threadpool-config-api/src/main/yang/threadpool.yang;a=blob[threadpool.yang]| Base YANG definitions for thread-related services | https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]| https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/threadpool-config-api/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config//threadpool-config-api/target/site/models//threadpool.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/logback-config/src/main/yang/config-logging.yang;a=blob[config-logging.yang]| Base YANG definitions for logging service|https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]| https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/logback-config/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config//logback-config/target/site/models//config-logging.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/shutdown-api/src/main/yang/shutdown.yang;a=blob[shutdown.yang]| Base YANG definitions for shutdown service| https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]| https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/shutdown-api/target/apidocs/index.html[JavaDoc] | https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config//shutdown-api/target/site/models//shutdown.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/shutdown-impl/src/main/yang/shutdown-impl.yang;a=blob[ shutdown-impl.yang]|Base YANG definitions for shutdown implementation|https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]|https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/shutdown-impl/target/apidocs/index.html[JavaDoc] |https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config//shutdown-impl/target/site/models//shutdown-impl.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/netty-timer-config/src/main/yang/netty-timer.yang;a=blob[ netty-timer.yang]| Base YANG definitions for netty timer implementation| https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]| https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/netty-timer-config/target/apidocs/index.html[JavaDoc]| https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config//netty-timer-config/target/site/models//netty-timer.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/config/netty-event-executor-config/src/main/yang/netty-event-executor.yang;a=blob[ netty-event-executor.yang]| Base YANG definitions for netty event executor implementation| https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]|https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/config/netty-event-executor-config/target/apidocs/index.html[JavaDoc]| https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/config//netty-event-executor-config/target/site/models//netty-event-executor.html[REST]
|===
===== MD-SAL modules
[cols="5*",^]
|===
| Model | Description | ODL component 2+^| API definition

|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/sal-dom-api/src/main/yang/opendaylight-md-sal-common.yang;a=blob[opendaylight-md-sal-common.yang]|Common definition for MD-SAL| https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/md-sal/sal-dom-api/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/sal-dom-api/target/site/models/opendaylight-md-sal-common.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/sal-dom-api/src/main/yang/opendaylight-md-sal-dom.yang;a=blob[ opendaylight-md-sal-dom.yang]| Service definition for Binding Aware MD-SAL| https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/md-sal/sal-dom-api/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/sal-dom-api/target/site/models/opendaylight-md-sal-dom.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/sal-remote/src/main/yang/opendaylight-md-sal-remote.yang;a=blob[ opendaylight-md-sal-remote.yang]|Definition of types related to Internet Assigned Numbers Authority|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|JavaDoc| REST
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/sal-binding-config/src/main/yang/opendaylight-md-sal-binding.yang;a=blob[opendaylight-md-sal-binding.yang]| Service definition for Binding Aware MD-SAL| https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--| https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/sal-binding-config/target/site/models/opendaylight-md-sal-binding.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/sal-netconf-connector/src/main/yang/odl-sal-netconf-connector-cfg.yang;a=blob[odl-sal-netconf-connector-cfg.yang]|Service definition for Binding Aware MD-SAL| https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/md-sal/sal-netconf-connector/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/sal-netconf-connector/target/site/models/odl-sal-netconf-connector-cfg.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/sal-binding-broker/src/main/yang/opendaylight-binding-broker-impl.yang;a=blob[ opendaylight-binding-broker-impl.yang]|Service definition for Binding Aware MD-SAL|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/md-sal/sal-binding-broker/target/apidocs/index.html[JavaDoc]|--
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/sal-dom-broker/src/main/yang/opendaylight-dom-broker-impl.yang;a=blob[ opendaylight-dom-broker-impl.yang]|Service definition for Binding Aware MD-SAL| https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/md-sal/sal-dom-broker/target/apidocs/index.html[JavaDoc]|--
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/samples/toaster/src/main/yang/toaster.yang;a=blob[toaster.yang]|YANG version of the TOASTER-MIB|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL] |--|--
|===
===== Netconf endpoint
[cols="5*",^]
|===
| Model | Description | ODL component 2+^| API definition

|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/netconf/ietf-netconf-monitoring/src/main/yang/ietf-netconf-monitoring.yang;a=blob[ietf-netconf-monitoring.yang]|NETCONF Monitoring Module (http://datatracker.ietf.org/doc/rfc6022/[RFC 6022]|https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]|https://jenkins.opendaylight.org/controller/job/controller-daily/ws/opendaylight/netconf/ietf-netconf-monitoring/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/netconf//ietf-netconf-monitoring/target/site/models//ietf-netconf-monitoring.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/netconf/ietf-netconf-monitoring-extension/src/main/yang/ietf-netconf-monitoring-extension.yang;a=blob[ietf-netconf-monitoring-extension.yang]|NETCONF Monitoring Module extension for tcp transport type|https://wiki.opendaylight.org/view/OpenDaylight_Controller:Main[Controller]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/netconf//ietf-netconf-monitoring-extension/target/site/models//ietf-netconf-monitoring-extension.html[REST]
|===
===== Services
[cols="5*",^]
|===
| Model | Description | ODL component 2+^| API definition

5+^|Inventory
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-inventory/src/main/yang/opendaylight-inventory.yang;a=blob[opendaylight-inventory.yang]| The base (abstract) inventory model |https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-topology/target/site/models/opendaylight-topology.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-inventory/src/main/yang/netconf-node-inventory.yang;a=blob[ netconf-node-inventory.yang]|The netconf-specific augmentation of the base inventory model |https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-inventory/target/site/models/netconf-node-inventory.html[REST]
5+^|Topology

|https://git.opendaylight.org/gerrit/gitweb?p=yangtools.git;f=model/ietf/ietf-topology/src/main/yang/network-topology@2013-10-21.yang;a=blob[network-topology.yang]|The base (abstract) network topology model http://datatracker.ietf.org/doc/draft-clemm-netmod-yang-network-topo/[Draft-clemm]|https://wiki.opendaylight.org/view/YANG_Tools:Main[Yang tools]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-topology/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-topology/target/site/restconf/network-topology.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=yangtools.git;f=model/ietf/ietf-topology-l3-unicast-igp/src/main/yang/l3-unicast-igp-topology@2013-10-21.yang;a=blob[ l3-unicast-igp-topology.yang]|The base L3 IGP network topology model  http://datatracker.ietf.org/doc/draft-clemm-netmod-yang-network-topo/[Draft-clemm]|https://wiki.opendaylight.org/view/YANG_Tools:Main[Yang tools]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-topology-l3-unicast-igp/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-topology-l3-unicast-igp/target/site/restconf/l3-unicast-igp-topology.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=yangtools.git;f=model/ietf/ietf-topology-isis/src/main/yang/isis-topology@2013-10-21.yang;a=blob[isis-topology.yang]|Network topology data types specific to IS-IS (http://datatracker.ietf.org/doc/draft-clemm-netmod-yang-network-topo/[Draft clemm])|https://wiki.opendaylight.org/view/YANG_Tools:Main[Yang tools]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-topology-isis/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-topology-isis/target/site/restconf/isis-topology.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=yangtools.git;f=model/ietf/ietf-topology-ospf/src/main/yang/ospf-topology@2013-10-21.yang;a=blob[ospf-topology.yang]|Network topology data types specific to OSPF (http://datatracker.ietf.org/doc/draft-clemm-netmod-yang-network-topo/[Draft clemm])|https://wiki.opendaylight.org/view/YANG_Tools:Main[Yang tools]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-topology-ospf/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-topology-ospf/target/site/restconf/ospf-topology.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=yangtools.git;f=model/ietf/ietf-ted/src/main/yang/ted@2013-10-21.yang;a=blob[ted.yang]|Data types for the Traffic Engineering Database (http://datatracker.ietf.org/doc/draft-clemm-netmod-yang-network-topo/[Draft clemm])|https://wiki.opendaylight.org/view/YANG_Tools:Main[Yang tools]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-ted/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/yangtools/job/yangtools-merge/lastSuccessfulBuild/artifact/model/ietf/ietf-ted/target/site/restconf/ted.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=topology/segment-routing/src/main/yang/topology-tunnel-sr.yang;a=blob[topology-tunnel-sr.yang]|Segment Routing extensions to base tunnel topology model.|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS\PCEP] |--|--
5+^|Model topology
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-topology/src/main/yang/opendaylight-topology.yang;a=blob[opendaylight-topology.yang]|Opendaylight-topology|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-topology/target/site/models/opendaylight-topology.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-topology/src/main/yang/opendaylight-topology.yang;a=blob[opendaylight-topology.yang]|Opendaylight-topology-inventory|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-topology/target/site/models/opendaylight-topology-inventory.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-topology/src/main/yang/opendaylight-topology.yang;a=blob[opendaylight-topology.yang]|Opendaylight-topology-view|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-topology/target/site/models/opendaylight-topology-view.html[REST]
|===
===== OpenFlow services
[cols="5*",^]
|===
| Model | Description | ODL component 2+^| API definition

5+^|Flow base types
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-base/src/main/yang/opendaylight-action-types.yang;a=blob[opendaylight-action-types.yang]|Data types for OpenFlow action structures(https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-spec-v1.3.1.pdf[O.F 1.3.1 Section A 3.4.2]|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-base/target/site/models/opendaylight-action-types.html[REST]
| https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-base/src/main/yang/opendaylight-flow-types.yang;a=blob[ opendaylight-flow-types.yang]|Data types for programming flows (match, action, instruction, group, meter)|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-base/target/site/models/opendaylight-flow-types.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-base/src/main/yang/opendaylight-group-types.yang;a=blob[opendaylight-group-types.yang]|Data types for OpenFlow groups (https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-spec-v1.3.1.pdf[OF 1.3.1 Section 5.6])|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-base/target/site/models/opendaylight-group-types.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-base/src/main/yang/opendaylight-match-types.yang;a=blob[opendaylight-match-types.yang]|Opendaylight-match-types|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-base/target/site/models/opendaylight-match-types.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-base/src/main/yang/opendaylight-meter-types.yang;a=blob[opendaylight-meter-types.yang]|Data types for OpenFlow meter structures (https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-spec-v1.3.1.pdf[OF 1.3.1 Section 5.7])|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-base/target/site/models/opendaylight-meter-types.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-base/src/main/yang/opendaylight-port-types.yang;a=blob[opendaylight-port-types.yang]|Data types for OpenFlow port structures (https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-spec-v1.3.1.pdf[OF 1.3.1 Section A.2.1])|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-base/target/site/models/opendaylight-port-types.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-base/src/main/yang/opendaylight-queue-types.yang;a=blob[opendaylight-queue-types.yang]|Data types for OpenFlow action structures (https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-spec-v1.3.1.pdf[OF 1.3.1 Section A 3.6])|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-base/target/site/models/opendaylight-queue-types.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-base/src/main/yang/opendaylight-table-types.yang;a=blob[opendaylight-table-types.yang]|Data types for table programming (https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/openflow/openflow-spec-v1.3.1.pdf[OF 1.3.1 Section 5])|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-base/target/site/models/opendaylight-table-types.html[REST]
5+^|Flow service
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-service/src/main/yang/flow-capable-transaction.yang;a=blob[flow-capable-transaction.yang]|flow-capable-transaction| https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-service/target/site/models/flow-capable-transaction.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-service/src/main/yang/flow-errors.yang;a=blob[flow-errors.yang]|Flow errors|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-service/target/site/models/flow-errors.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-service/src/main/yang/flow-node-inventory.yang;a=blob[flow-node-inventory.yang]|flow-node-inventory |https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-service/target/site/models/flow-node-inventory.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-service/src/main/yang/flow-topology-discovery.yang;a=blob[flow-topology-discovery.yang]|flow-topology-discovery |https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-service/target/site/models/flow-topology-discovery.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-service/src/main/yang/packet-processing.yang;a=blob[packet-processing.yang]|packet-processing |https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-service/target/site/models/packet-processing.html[REST]
5+^|Flow statistics

|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-statistics/src/main/yang/opendaylight-flow-statistics.yang;a=blob[opendaylight-flow-statistics.yang]|individual and aggregate flow statistics APIs and notification interfaces | https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-statistics/target/site/models/opendaylight-flow-statistics.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-statistics/src/main/yang/opendaylight-flow-table-statistics.yang;a=blob[opendaylight-flow-table-statistics.yang]|Flow table statistics collection APIs and notification interfaces |https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-statistics/target/site/models/opendaylight-flow-table-statistics.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-statistics/src/main/yang/opendaylight-group-statistics.yang;a=blob[opendaylight-group-statistics.yang]|Group stats collection APIs and notification interfaces|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-statistics/target/site/models/opendaylight-group-statistics.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-statistics/src/main/yang/opendaylight-meter-statistics.yang;a=blob[opendaylight-meter-statistics.yang]|Meter collection APIs and notification interfaces |https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-statistics/target/site/models/opendaylight-meter-statistics.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-statistics/src/main/yang/opendaylight-port-statistics.yang;a=blob[opendaylight-port-statistics.yang]|Node connector stats collection APIs and notification interfaces|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-statistics/target/site/models/opendaylight-port-statistics.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-statistics/src/main/yang/opendaylight-queue-statistics.yang;a=blob[opendaylight-queue-statistics.yang]|Queue statistics collection APIs and notification interfaces|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-statistics/target/site/models/opendaylight-queue-statistics.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/model/model-flow-statistics/src/main/yang/opendaylight-statistics-types.yang;a=blob[opendaylight-statistics-types.yang]|Generic stats type definitions (Node Connector, Flow, Group, Meter, Queue etc.)|https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL[MD-SAL]|--|https://jenkins.opendaylight.org/controller/job/controller-merge/lastSuccessfulBuild/artifact/opendaylight/md-sal/model/model-flow-statistics/target/site/models/opendaylight-statistics-types.html[REST]
|===
===== Affinity services
[cols="5*",^]
|===
| Model | Description | ODL component 2+^| API definition

|https://git.opendaylight.org/gerrit/gitweb?p=affinity.git;f=affinity/yang/src/main/yang/affinity.yang;a=blob[affinity.yang]|Affinity|https://wiki.opendaylight.org/view/Project_Proposals:Affinity_Metadata_Service[Affinity metadata services]|--|--
|===
===== BGPPCEP
[cols="5*",^]
|===
5+^|BGP models
| Model | Description | ODL component 2+^| API definition

|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=bgp/concepts/src/main/yang/bgp-types.yang;a=blob[bgp-types.yang]|Contains the base concepts contained in http://datatracker.ietf.org/doc/rfc4271/[RFC 4271] and http://datatracker.ietf.org/doc/rfc4760/[RFC 4760]|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=bgp/parser-api/src/main/yang/bgp-message.yang;a=blob[bgp-message.yang]|Contains the base data model of a BGP message (http://datatracker.ietf.org/doc/rfc4271/[RFC 4271] and (http://datatracker.ietf.org/doc/rfc4893/[RFC 4893]|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=bgp/parser-api/src/main/yang/bgp-multiprotocol.yang;a=blob[bgp-multiprotocol.yang]|Base data model of a BGP message (http://datatracker.ietf.org/doc/rfc4271/[RFC 4271]|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=bgp/linkstate/src/main/yang/bgp-linkstate.yang;a=blob[bgp-linkstate.yang]|Base data model of a BGP message (http://datatracker.ietf.org/doc/rfc4271/[RFC 4271]|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=bgp/rib-api/src/main/yang/bgp-rib.yang;a=blob[bgp-rib.yang]|Contains the concept of a Routing Information Base, as defined by http://datatracker.ietf.org/doc/rfc4271/[RFC 4271]|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
5+^|PCEP models 
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=pcep/ietf-stateful02/src/main/yang/odl-pcep-crabbe-initiated00.yang;a=blob[odl-pcep-crabbe-initiated00.yang]|Data model for PCEP extensions defined in http://tools.ietf.org/html/draft-crabbe-pce-pce-initiated-lsp-00[Draft Crabbe]|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=pcep/api/src/main/yang/pcep-message.yang;a=blob[pcep-message.yang]|Base data model the the PCEP message http://datatracker.ietf.org/doc/rfc5440/[RFC 5440], https://datatracker.ietf.org/doc/rfc5520/[RFC 5520], and http://datatracker.ietf.org/doc/rfc6006/[1]|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=pcep/api/src/main/yang/pcep-message.yang;a=blob[pcep-message.yang[pcep-message.yang]|Base data types for the PCEP message (http://datatracker.ietf.org/doc/rfc5440/[RFC 5440], https://datatracker.ietf.org/doc/rfc5520/[RFC 5520], and http://datatracker.ietf.org/doc/rfc6006/[2])|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
5+^|RSVP models

|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=rsvp/api/src/main/yang/rsvp.yang;a=blob[rsvp.yang]|Contains the definition of types related to Resource Reservation Protocol (RSVP)|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
5+^|PCEP topology models 

| https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=pcep/topology-api/src/main/yang/network-topology-pcep.yang;a=blob[network-topology-pcep.yang]|PCEP extensions to base topology model|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=pcep/topology-api/src/main/yang/network-topology-pcep-programming.yang;a=blob[network-topology-pcep-programming.yang]|PCEP extensions to base topology model|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
5+^|PCEP tunnel topology models 
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=pcep/tunnel-api/src/main/yang/topology-tunnel-pcep.yang;a=blob[topology-tunnel-pcep.yang]|PCEP extensions to base tunnel topology model|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=pcep/tunnel-api/src/main/yang/topology-tunnel-pcep-programming.yang;a=blob[topology-tunnel-pcep-programming.yang]|Programming extensions for tunnel topologies|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
5+^|Programming models
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=programming/api/src/main/yang/programming.yang;a=blob[programming.yang]|The basic tunnel programming model|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]
|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=programming/topology-api/src/main/yang/network-topology-programming.yang;a=blob[network-topology-programming.yang]|Programming extensions for tunnel topologies|https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|https://git.opendaylight.org/gerrit/gitweb?p=bgpcep.git;f=programming/tunnel-api/src/main/yang/topology-tunnel-programming.yang;a=blob[topology-tunnel-programming.yang]|Programming extensions for tunnel topologies|
https://wiki.opendaylight.org/view/BGP_LS_PCEP:Main[BGP-LS PCEP]|--|--
|===
===== Plugins
[cols="5*",^]
|===
5+^|OpenFlow protocol library
| Model | Description | ODL component 2+^| API definition

|https://git.opendaylight.org/gerrit/gitweb?p=openflowjava.git;f=openflow-protocol-api/src/main/yang/openflow-action.yang;a=blob[openflow-action.yang]|Base Openflow actions|https://wiki.opendaylight.org/view/Openflow_Protocol_Library:Main[OpenFlowJava]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-merge/org.opendaylight.openflowjava$openflow-protocol-api/ws/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-verify/ws/openflow-protocol-api/target/site/restconf/openflow-action.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=openflowjava.git;f=openflow-protocol-api/src/main/yang/openflow-augments.yang;a=blob[openflow-augments.yang]|Object augmentations|https://wiki.opendaylight.org/view/Openflow_Protocol_Library:Main[OpenFlow Java]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-merge/org.opendaylight.openflowjava$openflow-protocol-api/ws/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-verify/ws/openflow-protocol-api/target/site/restconf/openflow-augments.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=openflowjava.git;f=openflow-protocol-api/src/main/yang/openflow-extensible-match.yang;a=blob[openflow-extensible-match.yang]|Openflow OXM match|
https://wiki.opendaylight.org/view/Openflow_Protocol_Library:Main[OpenFlow Java]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-merge/org.opendaylight.openflowjava$openflow-protocol-api/ws/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-verify/ws/openflow-protocol-api/target/site/restconf/openflow-extensible-match.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=openflowjava.git;f=openflow-protocol-api/src/main/yang/openflow-instruction.yang;a=blob[openflow-instruction.yang]|Base Openflow instructions|https://wiki.opendaylight.org/view/Openflow_Protocol_Library:Main[OpenFlowJava]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-merge/org.opendaylight.openflowjava$openflow-protocol-api/ws/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-verify/ws/openflow-protocol-api/target/site/restconf/openflow-instruction.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=openflowjava.git;f=openflow-protocol-api/src/main/yang/openflow-protocol.yang;a=blob[openflow-protocol.yang]|Openflow Protocol messages|https://wiki.opendaylight.org/view/Openflow_Protocol_Library:Main[OpenFlowJava]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-merge/org.opendaylight.openflowjava$openflow-protocol-api/ws/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-verify/ws/openflow-protocol-api/target/site/restconf/openflow-protocol.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=openflowjava.git;f=openflow-protocol-api/src/main/yang/openflow-types.yang;a=blob[openflow-types.yang]|Common Openflow specific types|https://wiki.opendaylight.org/view/Openflow_Protocol_Library:Main[OpenFlowJava]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-merge/org.opendaylight.openflowjava$openflow-protocol-api/ws/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-verify/ws/openflow-protocol-api/target/site/restconf/openflow-types.html[REST]
|https://git.opendaylight.org/gerrit/gitweb?p=openflowjava.git;f=openflow-protocol-api/src/main/yang/system-notifications.yang;a=blob[system-notifications.yang]|System notification objects|https://wiki.opendaylight.org/view/Openflow_Protocol_Library:Main[OpenFlowJava]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-merge/org.opendaylight.openflowjava$openflow-protocol-api/ws/target/apidocs/index.html[JavaDoc]|https://jenkins.opendaylight.org/openflowjava/job/openflowjava-verify/ws/openflow-protocol-api/target/site/restconf/system-notifications.html[REST]
|===
////