== OpenFlow Plugin

.OpenFlow plugin: Component map
[options="header"]
|===
| Artifact ID | Component | Description 
| openflowplugin | openflowplugin | Main implementation of OFPlugin
| openflowplugin-it test-provider drop-test test-scripts | test | Support for end-to-end, integration, and regression testing
| openflowplugin-controller-config | configSubsystem | Default configuration files for config subsystem 
| distributions-openflowplugin-base | distribution | OFPlugin distribution, based on  the distribution of the controller,
but the old (OF-1.0 only) plugin is replaced with the new plugin(OF-1.0+1.3)
| learning-switch sample-consumer | sample | Sample  projects demonstrating MD-SAL usage 
| vagrant | util | Materialize testing virtual machine containing mininet+ovs
|=== 

=== OpenFlow Plugin: Sequence diagrams

.Message Lifecycle
image::MessageLifecycle.jpg[width=500]

.Handshake Scenario
image::Handshake.png[width=500]

.Connection Sequence (Handshake) Flow Diagram
image::OF1_0_Switch_Handshake_Sequence.png[width=500]

.Message Order Preservation 
image::MessageOrderPreservation.jpg[width=500]

.Add Flow Sequence 
image::Add_flow.png[width=500]

.Generic Notification Sequence
image::Generic_notification.png[width=500]

=== OpenFlow Plugin:Config subsystem
==== Model provided modules by yang
*General model (interfaces)* - openflow-plugin-cfg.yang. +

* The provided module is defined (identity openflow-provider) 

* The target implementation is assigned (...OpenflowPluginProvider) 
----
module openflow-provider {
   yang-version 1;
   namespace "urn:opendaylight:params:xml:ns:yang:openflow:common:config";
   prefix "ofplugin-cfg";

   import config {prefix config; revision-date 2013-04-05; }
   description
       "openflow-plugin-custom-config";
   revision "2014-03-26" {
       description
           "Initial revision";
   }
   identity openflow-provider{
       base config:service-type;
       config:java-class "org.opendaylight.openflowplugin.openflow.md.core.sal.OpenflowPluginProvider";
   }
}
----
*Implementation model* - openflow-plugin-cfg-impl.yang + 

* The implementation of module is defined (+identity openflow-provider-impl+). 

** The class name of the generated implementation is defined (ConfigurableOpenFlowProvider). 

* The configuration of the module is defined through augmentation:  
** This module requires an instance of a binding-aware-broker (container binding-aware-broker). 
** Also required is a list of openflow-switch-connection-providers. (Those are provided by openflowjava: one plugin instance will orchester multiple openflowjava modules.)
----
module openflow-provider-impl {
   yang-version 1;
   namespace "urn:opendaylight:params:xml:ns:yang:openflow:common:config:impl";
   prefix "ofplugin-cfg-impl";

   import config {prefix config; revision-date 2013-04-05;}
   import openflow-provider {prefix openflow-provider;}
   import openflow-switch-connection-provider {prefix openflow-switch-connection-provider;revision-date 2014-03-28;}
   import opendaylight-md-sal-binding { prefix md-sal-binding; revision-date 2013-10-28;}


   description
       "openflow-plugin-custom-config-impl";

   revision "2014-03-26" {
       description
           "Initial revision";
   }

   identity openflow-provider-impl {
       base config:module-type;
       config:provided-service openflow-provider:openflow-provider;
       config:java-name-prefix ConfigurableOpenFlowProvider;
   }

   augment "/config:modules/config:module/config:configuration" {
       case openflow-provider-impl {
           when "/config:modules/config:module/config:type = 'openflow-provider-impl'";

           container binding-aware-broker {
               uses config:service-ref {
                   refine type {
                       mandatory true;
                       config:required-identity md-sal-binding:binding-broker-osgi-registry;
                   }
               }
           }
           list openflow-switch-connection-provider {
               uses config:service-ref {
                   refine type {
                       mandatory true;
                       config:required-identity openflow-switch-connection-provider:openflow-switch-connection-provider;
                   }
               }
           }
       }
   }
}
---- 
==== Generating config and sal classes from yangs
NOTE: Suitable code generators, needed in pom, are involved.

----
<build> ...
  <plugins>
    <plugin>
      <groupId>org.opendaylight.yangtools</groupId>
      <artifactId>yang-maven-plugin</artifactId>
      <executions>
        <execution>
          <goals>
            <goal>generate-sources</goal>
          </goals>
          <configuration>
            <codeGenerators>
              <generator>
                <codeGeneratorClass>
                  org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                </codeGeneratorClass>
                <outputBaseDir>${project.build.directory}/generated-sources/config</outputBaseDir>
                <additionalConfiguration>
                  <namespaceToPackage1>
                    urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                  </namespaceToPackage1>
                </additionalConfiguration>
              </generator>
              <generator>
                <codeGeneratorClass>
                  org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl
                </codeGeneratorClass>
                <outputBaseDir>${project.build.directory}/generated-sources/sal</outputBaseDir>
              </generator>
              <generator>
                <codeGeneratorClass>org.opendaylight.yangtools.yang.unified.doc.generator.maven.DocumentationGeneratorImpl</codeGeneratorClass>
                <outputBaseDir>${project.build.directory}/site/models</outputBaseDir>
              </generator>
            </codeGenerators>
            <inspectDependencies>true</inspectDependencies>
          </configuration>
        </execution>
      </executions>
      <dependencies>
        <dependency>
          <groupId>org.opendaylight.controller</groupId>
          <artifactId>yang-jmx-generator-plugin</artifactId>
          <version>0.2.5-SNAPSHOT</version>
        </dependency>
        <dependency>
          <groupId>org.opendaylight.yangtools</groupId>
          <artifactId>maven-sal-api-gen-plugin</artifactId>
          <version>${yangtools.version}</version>
          <type>jar</type>
        </dependency>
      </dependencies>
    </plugin>
    ...
----
* JMX generator (target/generated-sources/config)
 
* sal CodeGeneratorImpl (target/generated-sources/sal)
 
* Documentation generator (target/site/models): https://jenkins.opendaylight.org/openflowplugin/job/openflowplugin-merge/ws/openflowplugin/target/site/models/openflow-provider.html[openflow generator]and https://jenkins.opendaylight.org/openflowplugin/job/openflowplugin-merge/ws/openflowplugin/target/site/models/openflow-provider-impl.html[openflow provider impl].

==== Altering generated files
Those files were generated under src/main/java in the package as referred in yangs (if they exist, the generator will not overwrite them): +

* ConfigurableOpenFlowProviderModuleFactory 

The *instantiateModule* methods are extended in order to capture and inject the osgi BundleContext into module, so it can be injected into final implementation: *OpenflowPluginProvider* +module.setBundleContext(bundleContext);+ +

* ConfigurableOpenFlowProviderModule 

The *createInstance* method is extended in order to inject osgi BundleContext into the module implementation: +pluginProvider.setContext(bundleContext);+ 
 
==== Configuration xml file

The configuration file contains: +

* Required capabilities
  
** Modules definitions from openflowjava 

**  Definitions from openflowplugin 

* Modules definition 
 
** openflow:switch:connection:provider:impl (listening on port 6633, name=openflow-switch-connection-provider-legacy-impl) 
** openflow:switch:connection:provider:impl (listening on port 6653, name=openflow-switch-connection-provider-default-impl) 
** openflow:common:config:impl (having 2 services (wrapping those 2 previous modules) and binding-broker-osgi-registry injected) 
* Provided services  
** openflow-switch-connection-provider-default 
** openflow-switch-connection-provider-legacy 
** openflow-provider 
----
<snapshot>
 <required-capabilities>
   <capability>urn:opendaylight:params:xml:ns:yang:openflow:switch:connection:provider:impl?module=openflow-switch-connection-provider-impl&revision=2014-03-28</capability>
   <capability>urn:opendaylight:params:xml:ns:yang:openflow:switch:connection:provider?module=openflow-switch-connection-provider&revision=2014-03-28</capability>
   <capability>urn:opendaylight:params:xml:ns:yang:openflow:common:config:impl?module=openflow-provider-impl&revision=2014-03-26</capability>
   <capability>urn:opendaylight:params:xml:ns:yang:openflow:common:config?module=openflow-provider&revision=2014-03-26</capability>
 </required-capabilities>

 <configuration>

   
     <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
       <module>
         <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:openflow:switch:connection:provider:impl">
           prefix:openflow-switch-connection-provider-impl
         </type>
         <name>openflow-switch-connection-provider-default-impl</name>
         <port>6633</port>
         <switch-idle-timeout>15000</switch-idle-timeout>
       </module>
       <module>
         <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:openflow:switch:connection:provider:impl">
           prefix:openflow-switch-connection-provider-impl
         </type>
         <name>openflow-switch-connection-provider-legacy-impl</name>
         <port>6653</port>
         <switch-idle-timeout>15000</switch-idle-timeout>
       </module>


       <module>
         <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:openflow:common:config:impl">
           prefix:openflow-provider-impl
         </type>
         <name>openflow-provider-impl</name>
         
         <openflow-switch-connection-provider>
           <type xmlns:ofSwitch="urn:opendaylight:params:xml:ns:yang:openflow:switch:connection:provider">
             ofSwitch:openflow-switch-connection-provider
           </type>
           <name>openflow-switch-connection-provider-default</name>
         </openflow-switch-connection-provider>
         <openflow-switch-connection-provider>
           <type xmlns:ofSwitch="urn:opendaylight:params:xml:ns:yang:openflow:switch:connection:provider">
             ofSwitch:openflow-switch-connection-provider
           </type>
           <name>openflow-switch-connection-provider-legacy</name>
         </openflow-switch-connection-provider>


         <binding-aware-broker>
           <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">
             binding:binding-broker-osgi-registry
           </type>
           <name>binding-osgi-broker</name>
         </binding-aware-broker>
       </module>
     </modules>

     <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
       <service>
         <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:openflow:switch:connection:provider">
           prefix:openflow-switch-connection-provider
         </type>
         <instance>
           <name>openflow-switch-connection-provider-default</name>
           <provider>/modules/module[type='openflow-switch-connection-provider-impl'][name='openflow-switch-connection-provider-default-impl']</provider>
         </instance>
         <instance>
           <name>openflow-switch-connection-provider-legacy</name>
           <provider>/modules/module[type='openflow-switch-connection-provider-impl'][name='openflow-switch-connection-provider-legacy-impl']</provider>
         </instance>
       </service>

       <service>
         <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:openflow:common:config">prefix:openflow-provider</type>
         <instance>
           <name>openflow-provider</name>
           <provider>/modules/module[type='openflow-provider-impl'][name='openflow-provider-impl']</provider>
         </instance>
       </service>
     </services>
   

 </configuration>
</snapshot>
----
==== API changes
In order to provide multiple instances of modules from openflowjava, there is an API change. Previously, the OFPlugin got access to the SwitchConnectionProvider exposed by OFJava, and injected the collection of configurations so that for every configuration, a new instance of the TCP listening server was created. Now, those configurations are provided by the configSubsystem, and the configured modules (wrapping the original SwitchConnectionProvider) are injected into the OFPlugin (wrapping SwitchConnectionHandler). 

==== Providing config file (IT, local distribution/base, integration/distributions/base)
*openflowplugin-it* 

The whole configuration is contained in one file (controller.xml). The entries needed in order to start up and wire the OEPlugin + OFJava are simply added there. 

*OFPlugin/distribution/base* +

The new config file is added (src/main/resources/configuration/initial/42-openflow-protocol-impl.xml), and copied to the config/initial subfolder of the build. 

*Integration/distributions/build* +

In order to push the actual config into the config/initial subfolder of distributions/base in the integration project, a new artifact was created in OFPlugin. The openflowplugin-controller-config contains only the config xml file under src/main/resources. Another change was committed into the integration project. During a build, this config xml is extracted and copied to the final folder in order to be accessible during the controller run. 

=== Message Spy in OF Plugin

With the intent to debug, the OpenFlow plugin implements a Message Spy to monitor controller communications.
The Message Spy collects and displays message statistics.

==== Message statistics collection +
Message statistics are grouped according to message type and checkpoint. The counter assigned to a checkpoint and message class increases by 1 when a message passes through.
 
The following checkpoints count passing messages: +
----
/**
    * statistic groups overall in OFPlugin
    */
   enum STATISTIC_GROUP {
       /** message from switch, enqueued for processing */
       FROM_SWITCH_ENQUEUED,
       /** message from switch translated successfully - source */
       FROM_SWITCH_TRANSLATE_IN_SUCCESS,
       /** message from switch translated successfully - target */
       FROM_SWITCH_TRANSLATE_OUT_SUCCESS,
       /** message from switch where translation failed - source */
       FROM_SWITCH_TRANSLATE_SRC_FAILURE,
       /** message from switch finally published into MD-SAL */
       FROM_SWITCH_PUBLISHED_SUCCESS,
       /** message from switch - publishing into MD-SAL failed */
       FROM_SWITCH_PUBLISHED_FAILURE,
       
       /** message from MD-SAL to switch via RPC enqueued */
       TO_SWITCH_ENQUEUED_SUCCESS,
       /** message from MD-SAL to switch via RPC NOT enqueued */
       TO_SWITCH_ENQUEUED_FAILED,
       /** message from MD-SAL to switch - sent to OFJava successfully */
       TO_SWITCH_SUBMITTED_SUCCESS,
       /** message from MD-SAL to switch - sent to OFJava but failed*/
       TO_SWITCH_SUBMITTED_FAILURE
   }
----
==== Message statistics display +
Access the message statistics by means of logs, osgi, and jmx. +

* osgi command (on demand): This method is considered deprecated. +
: +osgi> dumpMsgCount+ +

* From the controller console where statistics are refreshed every 10 seconds:
+Required logback settings: <logger name="org.opendaylight.openflowplugin.openflow.md.queue.MessageSpyCounterImpl" level="DEBUG" />+

* As JMX from the jconsole:
** Start the OFplugin with the -jmx parameter.
** Tab MBeans contains org.opendaylight.controller.
** RuntimeBean has a msg-spy-service-impl.
** Operations provides makeMsgStatistics report functionality.

*Sample results* +
----
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_ENQUEUED: MSG[PortStatusMessage] -> +0 | 1
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_ENQUEUED: MSG[MultipartReplyMessage] -> +24 | 81
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_ENQUEUED: MSG[PacketInMessage] -> +8 | 111
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_IN_SUCCESS: MSG[PortStatusMessage] -> +0 | 1
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_IN_SUCCESS: MSG[MultipartReplyMessage] -> +24 | 81
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_IN_SUCCESS: MSG[PacketInMessage] -> +8 | 111
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[QueueStatisticsUpdate] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[NodeUpdated] -> +0 | 3
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[NodeConnectorStatisticsUpdate] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[GroupDescStatsUpdated] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[FlowsStatisticsUpdate] -> +3 | 19
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[PacketReceived] -> +8 | 111
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[MeterFeaturesUpdated] -> +0 | 3
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[GroupStatisticsUpdated] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[GroupFeaturesUpdated] -> +0 | 3
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[MeterConfigStatsUpdated] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[MeterStatisticsUpdated] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[NodeConnectorUpdated] -> +0 | 12
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_OUT_SUCCESS: MSG[FlowTableStatisticsUpdate] -> +3 | 8
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_TRANSLATE_SRC_FAILURE: no activity detected
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[QueueStatisticsUpdate] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[NodeUpdated] -> +0 | 3
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[NodeConnectorStatisticsUpdate] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[GroupDescStatsUpdated] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[FlowsStatisticsUpdate] -> +3 | 19
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[PacketReceived] -> +8 | 111
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[MeterFeaturesUpdated] -> +0 | 3
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[GroupStatisticsUpdated] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[GroupFeaturesUpdated] -> +0 | 3
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[MeterConfigStatsUpdated] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[MeterStatisticsUpdated] -> +3 | 7
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[NodeConnectorUpdated] -> +0 | 12
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_SUCCESS: MSG[FlowTableStatisticsUpdate] -> +3 | 8
DEBUG o.o.o.s.MessageSpyCounterImpl - FROM_SWITCH_PUBLISHED_FAILURE: no activity detected
DEBUG o.o.o.s.MessageSpyCounterImpl - TO_SWITCH_ENQUEUED_SUCCESS: MSG[AddFlowInput] -> +0 | 12
DEBUG o.o.o.s.MessageSpyCounterImpl - TO_SWITCH_ENQUEUED_FAILED: no activity detected
DEBUG o.o.o.s.MessageSpyCounterImpl - TO_SWITCH_SUBMITTED_SUCCESS: MSG[AddFlowInput] -> +0 | 12
DEBUG o.o.o.s.MessageSpyCounterImpl - TO_SWITCH_SUBMITTED_FAILURE: no activity detected
----

=== OpenFlow Plugin:Mininet
==== Mininet on debian wheezy(7), x86_64
===== Requirements

*Openvswitch* +

. Install all requirements.
----
apt-get install build-essential fakeroot
apt-get install debhelper autoconf automake libssl-dev pkg-config bzip2 openssl python-all procps python-qt4 python-zopeinterface python-twisted-conch
----
[start= 2]
. Install a few helper applications.
----
apt-get -y install screen sudo vim etckeeper mlocate autoconf2.13 libssl-dev graphviz  tcpdump  gdebi-core
----
==== Test the Python environment
*Python pip* + 

. Install setuptools.
----
wget https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py
sudo python ez_setup.py
----
[start= 2]
. Install pip.
----
wget https://raw.github.com/pypa/pip/master/contrib/get-pip.py
sudo python get-pip.py
----
[start= 3]
. Post install the python libraries required by the ODL testing script.
---- 
sudo pip install netaddr
----
=== Installation
==== Openvswitch 2.0.0
. Remove the old packages, as root:
---- 
sudo -i
apt-get remove openvswitch-common openvswitch-datapath-dkms openvswitch-controller openvswitch-pki openvswitch-switch
----
[start= 2]
. Download and unpack OpenV Switch 2.0.0. 
----
wget http://openvswitch.org/releases/openvswitch-2.0.0.tar.gz
tar zxvf openvswitch-2.0.0.tar.gz
----
*Build and install* +

. Install the openvswitch package. Deploy it using the module assistant at:  https://wiki.debian.org/ModuleAssistant 
----
cd ../
gdebi openvswitch-datapath-source_2.0.0-1_all.deb
module-assistant auto-install openvswitch-datapath
gdebi openvswitch-common_2.0.0-1_amd64.deb
gdebi openvswitch-switch_2.0.0-1_amd64.deb
gdebi openvswitch-pki_2.0.0-1_all.deb 
gdebi openvswitch-controller_2.0.0-1_amd64.deb
----
*Post installation settings* +
---- 
service openvswitch-controller stop
update-rc.d openvswitch-controller disable
----
*Test installation* +
---- 
ovs-vsctl show
ovs-vsctl --version
ovs-ofctl --version
ovs-dpctl --version
ovs-controller --version
----
==== Mininet 2.1.0

. Download and checkout the required version.
----
git clone git://github.com/mininet/mininet
cd mininet
git checkout -b 2.1.0 2.1.0
----
[start=2]
. Compile and install mininet.
----
gcc mnexec.c -o mnexec
mv mnexec /usr/bin/
python setup.py install
----
[start=3]
. Test the installation. 
----
mn --version
mn --test pingall
----
*Expected result* +
---- 
root@debian:~/mininet# mn --version
2.1.0
root@debian:~/mininet# mn --test pingall
*** Creating network
*** Adding controller
*** Adding hosts:
h1 h2 
*** Adding switches:
s1 
*** Adding links:
(h1, s1) (h2, s1) 
*** Configuring hosts
h1 h2 
*** Starting controller
*** Starting 1 switches
s1 
*** Ping: testing ping reachability
h1 -> h2 
h2 -> h1 
*** Results: 0% dropped (2/2 received)
*** Stopping 1 switches
s1 ..
*** Stopping 2 hosts
h1 h2 
*** Stopping 1 controllers
c0 
*** Done
completed in 0.269 seconds
----
*Post installation additions* +

* Modify the source code of the mininet node.py file as described in https://wiki.opendaylight.org/view/Openflow_Protocol_Library:OpenVirtualSwitch#Stage_3[Stage 3]. 
----
--- /root/mininet/build/lib.linux-x86_64-2.7/mininet/node.py    2013-11-22 03:35:12.000000000 -0800
+++ /usr/local/lib/python2.7/dist-packages/mininet-2.1.0-py2.7.egg/mininet/node.py      2013-11-22 06:17:07.350574387 -0800
@@ -952,6 +952,10 @@
            datapath: userspace or kernel mode (kernel|user)"""
         Switch.__init__( self, name, **params )
         self.failMode = failMode
+        protKey = 'protocols'
+        if self.params and protKey in self.params:
+               print 'have protcol params!'
+               self.opts += protKey + '=' + self.params[protKey]
         self.datapath = datapath
  
@@ -1027,8 +1031,9 @@
         if self.datapath == 'user':
             self.cmd( 'ovs-vsctl set bridge', self,'datapath_type=netdev' )
         int( self.dpid, 16 ) # DPID must be a hex string
+        print 'OVSswitch opts: ',self.opts
         self.cmd( 'ovs-vsctl -- set Bridge', self,
-                  'other_config:datapath-id=' + self.dpid )
+                  self.opts+' other_config:datapath-id=' + self.dpid)
         self.cmd( 'ovs-vsctl set-fail-mode', self, self.failMode )
         for intf in self.intfList():
             if not intf.IP():
----
*Start and test the modified mininet* +

. Start the mn session:
---- 
sudo mn --topo single,3  --controller 'remote,ip=<your controller IP>' --switch ovsk,protocols=OpenFlow10
----
[start=2]
. Alternatively, use this command:
---- 
sudo mn --topo single,3  --controller 'remote,ip=<your controller IP>' --switch ovsk,protocols=OpenFlow13
----
[start= 3]
. Test the version of the protocol used by switch "s1": 
----
ovs-ofctl -O OpenFlow10 show s1
ovs-ofctl -O OpenFlow13 show s1
----
=== Usage

REST tests openflowplugin
---- 
sudo python odl_tests.py --xmls 1,2
----
* For more option informations, use:
---- 
sudo python odl_tests.py --help
----
=== Coding tips for OpenFlow Plugin
If you use Eclipse, the following compiler settings might be useful either during coding or while fixing errors. 
The following errors are noteworthy:
 
* name shadowing. 
* null checks. 
* missing case in switch block. 
* missing break in case. 
* unused variables/parameters. 
* annotations checks (@override). 
* access to non accessible member of enclosing type. 
* If overriding hashcode or equals, both must be overriden.
 
Also useful are  warnings upon missing javadoc comments for public classes, members, and methods.

.Configure Compiler Errors and Warnings
image::codinghints1.png[height=750]

.Configure Javadoc
image::codinghints2.png[width=500]

=== OpenFlow Plugin: Wiring up notifications
==== Introduction
OpenFlow messages coming from the OpenflowJava plugin into MD-SAL Notification objects must be translated, and then published to the MD-SAL.

==== To create and register a Translator
. Create a Translator class. 
. Register the Translator. 
. Register the notificationPopListener to handle Notification Objects. 

==== Creating a Translator Class
An example is available in https://git.opendaylight.org/gerrit/gitweb?p=openflowplugin.git;a=blob;f=openflowplugin/src/main/java/org/opendaylight/openflowplugin/openflow/md/core/translator/PacketInTranslator.java;h=e0944c39bfacad1d396b15087f668d9d1fa1d95d;hb=HEAD[PacketInTranslator.java]. 

. Create the class.
----
public class PacketInTranslator implements IMDMessageTranslator<OfHeader, List<DataObject>> {
----
[start=2]
. Implement the translate function: 
----
public class PacketInTranslator implements IMDMessageTranslator<OfHeader, List<DataObject>> {

    protected static final Logger LOG = LoggerFactory
            .getLogger(PacketInTranslator.class);
    @Override
    public PacketReceived translate(SwitchConnectionDistinguisher cookie,
            SessionContext sc, OfHeader msg) { 
            ...
    }
----
[start=2]
. Ensure that the type is the expected one, and cast it:
---- 
        if(msg instanceof PacketInMessage) {
            PacketInMessage message = (PacketInMessage)msg;
            List<DataObject> list = new CopyOnWriteArrayList<DataObject>();
----
[start=3]
. Complete the translation and return.
---- 
            PacketReceived pktInEvent = pktInBuilder.build();
            list.add(pktInEvent);
            return list;
----
==== Registeing the Translator Class
* Go to https://git.opendaylight.org/gerrit/gitweb?p=openflowplugin.git;a=blob;f=openflowplugin/src/main/java/org/opendaylight/openflowplugin/openflow/md/core/MDController.java;h=d79e18704b05923eee2a2da57d02655e2af6d9c1;hb=HEAD[MDController.java] and in init() add register your Translator: 
----
public void init() {
        LOG.debug("Initializing!");
        messageTranslators = new ConcurrentHashMap<>();
        popListeners = new ConcurrentHashMap<>();
        //TODO: move registration to factory
        addMessageTranslator(ErrorMessage.class, OF10, new ErrorTranslator());
        addMessageTranslator(ErrorMessage.class, OF13, new ErrorTranslator());
        addMessageTranslator(PacketInMessage.class,OF10, new PacketInTranslator());
        addMessageTranslator(PacketInMessage.class,OF13, new PacketInTranslator());
----
NOTE: There is a separate registration for each of the OF10 and OF13. Basically, you indicate the type of openflowjava message you wish to translate for, the OF version, and an instance of your Translator.

==== Registering your MD-SAL message for notification to the MD-SAL
* In MDController.init() register to have the notificationPopListener handle your MD-SAL Message:
---- 
addMessagePopListener(PacketReceived.class, new NotificationPopListener<DataObject>());
----
When a message comes from the openflowjava plugin, it will be translated and published to the MD-SAL.

=== OpenFlow Plugin:Python test scripts
==== Prerequisites for Python test-scripts
* Linux based OS (these instructions cover debian 7 - wheezy) 
* Java 1.7+ 
* Python (v 2.6) 
* Openvswitch (v 2.0.0) 
* Mininet (v 2.1.0) 
* Controller (supporting openflow 1.3) 

==== Installing python tools
NOTE: Build python tools with python2.6, not the default python.

* wget https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py 
* python2.6 ez_setup.py 
* wget https://raw.github.com/pypa/pip/master/contrib/get-pip.py 
* python2.6 get-pip.py 

See <<_openflow_plugin_mininet>>

==== Installing Wireshark 
. apt-get install wireshark 
. Make yourself a standard user again (CTRL^D) 
. sudo dpkg-reconfigure wireshark-common 
. sudo usermod -a -G wireshark $USER 
. sudo reboot 

==== Adding openflow13 dissector to wireshark 
. mkdir /home/mininet/.wireshark/plugins/ 
. Copy the file openflow.so to this directory //TODO add attachment. 

==== Controller

*Install Java JDK and set JAVA_HOME* 

. apt-get install openjdk-7-jdk 
. Export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java 

*Download, unzip, and run the integration build* +

. Find the latest integration/distribution/base build on nexus. 
. Download it (using for example, wget <url to artifact.zip>) and unzip it (using for example, unzip <artifact.zip>) 
. Start the controller: 
----
cd opendaylight
./run.sh -of13
----
*Clone openflowplugin project* +

* git clone https://git.opendaylight.org/gerrit/p/openflowplugin.git

==== Tests

* locations: openflowplugin/test-scripts 
* content directory  
** xmls (switch configuration input in xml form) 
** openvswitch 
** *runnable files*:  
*** odl_crud_tests.py 
*** stress_test.py 
*** oper_data_test.py
*** sw_restart_test.py 

=== General
The tests are designed for running on Linux based machines with installed ovs and mininet python scripts. All scripts has to be started with same permission as mininet (*sudo*).
 Otherwise the scripts can not start mininet. All runnable scripts contains a *help* description for input parameters for a quick orientation. 
 
Basic parameters for all runnable scripts: 

* +--help+: dump help 
* +--mnport+: A controller port listener for the openflow switch communications. The parameter is used for configuration startup of the Mininet. A default value is *6653*. 
* +--odlhost+: A controller IP address. The parameter is used for configuration startup of the Mininet and for the rest address builders. A default value is *127.0.0.1* (localhost). 
* +--odlport+: A controller port listener for a http REST communication. The parameter is used for the rest address builders. 

=== ODL Test (odl_crud_tests.py)

The test scripts are designed like CRUD (Create Read Update Delete) End-to-End black-box test suite for testing the switch configuration inputs/outputs via RESTconf. (It could work with mininet [opf13] by CPqD,OVS only.) 

All inputs are read from xml files: +

* file prefix f*.xml -> Flow ; 
* file prefix g*.xml -> Group ; 
* file prefix m*.xml -> Meter ; 

NOTE: Only the Groups and the Meters are supported by CPqD.

The test uses: 

* RESTfull (GET, PUT, POST (create data only), DELETE) 
* RESTconf POST sal-services 

==== Test life cycle
 
. Read input and put in to controller via REST (PUT | POST | POST sal-add). 
. Get the stored data via REST from config DataStore and compare input vs output (GET). 
. Get the stored data via REST from operational DataStore and compare input vs output (GET). 
. Modify the input and the update put in to controller via REST (PUT | POST sal-update). 
. Delete the input via REST (DELETE | POST sal-remove). 
. Validate the delete process in config DS and operational DS (GET). 

=== Parameters
 
* +--odlhost+: odl controller host (default value is 127.0.0.1) 
* +--odlport+: odl RESTconf listening port (default value is 8080) 
* +--loglev+: tlogging level definition (default value is DEBUG) debug level contains request/response payload 
* +--mininet+: OpenVSwitch or CPqD (default OVS) 
* +--fxmls+:The number specifies a Flow test xml file from xmls directory (pattern: f{nr}.xml) (e.g. 1,3,34). This parameter has no default value. The script is testing all f_.xml files from xmls directory without --fxmls parameter. 0 means no test. The parameter is relevant for (OVS and CPqD) 
* +--mxmls+:The number specifies a Meter test xml file from xmls directory (pattern: m{nr}.xml) (e.g. 1,3). This parameter has no default value. The script is testing all m_.xml files from xmls directory without --mxmls parameter. 0 means no test. The parameter is relevant for (CPqD only) 
* +--gmls+:The number specifies a Group test xml file from xmls directory (pattern: g{nr}.xml) (e.g. 1,3). This parameter has no default value. The script is testing all g_.xml files from xmls directory without --gxmls parameter. 0 means no test. The parameter is relevant for (CPqD only) 
* +--confresp+: (configuration response) - define a delay to the Configruation Data Store (default = 0 sec.) Increase this value is important for a weaker controller machine 
* +--operresp+: (operation response) - define a delay to the Operation Data Store (defalut = 3 sec.) Increase this value is important for a weaker controller machine or a weaker network 
* +--coloring+: switcher for enable/disable coloring logged output 

NOTE: The script has a file and the console logging output handlers (file crud_test.log).

*cmd example*:
---- 
python odl_crud_tests.py --mininet 2 --fxmls 1 --gxmls 0 --mxmls 3 --loglev 2
----
cmd means: The script expects ODL Controller RESTconf listener in 127.0.0.1:8080; the script expects Mininet by CPqD (gxmls and mxmls params are not ignored); and the script create the tests for f1.xml, and m3.xml and the script shows only INFO and ERROR logging messages which are colourized. 

NOTE: The device Errors listener is not supported yet. We recommend that you use a wireshark tool for the investigation of an unexpected behaviour. 

=== Stress Test (stress_test.py)

The test simulates multiple connections for the repeatable END-TO-END add flow test scenario. The flow pattern is the same (look at openvswitch.flow_tools.py). The script changes only a flow_id value.

The test life cycle: 

* Initialize mininet and thread pool 
* The incremental add flow's group (in every thread from thread pool) 
* Check nr. of flows (validate numbers of flows with expected calculated values and make report) 
* Get all flows from switch directly by command line 
* Get all flows from configuration DataStore 
* Get all flows from the operational DataStrore 
* Incrementally delete the groups of the flow  (in every thread from thread pool) 
 final report 

*Parameters*: 

* +--threads+: number of threads which should be used for multiple connection simulation in the thread pool. The default value is 50 
* +--flows+: number of flows which should be used for add connection samples 

=== Operational Data Test (oper_data_test.py)

The test checks the operational store of the controller. The Flow addition action and deletion action from the Data Store. When a flow is added via REST, it is added to the config store and then pushed to the switch. When it is successfully pushed to the switch, it is also moved to the operational store. Deletion also happens the same way. 

You can specify the number of flows added by the parameter:
----
--flows : number of the flows which are add to switch. The default value is 100
---- 
=== Switch restart (sw_restart_test.py)

The test is for a flow addition to a switch after the switch has been restarted. After the switch is restarted, it should get the flow configuration from the controller operational datastore. The speed at which the configuration is pushed to the restarted switch may vary. So, you can specify the wait time; and the number of retries by wait time; and the number of retries by: 
----
sw_restart_test.py --wait WAIT_TIME (default is 30) 
sw_restart_test.py --retry NO_RETRIES (default is 1) 
----
You can also specify that flows are added by xmls from the /xmls folder. If you do not specify this parameter, the default xml template will be used.
---- 
sw_restart_test.py --xmls XMLS (default is generic template)
---- 
=== OpenFlow Plugin: Robot framework tests

==== Prerequisites for robot tests

* Virtual machine with Mininet for OF1.0 and OF1.3 and with OpenSwitch 
* Current version of ODL Controller 
* Python (v 2.6 and higher) 
* Robot framework 
* GIT 

==== Installation

There are in three puzzle pieces: +

* ODL controller 
* Mininet with ovs 
* Robot framework + tests 

NOTE: Use VMs to run them on the same machine or distribute them.
 
*All-in-one strategy: Advantages and disadvantages*

* Easy to transfer whole setup (if running on VM) 
* No network issues (especially between VMs) 
* However, there is no simple way to switch or update mininet or ovs 

*Distributed strategy: Robot + ODL controller on one VM, mininet on another* +

* Modularity 
* Transfer of the whole set-up involves two VMs 
* VMs need network access to one another (This can be achieved by the 'internal network' of virtualBox.) 

==== VM with Mininet

There are three options to create a VM: 

* Follow instructions on this Opendaylight wiki page at:
 https://wiki.opendaylight.org/view/CrossProject:Integration_Group:Create_System_Test_Environment#Install_Mininet_for_OF1.0_and_OF1.3[Install Mininet for OF1.0 and OF1.3]
* Download https://wiki.opendaylight.org/view/CrossProject:Integration_Group:Test_VMs#Links_to_VMs[Preinstalled VMs]
 or there is also a possibility to  create mininet VM from scratch (based on debian distribution) 

IMPORTANT: In order for robot framework to be able to control mininet through ssh the prompt on mininet VM has to end with ">" character. 

[options="header"]
|===

| Component | Topic | Included in Guide

| MD-SAL |Southbound Protocol Plugin | Developer guide

| MD-SAL a| Plugin Types:

* Southbound Protocol Plugin
* Manager-type Application
* Protocol Library
* Connector Plugin
| User Guide
|===

=== TLS support for OF Plugin

SDN separates the data plane from the control plane of networks. It is imperative that communication between the two planes is secure. +
Secure communications between the data plane switches and controllers on the control plane require the authentication of switches and controllers.
Authentication ensures that no unsecured switch connects to a controller, and that no unsecured controller manages a switch. When a controller with TLS configured is opened, the OpenFlow port only accepts Transport Layer Security (TLS) communications. 
Any switch without TLS configured will fail in its connection attempt. 
 
 
Open Secure Sockets Layer (SSL) provides the tools for the public key infrastructure (PKI) management required to establish secure connections between a controller and switches. +
Information on `SSL on Open vSwitch and ovs controller’ is available at: +
https://github.com/mininet/mininet/wiki/SSL-on-Open-vSwitch-and-ovs-controller +

In a lab environment, the private key of the controller resides on the mininet host that also acts as the Certification authority (CA) signing host. In a production environment, the key generation for the controller would be separate from that of the switches; only the public controller key is shared with the switches.

NOTE: While in a lab environment, TLS may be configured with the keystore shipped with the controller, the TLS configuration in a production environment must choose a different keystore.

*Creating and signing private and public key certificates* +
Use ovs pki to create private keys and public certificate files for the switches and the controller. +


. On the mininet host, verify whether PKI is initialized: +
: +ls /var/lib/openvswitch/pki/controllerca/cacert.pem+ +
. If PKI is not initialized, use: +ovs-pki init+ +
. To generate the signed certificates, use the request certificates sc-req.pem and ctl-req.pem:
----
$ ls /etc/openvswitch
conf.db ctl-cert.pem ctl-privkey.pem ctl-req.pem sc-cert.pem sc-privkey.pem sc-req.pem
system-id.conf
----
[start=4]
. To create private keys and public cert files for the switches and the controller, run the ovs-pki:
----
cd /etc/openvswitch
sudo ovs-pki req+sign sc switch
sudo ovs-pki req+sign ctl controller
----
[start=5]
. From .pem files, create an intermediate Open SSL PKCS 12 formatted keystore to hold the private key for the controller.
----
sudo openssl pkcs12 -export -in ctl-cert.pem -inkey ctl-privkey.pem \
-out ctl.p12 -name odlserver \
-CAfile /var/lib/openvswitch/pki/controllerca/cacert.pem -caname root -chain
You'll be prompted for a password, use "opendaylight"
Enter Export Password:
Verifying - Enter Export Password:
----
[start=6]
. Copy the intermediate keystore, which has the private key of the controller, and the switches public key cert file ( ctl.p12 and sc-cert.pem) from the mininet host to any work directory on the controller machine. Import the PKSC 12 format to a Java compatible format that the controller can use:
----
sftp mininet@mininetipaddress
mininet
sftp get ctl.p12 sc-cert.pem
quit
----
[start=7]
. For use in the steps that follow, find a keytool in a jdk bin directory, and add it to the path:
----
keytool -importkeystore \
        -deststorepass opendaylight -destkeypass opendaylight -destkeystore ctl.jks \
        -srckeystore ctl.p12 -srcstoretype PKCS12 -srcstorepass opendaylight \
        -alias odlserver
----
[start=8]
. Store the public key of the switch in a truststore:
----
keytool -importcert -file sc-cert.pem -keystore truststore.jks -storepass opendaylight
# when prompted "Trust this certificate? [no]:" enter  "yes"
# Certificate was added to keystore
----
[start=9]
. Copy the two keystores to the ssl configuration directory:
----
mkdir ODLINSTALL/configuration/ssl
cp ctl.jks truststore.jks ODLINSTALL/configuration/ssl
----
=== Configuring the ODL OpenFlow plugin

* Configure the OF plugin using the following:
----
cd configuration/initial
vi configuration/initial/42-openflowplugin.xml
# add the <tls> blocks as shown to each of the existing OF-switch-connection-provider modules

        <!-- default OF-switch-connection-provider (port 6633) -->
        <module>
          <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:openflow:switch:connection:provider:impl">
            prefix:openflow-switch-connection-provider-impl
          </type>
          <name>openflow-switch-connection-provider-default-impl</name>
          <port>6633</port>
          <switch-idle-timeout>15000</switch-idle-timeout>
          <tls>
            <keystore>configuration/ssl/ctl.jks</keystore>
            <keystore-type>JKS</keystore-type>
            <keystore-path-type>PATH</keystore-path-type>
            <keystore-password>opendaylight</keystore-password>
            <truststore>configuration/ssl/truststore.jks</truststore>
            <truststore-type>JKS</truststore-type>
            <truststore-path-type>PATH</truststore-path-type>
            <truststore-password>opendaylight</truststore-password>
            <certificate-password>opendaylight</certificate-password>
          </tls>

        </module>
        <!-- default OF-switch-connection-provider (port 6653) -->
        <module>
          <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:openflow:switch:connection:provider:impl">
            prefix:openflow-switch-connection-provider-impl
          </type>
          <name>openflow-switch-connection-provider-legacy-impl</name>
          <port>6653</port>
          <switch-idle-timeout>15000</switch-idle-timeout>
          <tls>
            <keystore>configuration/ssl/ctl.jks</keystore>
            <keystore-type>JKS</keystore-type>
            <keystore-path-type>PATH</keystore-path-type>
            <keystore-password>opendaylight</keystore-password>
            <truststore>configuration/ssl/truststore.jks</truststore>
            <truststore-type>JKS</truststore-type>
            <truststore-path-type>PATH</truststore-path-type>
            <truststore-password>opendaylight</truststore-password>
            <certificate-password>opendaylight</certificate-password>
          </tls>

        </module>
----
=== Configuring openvswitch SSL +

*To configure openswitch SSL* +

. Set ovs ssl options.
----
sudo ovs-vsctl set-ssl \
    /etc/openvswitch/sc-privkey.pem \
    /etc/openvswitch/sc-cert.pem \
    /var/lib/openvswitch/pki/controllerca/cacert.pem
----
[start=2]
. Start a mininet with SSL connections to the ODL controller.
..	Open the  `ssl_switch_tests.py’ file
----
#!/usr/bin/python
from mininet.net import Mininet
from mininet.node import Controller, RemoteController
from mininet.cli import CLI
from mininet.log import setLogLevel, info

def emptyNet():
    net = Mininet( controller=RemoteController )
    net.addController( 'c0' )
    h1 = net.addHost( 'h1' )
    h2 = net.addHost( 'h2' )
    s1 = net.addSwitch( 's1' )
    net.addLink( h1, s1 )
    net.addLink( h2, s1 )

    net.start()
    s1.cmd('ovs-vsctl set-controller s1 ssl:YOURODLCONTROLLERIPADDRESS:6633')

    CLI( net )
    net.stop()

if __name__ == '__main__':
    setLogLevel( 'info' )
    emptyNet()
----
[start=3]
. Start mininet with TLS:
----
chmod +x ssl_switch_test.py
sudo ./ssl_switch_test.py
----
=== Configuring a hardware switch with TLS

The configuration example that follows uses a Brocade MLX device. +
*To configure a hardware switch* +

. Set up a tftp server.
----
telnet@NetIron MLX-4 Router#enable
<enter config password>.
----
[start=2]
. Copy the sc-cert.pem and sc-privkey.pem files to the tftp sever on the controller:
----
telnet@NetIron MLX-4 Router(config)#copy tftp flash 10.0.0.1 sc-cert.pem client-certificate
telnet@NetIron MLX-4 Router(config)#copy tftp flash 10.0.0.1 sc-privkey.pem client-private-key
telnet@NetIron MLX-4 Router(config)#openflow controller ip-address 10.0.0.1
----
NOTE: A tftp server runs on the controller host "10.0.0.1".

==== Commands for debugging
*Debugging mininet* +
To see connection entries in the ovswitchd log file, use: +
+sudo tail /var/log/openvswitch/ovs-vswitchd.log+ +
*Debugging the ODL controller* + 
+./run.sh -Djavax.net.debug=ssl,handshake+ +

=== Open Flow Plugin: Support for extensibility
OpenFlow (OF) allows vendor-defined extensions to fields in the flow entries of flow tables. OpenFlow-1.3 specifications describe experimenter items using meter, queue, match, action, multipart, table features, and error message. The OF Plugin supports extensions to the action and match fields of flow entries. 
OF Plugin extensibility API is defined in the openflowplugin-extension-api (odl), for example,  converter interfaces, and  register or lookup keys. OF Plugin extensibility is dependent on the MD-SAL and the OpenFlow Java Library. +
The extensibility functionality uses a two-level conversion between the following: +

* The semantic high level model (MD-SAL) and the protocol-oriented low level model (OFJava)
* The low-level model (OFJava) and the Wire protocol

Vendor actions augment the MD-SAL model. MD-SAL defines the flow model using yang. Vendors can extend the existing MD-SAL models by using the augmentation feature of yang. Augments only add new items to the model. They neither remove nor modify existing models. The OFJava-API contains protocol related constants and interfaces describing how to work with OFJava and generated models (generated from yang files). These models are referred to as OFJava-API models. +

.OF Plugin support for extensibility
image::OFPlugin_ExtensibilitySupportInOFPlugin.png[width=500]

==== Converters (semantic level)
Converters aid communication between applications and devices by making possible the communication between southbound APIs and their North-bound counterparts. They translate MD-SAL models to OFJava-API models. The default set of converters reside in: openflowplugin/src/main/java/org/opendaylight/openflowplugin/openflow/md/core/sal/convertor

Converters act upon models from and to the MD-SAL. Inputs for *action converter from MD-SAL* are instances of the MD-SAL model: for example, in the case of action, OutputActionCase. The output contains OFJava-API models of Action transferred from applications to devices. Working in reverse, *action converters to MD-SAL* translate OFJava-API models (Action) to MD-SAL models (Action).

After a vendor bundle is activated, converters are registered with the OF plugin so that they can work. Registration is based on the augmentation type and version. Once the converters are registered, the OF Plugin can convert MD-SAL action to OF Java actions.

==== Approaches to action conversion
The sample that follows shows two approaches to converting action (ActionConvertor.java). The first approach relies on a key field in a generalExtension augmentation. The second approach directly creates the converter lookup key out of the action type.
----
else if (action instanceof GeneralExtensionGrouping) {
                
                /**
                  * TODO: EXTENSION PROPOSAL (action, MD-SAL to OFJava)
                 * - we might need sessionContext as converter input
                 * 
                 */
                
                GeneralExtensionGrouping extensionCaseGrouping = (GeneralExtensionGrouping) action;
                Extension extAction = extensionCaseGrouping.getExtension();
                ConverterExtensionKey<? extends ExtensionKey> key = new ConverterExtensionKey<>(extensionCaseGrouping.getExtensionKey(), version);
                ConvertorToOFJava<Action> convertor = 
                        OFSessionUtil.getExtensionConvertorProvider().getConverter(key);
                if (convertor != null) {
                    ofAction = convertor.convert(extAction);
                }
            } else {
                // try vendor codecs
                TypeVersionKey<org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.Action> key =
                        new TypeVersionKey<>(
                                (Class<? extends org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.Action>) action.getImplementedInterface(),
                                version);
                ConvertorActionToOFJava<org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.Action, Action> convertor = 
                        OFSessionUtil.getExtensionConvertorProvider().getConverter(key);
                if (convertor != null) {
                    ofAction = convertor.convert(action);
                }
            }
----
==== Encoders and decoders for augment messages (low level)

Augments are encoded using encoders. Vendor bundles register the encoders so that the OpenFlow Java Library can support the vendor actions. Default sets of encoders and decoders reside in /openflow-protocol-impl/src/main/java/org/opendaylight/openflowjava/protocol/impl/serialization and /openflow-protocol-impl/src/main/java/org/opendaylight/openflowjava/protocol/impl/deserialization.
The OF plugin uses encoders to create the binary (wire protocol) form of a message object, and write it to the buffer.

Decoders on the other hand are responsible for the following tasks: +

* Read binary buffer
* Detect the type of message (encoded in the header)
* Create the corresponding objects, and populate them with values from the buffer

==== Master decoder
Vendor decoders cannot be directly registered if the actual message type is outside the general header, and only vendor-provided logic can take decisions. Then a master decoder, which is also provided be the vendor, is used. The master decoder contains logic to register decoders and to distinguish between vendor actions. The same work-flow persists: the lookup decoder by key containing version, actionClass, vendorActionSubtype. (For example, the experimenter action makes it appear as if all actions from one vendor  have the same header, and the subtype of the actual action lies somewhere further in the buffer.)

The OFJava extensions provide the space for registering vendor encoders and master decoders. They also provide the lookup mechanism to pick the right decoder or encoder for work with a message or buffer.

=== Overload protection in the OF Plugin
Overload protection in the OpenFlow (OF) Plugin works in the following way: +

. The ConnectionConductor is the source from where all incoming messages are pushed to queues for asynchronous processing. It is the part of the OF Plugin closest to OFJava, and has on*Message methods (listeners to incoming messages). The ConnectionConductorImpl pushes messages to the QueueKeeper. Every ConnectionConductor has a local instance of the QueueKeeper. +
The QueueKeeper has two queues: +
** Unordered queues (for packetIn messages)
** Ordered queues (for other messages) +
Both queue types are limited and blocking.
[start=2]
. If a particular queue is full, the messages pushed to it will be dropped. Upon a successful push, the harverster is pinged to be roused from hibernation.
. A QueueZipper wraps the two queues, and provides the poll method. This poll method rotates regularly through the underlying queues. If the currently polled queue is empty, it polls the next queue. (See QueueKeeperFairImpl).
. Each QueueKeeper gets registered by the QueueKeeperHarvester. The Harvester runs upon one thread; iterates through all the registered QueueKeepers; and polls them. The polled message is then queued into the QueueProcessor. +
If all the registered queueKeepers are empty, the harverster hibernates.
[start=5]
. At the QueueProcessor are several threads translating messages from OFJava-API models to MD-SAL models (preserving order). The QueueProcessor uses two threadPools:
** One threadPool to process the queue items
** Another threadPool (containing one thread) to publish messages to the MD-SAL +

A queue gets filled for different reasons: +

* The MD-SAL is overloaded.
* A node is flooding, or something has generally slowed down the processing pipeline. +
If the queue in the QueueProcessor is full, it blocks the harvester. If the harvester is blocked, the queues in the QueueKeeper will not be emptied.

NOTE: The current implementation of the feature offers no checking of the memory or CPU load to actively throttle messages.

.Overload protection

image::overloadProtectionBrief.png[width=500]

==== Effects of overload protection

* When a node floods the controller, it will not block messages from other nodes.
* The processing of messages is fair: 'Floody' node messages are neither prioritized, nor do they infest queues outside the ConnectionConductor.
* Memory is not exhausted on the controller side as messages gets dropped immediately upon an unsuccessful push to the local queue.
* The functionality cannot create back pressure at the netty level. Pressure affects the echo message, and might cause a connection close action on the switch side.
