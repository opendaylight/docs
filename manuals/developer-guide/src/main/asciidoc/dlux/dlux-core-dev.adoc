== DLUX
=== Setup and Run
==== Required Technology Stack

*  NodeJS (Http Server, http://www.nodejs.org )
*  Bower (JavaScript Package Manager, http://bower.io )
*  GruntJS (JavaScript Task Runner, http://gruntjs.com )
*  AngularJS (JavaScript client-side framework, http://www.angularjs.org )
*  Karma (JavaScript Test Runner, http://karma-runner.github.io/ )
*  Other AngularJS/Third-party JS libraries


==== Get latest DLUX code from git

.Anonymous clone

 $ git clone https://git.opendaylight.org/gerrit/dlux

.If you have a opendaylight.org account

 $ git clone ssh://<username>@git.opendaylight.org:29418/dlux.git


==== Build DLUX

All necessary modules mentioned above such as nodesjs, bower etc. will be installed automatically, when you run the dlux build for first time.
Run following command at dlux home directory /dlux to build dlux feature and distribution along with code. Once successful, It will make dlux
feature available to install and also create dlux karaf distribution. You can find karaf distribution at dlux/distribution-dlux.

 $ mvn clean install

TIP: If you see node or npm related errors, uninstall the existing node and try to manually install node before trying maven build.

===== Install NodeJS if needed

====== For Windows and Mac without brew:

. Go to http://www.nodejs.org
. Download and install NodeJS

====== For Mac with brew installed:

 $ brew update
 $ brew install node

====== Verify NodeJS is installed:

 $ npm --version

==== Enable DLUX Karaf Feature
Once you have dlux distribution or you have karaf distribution from integration repository. You can turn on the dlux feature to access the UI.
We will take example of dlux distribution here. Navigate to directory dlux/distribution-dlux/target/assembly/bin and start the karaf
via following command -

 $ ./karaf

On the karaf shell, install dlux core feature via running following command -

 feature:install odl-dlux-core

It will internally install odl-restconf and dlux topology application along with core dlux components. once this feature is successfully installed.
Access the dlux UI at http://localhost:8181/index.html. Default credentials are admin/admin for login.

All the applications in dlux are now karaf features. You can install other dlux applications such as nodes, yang-ui from karaf
console using commands such as -

----
 $ feature:install odl-dlux-node

 $ feature:install odl-dlux-yangui
----

=== DLUX Modules

DLUX modules are the individual features such as nodes, topology etc. Each module has a defined structure and you can find all existing modules under
/dlux/modules directory of code.

==== Module Structure

 * module_folder
 ** <module_name>.module.js
 ** <module_name>.controller.js
 ** <module_name>.services.js
 ** <module_name>.directives.js
 ** <module_name>.filter.js
 ** index.tpl.html
 ** <a_stylesheet>.css

==== Create New Module
===== Define the module

First, create an empty file with the module name.
Next, we need to surround our module with a define function. This allows RequireJs to see our module.js files. The first argument is an array who contain all the module dependencies. The second is a callback function whose body contain the AngularJs code base. The function parameters correspond with the order of dependencies. Each dependences is injected into a parameter if it is provided. Finally, we return the angular module to be able to inject it as a parameter in our others modules.

For each new module, you must have at least those two dependencies :

* angularAMD : It's a wrapper arround angularjs to provide an AMD (Asynchronous Module Definition) support. Which is used by RequireJs. For more information click https://github.com/amdjs/amdjs-api/blob/master/AMD.md[here].
* app/core/core.services : This one is mandatory if you want to add content in the navigation menu, the left bar or the top bar.

The following are not mandatory, but very often used.

* angular-ui-router : A library to provide URL routing
* routingConfig : To set the level access to a page


 define(['angularAMD','app/routingConfig', 'angular-ui-router','app/core/core.services'], function(ng) {
    var module = angular.module('app.a_module', ['ui.router.state', 'app.core']);
    // module configuration
    module.config(function() {
        [...]
    });
   return module;
 });


===== Set the register function
If your module is only required by the main application, you will need register your angular components because the app will be already bootstrapped. Otherwise, it won't see your components on the runtime.

TIP: If your module is only use by an other module, you don't have to do this step.

 module.config(function($compileProvider, $controllerProvider, $provide) {
    module.register = {
      controller : $controllerProvider.register,
      directive : $compileProvider.directive,
      factory : $provide.factory,
      service : $provide.service
    };


===== Set the route
The next step is to set up the route for our module. This part is also done in the configuration method of the module. We have to add *$stateProvider* as a parameter.

 module.config(function($stateProvider) {
    var access = routingConfig.accessLevels;
    $stateProvider.state('main.module', {
      url: 'module',
      views : {
        'content' : {
          templateUrl: 'src/app/module/module.tpl.html',
          controller: 'ModuleCtrl'
        }
      }
    });
 });


===== Adding element to the navigation menu
To be able to add item to the navigation menu, the module requires the *NavHelperProvider* parameter in the configuration method. This helper has a method to easily add an item to the menu. The first parameter is an id that refers to the level of your menu and the second is a object.

 var module = angular.module('app.a_module', ['app.core']);
 module.config(function(NavMenuHelper) {
     NavMenuHelper.addToMenu('myFirstModule', {
         "link" : "#/module/index",
         "active" : "module",
         "title" : "My First Module",
         "icon" : "icon-sitemap",
         "page" : {
             "title" : "My First Module",
             "description" : "My first module"
         }
     });
  });

The ID parameter supports, for now, two levels of depth. So if your ID looks like 'rootNode.childNode', the helper will look for a node named 'rootNode' and it will append the 'childNode' to it. If the root node doesn't exist, it will create it.


===== Link the controller file

To include the controller file, we will use the NavHelperProvider. It contain a method who will load the given file.

 [...]
    NavHelperProvider.addControllerUrl('<path_to_module_folder>/<module_name>.controller');

The module.js file is now complete.


==== Create the Controllers, factory, directive, etc

Creating the controller and other components are similar to the module.

* First, add the define method
* Second, add the relative path to the module definition
* Last, create your methods as you usually do it with angularJs

 define(['<relative_path_to_module>/<module_name>.module'], function(module) {
    module.register.controller('ModuleCtrl', function($rootScope, $scope) {
    });
 });

=== Add new application using dlux modularity
Dlux works as a karaf based UI platform, where you can create a new karaf feature of your UI component and install that UI applications in dlux using blueprint.
This page will help you to create and load a new application for dlux. You don't have to add new module in dlux repository.

==== Add a new OSGi blueprint bundle
The OSGi Blueprint Container specification allows us to use dependency injection in our OSGi environment. Each dlux application module registers itself via blueprint configuration. Each application will have its own blueprint.xml to place its configuration.

1. Create a maven project to place blueprint configuration. For reference, take a look at topology bundle, present under dlux/bundles/topology. All the existing dlux modules's configurations are available under bundles directory of dlux code.

2. In pom.xml, you have to add a maven plugin to unpack your module code under generated-resources of this project. For reference, you can check pom.xml of "dlux/bundles/topology" project. your bundle will eventually gets deployed in karaf as feature, so your bundle should contain all your module code. If you want to combine module and bundle project, that should not an issue either.

3. Create a blueprint.xml configuration file under src/main/resources/OSGI-INF/blueprint. Below is the content of the blueprint.xml taken from topology bundles's blueprint.xml. any new application should create a blueprint.xml in following format -

----
<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0">
	<reference id="httpService" availability="mandatory" activation="eager" interface="org.osgi.service.http.HttpService"/>
    <reference id="loader" availability="mandatory" activation="eager" interface="org.opendaylight.dlux.loader.DluxModuleLoader"/>

    <bean id="bundle" init-method="initialize" destroy-method="clean" class="org.opendaylight.dlux.loader.DluxModule">
      <property name="httpService" ref="httpService"/>
      <property name="loader" ref="loader"/>
      <property name="moduleName" value="topology "/>
      <property name="url" value="/src/app/topology"/>
      <property name="directory" value="/topology"/>
      <property name="requireJs" value="app/topology/topology.module"/>
      <property name="angularJs" value="app.topology"/>
    </bean>
</blueprint>
----

In above configuration, there are two references with id httpService and loader. These two beans will already be initialized by dlux-core, so any new application can use them. Without these two bean references, a new application will not be able to register.

Next is the initialization of your application bean, which will be an instance of class org.opendaylight.dlux.loader.DluxModule. There are 5 properties that you should provide in this bean besides the references of httpService and loader. Lets talk about those bean properties in little more detail.

*moduleName* : Name of your module. This name should be unique in dlux.

*url*: This is the url via which requireJS in dlux will try to load your module js/html files. Also, this is the url that browser will use to load the static html, js or css files. requireJS in dlux has a base path of "src", so all the url should start with /src so requireJS and browser can correctly reach to the file name.

*directory*: In your bundle's pom.xml, you unpack your module code. This is the directory where your actual static files will resides. Above mentioned url is registered with httpService, so when browser makes a call to that url, it will be redirected to the directory mentioned here. So, in above example, all the topology files are present under /topology directory and browser/requireJS can access those files with uri /src/app/topology.

*requireJS*: This is the path to your requireJS module. If you notice closely, you will see the initial path of requireJS app/topology in above example matches with the last part of url. this path will be be used by requireJS. As mentioned above, we have kept "src" as base path in requireJS, that is the exact reason url start with /src.

*angularJS*: name of your angularJS module.

OSGi understands blueprint.xml, once you will deploy your bundle in karaf (or you can create a new feature for your application), karaf will read your blueprint.xml and it will try to register your application with dlux. Once successful, if you refresh your dlux UI, you will see your application in left hand navigation bar of dlux.


=== Yang Utils
Yang Utils are used by yang UI to perform all CRUD operations. All of these utilities are present in yangutils.services.js file. It has following factories -

.Factories
* *arrayUtils* – defines functions for working with arrays.
* *pathUtils* – defines functions for working with xpath (paths to APIs and subAPIs). It divides xpath string to array of elements, so this array can be later used for search functions.
* *syncFact* – provides synchronization between requests to and from ODL when it’s needed.
* *custFunct* – it is linked with apiConnector.createCustomFunctionalityApis in yangui controller in yangui.controller.js. That function makes it possible to create some custom function called by the click on button in index.tpl.html. All custom functions are stored in array and linked to specific subAPI. When particular subAPI is expanded and clicked, its  inputs (linked root node with its child nodes) are displayed in the bottom part of the page and its buttons with custom functionality are displayed also.
* *reqBuilder* – creates object builder = request built from filled inputs on page in JSON format. It is possible with “show preview” button. This request is sent to ODL when button PUT or POST is clicked.
* *yinParser* – factory for reading of .xml files of yang models and creating objects hierarchy. Every statement from yang is represented by node.
* *nodeWrapper* – adds functions to objects in tree hierarchy created with yinParser. These functions provide functionality for every type of node.
* *apiConnector* – the main functionality is filling the main structures and linking them. Structure of APIs and subAPIs which is two level array - first level is filled by main APIs, second level is filled by others sub APIs. Second main structure is array of root nodes, which are objects including root node and its children nodes. Linking these two structures is creating links between every subAPI (second level of APIs array) and its root node, which must be displayed like inputs when subAPI is expanded.
* *yangUtils* – some top level functions which are used by yangui controller for creating the main structures.
