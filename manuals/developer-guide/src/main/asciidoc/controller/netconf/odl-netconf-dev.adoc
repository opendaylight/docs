== NETCONF Developer guide

*Reading user guide for netconf is adviced as it contains an overview
of NETCONF in ODL and a how-to for spawning and configuring netconf
connectors.*

=== Southbound (netconf-connector) for app developers

This chapter is recommended for application developers who need to
interact with mounted netconf devices from their application code. It
tries to demonstrate all the use cases from user guide with
RESTCONF but now from the code level. One important difference would
be the demonstration of netconf notifications and notification
listeners. The notifications were not shown using RESTCONF becaus
*RESTCONF does not support notifications from mounted NETCONF
devices.*

*Reading the generic ODL app development
tutorial is recommended before diving into this chapter:
https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:MD-SAL_App_Tutorial.
This guide assumes awerness of basic ODL app development concept*

==== Sample app
All the examples presented here are implemented by a sample ODL
application called *ncmount*. It can be found on github:

* https://github.com/opendaylight/coretutorials/tree/master/ncmount

or checked out from the official ODL repository:

* https://git.opendaylight.org/gerrit/#/admin/projects/coretutorials



*The application was built using ODL's maven archetype and
demonstrates how to:*

* preconfigure connectors to netconf devices
* retrieve MountPointService (registry of available mount points)
* listen and react to changing connection state of netconf-connector
* add custom device YANG models to the APP and work with them
* read data from device in binding aware format (generated java APIs
  from provided YANG models)
* write data into device in BA format
* trigger and listen to netconf notifications in BA format

Detailed information about the structure of the application can be
found at:
https://wiki.opendaylight.org/view/Controller_Core_Functionality_Tutorials:Tutorials:Netconf_Mount
// TODO Migrate the information from wiki here

NOTE: Code in ncmount is fully *Binding aware* (works with generated
java APIs from provided YANG models). However it is also possible to
perform the same operations in *Binding independent* manner.
// TODO Add BI NcmountProvider version into the sample app and link it from here

==== NcmountProvider.java
NcmountProvider.java class is the central point of ncmount application
as all the logic is contained there. The next chapters will detail its
most interesting pieces

===== Retrieve MountPointService
MountPointService is a central registry of all available mount points
in ODL. It is just another MD-SAL service and is available from the
+session+ attribute passed by +onSessionInitiated+ callback:

----
    @Override
    public void onSessionInitiated(ProviderContext session) {
        LOG.info("NcmountProvider Session Initiated");

        // Get references to the data broker and mount service
        this.mountService = session.getSALService(MountPointService.class);

        ...

        }
    }
----

===== Listen for connection state changes
It is important to know when a mount point appears, when its fully
connected and when its disconnected or removed. The exact states of a
mount poit are:

* Connected
* Connecting
* Unable to connect

To receive this kind of information, application has to register
itself as a notification listener for the preconfigured
netconf-topology subtree in MD-SAL's datastore. This can be performed
in the +onSessionInitiated+ callback as well:

----
    @Override
    public void onSessionInitiated(ProviderContext session) {

        ...

        this.dataBroker = session.getSALService(DataBroker.class);

        // Register ourselves as the REST API RPC implementation
        this.rpcReg = session.addRpcImplementation(NcmountService.class, this);

        // Register ourselves as data change listener for changes on Netconf
        // nodes. Netconf nodes are accessed via "Netconf Topology" - a special
        // topology that is created by the system infrastructure. It contains
        // all Netconf nodes the Netconf connector knows about. NETCONF_TOPO_IID
        // is equivalent to the following URL:
        // .../restconf/operational/network-topology:network-topology/topology/topology-netconf
        if (dataBroker != null) {
            this.dclReg = dataBroker.registerDataChangeListener(LogicalDatastoreType.OPERATIONAL,
                    NETCONF_TOPO_IID.child(Node.class),
                    this,
                    DataChangeScope.SUBTREE);
        }
    }
----

Implementation of the callback from MD-SAL when the data change can be
found in the
+onDataChanged(AsyncDataChangeEvent<InstanceIdentifier<?>, DataObject>
change)+ callback of
https://github.com/opendaylight/coretutorials/blob/master/ncmount/impl/src/main/java/ncmount/impl/NcmountProvider.java[NcmountProvider
class].

===== Reading data from the device
First step when trying to interact with the device is to get the exact
mount point instance (identified by an instance identifier) from the MountPointService:

----
    @Override
    public Future<RpcResult<ShowNodeOutput>> showNode(ShowNodeInput input) {
        LOG.info("showNode called, input {}", input);

        // Get the mount point for the specified node
        // Equivalent to '.../restconf/<config | operational>/opendaylight-inventory:nodes/node/<node-name>/yang-ext:mount/'
        // Note that we can read both config and operational data from the same
        // mount point
        final Optional<MountPoint> xrNodeOptional = mountService.getMountPoint(NETCONF_TOPO_IID
                .child(Node.class, new NodeKey(new NodeId(input.getNodeName()))));

        Preconditions.checkArgument(xrNodeOptional.isPresent(),
                "Unable to locate mountpoint: %s, not mounted yet or not configured",
                input.getNodeName());
        final MountPoint xrNode = xrNodeOptional.get();

        ....
    }
----

NOTE: Triggerring method in this case is called +showNode+. It is a
YANG defined RPC and NcmountProvider serves as an MD-SAL RPC
implementation among other things. It means that +showNode+ an be
trigerred using RESTCONF.

The next step is to retrieve an instance +DataBroker+ API from the
mount point and start a read transaction:

----
    @Override
    public Future<RpcResult<ShowNodeOutput>> showNode(ShowNodeInput input) {

        ...

        // Get the DataBroker for the mounted node
        final DataBroker xrNodeBroker = xrNode.getService(DataBroker.class).get();
        // Start a new read only transaction that we will use to read data
        // from the device
        final ReadOnlyTransaction xrNodeReadTx = xrNodeBroker.newReadOnlyTransaction();

        ...
    }
----

Finally, it is possible to perform the read operation:

----
    @Override
    public Future<RpcResult<ShowNodeOutput>> showNode(ShowNodeInput input) {

        ...

        InstanceIdentifier<InterfaceConfigurations> iid =
                InstanceIdentifier.create(InterfaceConfigurations.class);

        Optional<InterfaceConfigurations> ifConfig;
        try {
            // Read from a transaction is asynchronous, but a simple
            // get/checkedGet makes the call synchronous
            ifConfig = xrNodeReadTx.read(LogicalDatastoreType.CONFIGURATION, iid).checkedGet();
        } catch (ReadFailedException e) {
            throw new IllegalStateException("Unexpected error reading data from " + input.getNodeName(), e);
        }

        ...
    }
----

Instance identifier is here used again to specify a subtree to read
from device. At this point application can process the data as it sees
fit. Ncmount app transforms the data into its own format and returns
it from +showNode+.

===== Writing data to the device
aaa
