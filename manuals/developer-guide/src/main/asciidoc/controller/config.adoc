=== OpenDaylight Controller Configuration: Java Code Generator

==== YANG to Java code generator

The Java code for the configuration system is generated by the yang-maven-plugin and the yang-jmx-generator-plugin.
The input Yang module files are converted to java files by the definition of the module and the specified templates. the generated java code can represent interfaces, classes, or abstract classes used for configuration.

===== Service interfaces generating

Service interfaces (SI) are generated from YANG "service-types". Each SI must be defined as "identity" with a "base" statement set to "config:service-type", or another SI. This is because a service must have a globally unique name.
 Each SI must be annotated with @ServiceInterfaceAnnotation, and must extend AbstractServiceInterface.

*Sample YANG module representing service interface* +

----
module config-test {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:test";
    prefix "test";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "Testing API";

    revision "2013-06-13" {
        description
            "Initial revision";
    }

    identity testing {
        description
            "Test api";

        base "config:service-type";
        config:java-class "java.lang.AutoCloseable";
    }
}
----
The "description" node of identity is generated as javadoc in the service interface. +
The "config:java-class" is generated as *ServiceInterfaceAnnotation*. It specifies java classes or interfaces in the "osgiRegistrationTypes" parameter. The module implementing this service interface must instantiate a java object that can be cast to any of the java types defined in "osgiRegistrationTypes".

*Generated java source file: AutoCloseableServiceInterface* +
----
package %prefix%.test;

/**
* Test api
*/
@org.opendaylight.controller.config.api.annotations.Description(value = "Test api")
@org.opendaylight.controller.config.api.annotations.ServiceInterfaceAnnotation(value = "testing", osgiRegistrationType = java.lang.AutoCloseable.class)
public interface AutoCloseableServiceInterface extends org.opendaylight.controller.config.api.annotations.AbstractServiceInterface
{

}
----

====== Module stubs generating

Modules are constructed during configuration transaction. A module implements the ModuleMXBean interface. The ModuleMXBean interface represents getters and setters for attributes that will be exposed to the configuration registry by means of JMX. Attributes can either be simple types, or composite types.

Each ModuleMXBean must be defined in yang as "identity" with the base statement set to "config:module-type". Not only are ModuleMXBeans generated, but also ModuleFactory and Module stubs. Both are first generated as abstract classes with almost full functionality. Then their implementations, which are allowed to be modified by users, are generated, but only once.

===== Runtime beans generating

Runtime JMX beans are purposed to be the auditors: they capture data about running module instances. A module can have zero or more runtime beans. Runtime beans are hierarchically ordered, and each must be uniquely identified.
 A runtime bean is defined as a configuration augment of a module, from which interface RuntimeMXBean, RuntimeRegistrator, and RuntimeRegistretion are generated. Augment definition contains arguments representing the data of a module that must be watched.

===== RPCs

Method calls in yang must be specified as top level elements. The context, where an RPC operation exits, must be defined in the RPC definition itself, and in the runtime bean that provides method implementation.


===== OpenDaylight Controller: Configuration
The Controller configuration operation has three stages:

* First, a Proposed configuration is created. Its target is to replace the old configuration.
* Second, the Proposed configuration is validated, and then committed. If it passes validation successfully, the Proposed configuration state will be changed to Validated.
* Finally, a Validated configuration can be Committed, and the affected modules can be reconfigured.

In fact, each configuration operation is wrapped in a transaction. Once a transaction is created, it can be configured, that is to say, a user can abort the transaction during this stage. After the transaction configuration is done, it is committed to the validation stage. In this stage, the validation procedures are invoked.
 If one or more validations fail, the transaction can be reconfigured. Upon success, the second phase commit is invoked.
 If this commit is successful, the transaction enters the last stage, committed. After that, the desired modules are reconfigured. If the second phase commit fails, it means that the transaction is unhealthy - basically, a new configuration instance creation failed, and the application can be in an inconsistent state.

.Configuration states
image::configuration.jpg[width=500]

.Transaction states
image::Transaction.jpg[width=500]

==== Validation
To secure the consistency and safety of the new configuration and to avoid conflicts, the configuration validation process is necessary.
Usually, validation checks the input parameters of a new configuration, and mostly verifies module-specific relationships.
The validation procedure results in a decision on whether the proposed configuration is healthy.

==== Dependency resolver
Since there can be dependencies between modules, a change in a module configuration can affect the state of other modules. Therefore, we need to verify whether dependencies on other modules can be resolved.
The Dependency Resolver acts in a manner similar to dependency injectors. Basically, a dependency tree is built.

==== APIs and SPIs
This section describes configuration system APIs and SPIs.


===== SPIs
*Module* org.opendaylight.controller.config.spi. Module is the common interface for all modules: every module must implement it. The module is designated to hold configuration attributes, validate them, and create instances of service based on the attributes.
This instance must implement the AutoCloseable interface, owing to resources clean up. If the module was created from an already running instance, it contains an old instance of the module. A module can implement multiple services. If the module depends on other modules, setters need to be annotated with @RequireInterface.

*Module creation*

. The module needs to be configured, set with all required attributes.
. The module is then moved to the commit stage for validation. If the validation fails, the module attributes can be reconfigured. Otherwise, a new instance is either created, or an old instance is reconfigured.
A module instance is identified by ModuleIdentifier, consisting of the factory name and instance name.

*ModuleFactory* org.opendaylight.controller.config.spi. The ModuleFactory interface must be implemented by each module factory. +
A module factory can create a new module instance in two ways: +

* From an existing module instance
* An entirely new instance +
ModuleFactory can also return default modules, useful for populating registry with already existing configurations.
A module factory implementation must have a globally unique name.

===== APIs

|===
| ConfigRegistry | Represents functionality provided by a configuration transaction (create, destroy module, validate, or abort transaction).
| ConfigTransactionController | Represents functionality for manipulating with configuration transactions (begin, commit config).
| RuntimeBeanRegistratorAwareConfiBean | The module implementing this interface will receive RuntimeBeanRegistrator before getInstance is invoked.
|===

===== Runtime APIs

|===
| RuntimeBean | Common interface for all runtime beans
| RootRuntimeBeanRegistrator | Represents functionality for root runtime bean registration, which subsequently allows hierarchical registrations
| HierarchicalRuntimeBeanRegistration | Represents functionality for runtime bean registration and unreregistration from hierarchy
|===

===== JMX APIs

JMX API is purposed as a transition between the Client API and the JMX platform. +

|===
| ConfigTransactionControllerMXBean | Extends ConfigTransactionController, executed by Jolokia clients on configuration transaction.
| ConfigRegistryMXBean | Represents entry point of configuration management for MXBeans.
| Object names | Object Name is the pattern used in JMX to locate JMX beans. It consists of domain and key properties (at least one key-value pair). Domain is defined as "org.opendaylight.controller". The only mandatory property is "type".
|===

===== Use case scenarios

A few samples of successful and unsuccessful transaction scenarios follow: +

*Successful commit scenario*

. The user creates a transaction calling creteTransaction() method on ConfigRegistry.
. ConfigRegisty creates a transaction controller, and registers the transaction as a new bean.
. Runtime configurations are copied to the transaction. The user can create modules and set their attributes.
. The configuration transaction is to be committed.
. The validation process is performed.
. After successful validation, the second phase commit begins.
. Modules proposed to be destroyed are destroyed, and their service instances are closed.
. Runtime beans are set to registrator.
. The transaction controller invokes the method getInstance on each module.
. The transaction is committed, and resources are either closed or released.

*Validation failure scenario* +
The transaction is the same as the previous case until the validation process. +

. If validation fails, (that is to day, illegal input attributes values or dependency resolver failure), the validationException is thrown and exposed to the user.
. The user can decide to reconfigure the transaction and commit again, or abort the current transaction.
. On aborted transactions, TransactionController and JMXRegistrator are properly closed.
. Unregistration event is sent to ConfigRegistry.

===== Default module instances
The configuration subsystem provides a way for modules to create default instances. A default instance is an instance of a module, that is created at the module bundle start-up (module becomes visible for
configuration subsystem, for example, its bundle is activated in the OSGi environment). By default, no default instances are produced.

The default instance does not differ from instances created later in the module life-cycle. The only difference is that the configuration for the default instance cannot be provided by the configuration subsystem.
The module has to acquire the configuration for these instances on its own. It can be acquired from, for example, environment variables.
After the creation of a default instance, it acts as a regular instance and fully participates in the configuration subsystem (It can be reconfigured or deleted in following transactions.).

=== OpenDaylight Controller configuration: Initial
The Initial configuration of the controller involves two methods.

=== Initial configuration for controller
The two ways of configuring the controller: +

* Using the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:config.ini[config.ini] property file to pass configuration properties to the OSGi bundles besides the config subsystem.
* Using the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Configuration:Initial#Configuration_Persister[configuration persister] to push the initial configuration for modules managed by the config subsystem.

==== Using the config.ini property file

The config.ini property file can be used to provide a set of properties for any OSGi bundle deployed to the controller. It is usually used to configure bundles that are not managed by the config subsystem. For details, see <<_opendaylight_controller_configuration_config_ini>>.

==== Using configuration persister

Configuration persister is a default service in the controller, and is started automatically using the OSGi Activator. Its purpose is to load the initial configuration for the config subsystem and store a snapshot for every new configuration state pushed to the config-subsystem from external clients.
For details, see <<_opendaylight_controller_configuration_persister>>.

=== OpenDaylight Controller configuration: config.ini

Various parts of the system that are not under the configuration subsystem use the file config.ini. Changes to this file apply after a server restart. The tabulation of several important configuration keys and values follows:

[cols="2*", width="75%"]
|===

|Setting | Description
| yangstore.blacklist=.\*controller.model.* | This regular expression (can be OR-ed using pipe character) tells netconf to exclude the yang files found in the matching bundle symbolic name from the hello message. This is helpful when dealing with a netconf client that has parsing problems.
| netconf.config.persister.* settings  | See <<_opendaylight_controller_configuration_initial>>.
| netconf.tcp.address=0.0.0.0 netconf.tcp.port=8383 +

netconf.ssh.address=0.0.0.0 netconf.ssh.port=1830 netconf.ssh.pk.path = ./configuration/RSA.pk +

netconf.tcp.client.address=127.0.0.1 netconf.tcp.client.port=8383 | These settings specify the netconf server bindings. IP address 0.0.0.0 is used when all available network interfaces must be used by the netconf server. When starting the ssh server, the user must provide a private key. The actual authentication is done in the user admin module. By default, users admin:admin and netconf:netconf can be used to connect by means of ssh. Since the ssh bridge acts as a proxy, one needs to specify the netconf plaintext TCP address and port. These settings must normally be identical to those specified by netconf.tcp.* .
|===
=== OpenDaylight Controller: Configuration Persister
One way of configuring the controller is to use the configuration persister to push the initial configuration for modules managed by the config subsystem.

==== Using configuration persister

The configuration persister is a default service in the controller, and is started automatically using the OSGi Activator.
Its purpose: +

* Load the initial configuration for the config subsystem.
* Store a snapshot for every new configuration state pushed to the config-subsystem from external clients. +

It retrieves the base configuration from the config.ini property file, and tries to load the configuration for the config subsystem.
The configuration for the config subsystem is pushed as a set of edit-config netconf rpcs followed by a commit rpc since the config persister acts as a netconf client.

*Configuration persister lifecycle:* +

. Start the config persister service at _config-persister-impl_ bundle startup.
. Retrieve the base configuration of the adapters from the config.ini property file.
. Initialize the backing storage adapters.
. Initialize the netconf client, and connect to the netconf endpoint of the config subsystem.
. Load the initial configuration snapshots from the latest storage adapter.
. Send the edit-config rpc with the initial configuration snapshots.
. Send the commit rpc.
. Listen for any of the following changes to the configuration and persist a snapshot.

*Configuration Persister interactions:* +

.Persister
image::Persister.jpg[width=500]

=== Current configuration for controller distribution

The _config.ini_ property file contains the following configuration for the configuration persister: +
----
netconf.config.persister.active=1,2

netconf.config.persister.1.storageAdapterClass=org.opendaylight.controller.config.persist.storage.directory.autodetect.AutodetectDirectoryStorageAdapter

netconf.config.persister.1.properties.directoryStorage=configuration/initial/

netconf.config.persister.1.readonly=true


netconf.config.persister.2.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.xml.XmlFileStorageAdapter

netconf.config.persister.2.properties.fileStorage=configuration/current/controller.currentconfig.xml

netconf.config.persister.2.properties.numberOfBackups=1
----

With this configuration, the configuration persister initializes two adapters: +

* AutodetectDirectoryStorageAdapter to load the initial configuration files from the _configuration/initial/_ folder. These files will be pushed as the initial configuration for the config subsystem. Since this adapter is Read only, it will not store any configuration snapshot during the controller lifecycle.
* XmlFileStorageAdapter to store snapshots of the current configuration after any change in the file _configuration/current/controller.currentconfig.xml_ (Only 1 snapshot backup is kept; every new change overwrites the previous one). +
The initial configuration in the controller distribution consists of 2 files in the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Configuration:Initial#Persisted_snapshot_format[xml format]. +
* configuration/initial/00-netty.xml: +
----
<snapshot>
    <required-capabilities>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty?module=netty&amp;revision=2013-11-19</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty:eventexecutor?module=netty-event-executor&amp;revision=2013-11-12</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty:threadgroup?module=threadgroup&amp;revision=2013-11-07</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty:timer?module=netty-timer&amp;revision=2013-11-19</capability>
    </required-capabilities>
    <configuration>

        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty:threadgroup">netty:netty-threadgroup-fixed</type>
                    <name>global-boss-group</name>
                </module>
                <module>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty:threadgroup">netty:netty-threadgroup-fixed</type>
                    <name>global-worker-group</name>
                </module>
                <module>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty:timer">netty:netty-hashed-wheel-timer</type>
                    <name>global-timer</name>
                </module>
                <module>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty:eventexecutor">netty:netty-global-event-executor</type>
                    <name>global-event-executor</name>
                </module>
            </modules>

            <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <service>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-threadgroup</type>
                    <instance>
                        <name>global-boss-group</name>
                        <provider>/modules/module[type='netty-threadgroup-fixed'][name='global-boss-group']</provider>
                    </instance>
                    <instance>
                        <name>global-worker-group</name>
                        <provider>/modules/module[type='netty-threadgroup-fixed'][name='global-worker-group']</provider>
                    </instance>
                </service>
                <service>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-event-executor</type>
                    <instance>
                        <name>global-event-executor</name>
                        <provider>/modules/module[type='netty-global-event-executor'][name='global-event-executor']</provider>
                    </instance>
                </service>
                <service>
                    <type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-timer</type>
                    <instance>
                        <name>global-timer</name>
                        <provider>/modules/module[type='netty-hashed-wheel-timer'][name='global-timer']</provider>
                    </instance>
                </service>
            </services>
        </data>

    </configuration>
</snapshot>
----
This configuration snapshot instantiates netty utilities, which will be utilized by the controller components that use netty internally. +

*configuration/initial/01-md-sal.xml:* +
----
<snapshot>

    <configuration>

        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl">prefix:schema-service-singleton</type>
                    <name>yang-schema-service</name>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl">prefix:hash-map-data-store</type>
                    <name>hash-map-data-store</name>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl">prefix:dom-broker-impl</type>
                    <name>dom-broker</name>
                    <data-store xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl">
                        <type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:dom-data-store</type>
                        <!-- to switch to the clustered data store, comment out the hash-map-data-store <name> and uncomment the cluster-data-store one -->
                        <name>hash-map-data-store</name>
                        <!-- <name>cluster-data-store</name> -->
                    </data-store>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-broker-impl</type>
                    <name>binding-broker-impl</name>
                    <notification-service xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">
                        <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-notification-service</type>
                        <name>binding-notification-broker</name>
                    </notification-service>
                    <data-broker xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">
                        <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
                        <name>binding-data-broker</name>
                    </data-broker>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:runtime-generated-mapping</type>
                    <name>runtime-mapping-singleton</name>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-notification-broker</type>
                    <name>binding-notification-broker</name>
                </module>
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-data-broker</type>
                    <name>binding-data-broker</name>
                    <dom-broker xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">
                        <type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:dom-broker-osgi-registry</type>
                        <name>dom-broker</name>
                    </dom-broker>
                    <mapping-service xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">
                        <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">binding:binding-dom-mapping-service</type>
                        <name>runtime-mapping-singleton</name>
                    </mapping-service>
                </module>

            </modules>

            <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                	<service>
				<type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:schema-service</type>
				<instance>
					<name>yang-schema-service</name>
					<provider>/modules/module[type='schema-service-singleton'][name='yang-schema-service']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-notification-service</type>
				<instance>
					<name>binding-notification-broker</name>
					<provider>/modules/module[type='binding-notification-broker'][name='binding-notification-broker']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:dom-data-store</type>
				<instance>
					<name>hash-map-data-store</name>
					<provider>/modules/module[type='hash-map-data-store'][name='hash-map-data-store']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-broker-osgi-registry</type>
				<instance>
					<name>binding-osgi-broker</name>
					<provider>/modules/module[type='binding-broker-impl'][name='binding-broker-impl']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
				<instance>
					<name>binding-rpc-broker</name>
					<provider>/modules/module[type='binding-broker-impl'][name='binding-broker-impl']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding-impl="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">binding-impl:binding-dom-mapping-service</type>
				<instance>
					<name>runtime-mapping-singleton</name>
					<provider>/modules/module[type='runtime-generated-mapping'][name='runtime-mapping-singleton']</provider>
				</instance>
			</service>
			<service>
			<type xmlns:dom="urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom">dom:dom-broker-osgi-registry</type>
				<instance>
					<name>dom-broker</name>
					<provider>/modules/module[type='dom-broker-impl'][name='dom-broker']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
				<instance>
					<name>binding-data-broker</name>
					<provider>/modules/module[type='binding-data-broker'][name='binding-data-broker']</provider>
				</instance>
			</service>

            </services>
        </data>

    </configuration>

    <required-capabilities>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty:eventexecutor?module=netty-event-executor&amp;revision=2013-11-12</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:threadpool?module=threadpool&amp;revision=2013-04-09</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding?module=opendaylight-md-sal-binding&amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom?module=opendaylight-md-sal-dom&amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl?module=opendaylight-sal-binding-broker-impl&amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:dom:impl?module=opendaylight-sal-dom-broker-impl&amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:common?module=opendaylight-md-sal-common&amp;revision=2013-10-28</capability>
    </required-capabilities>

</snapshot>
----
This configuration snapshot instantiates md-sal modules.

After the controller is started, all these modules will be instantiated and configured. They can be further referenced from the new modules as dependencies, reconfigured, or even deleted.
These modules are considered to be the base configuration for the controller and the purpose of them being configured automatically is to simplify the process of controller configuration for users, since the base modules will already be ready for use.

=== Adding custom initial configuration

There are multiple ways to add the custom initial confguration to the controller distribution:

. Manually create the config file, and put it in the initial configuration folder.
. Reconfigure the running controller using the yuma yangcli tool. The XmlFileStorageAdapter adapter will store the current snapshot, and on the next startup of the controller (assuming it was not rebuilt since), it will load the configuration containing the changes.

==== Custom initial configuration in bgpcep distribution

The BGPCEP project will serve as an example for adding the custom initial configuration. The bgpcep project contains the custom initial configuration that is based on the initial configuration from the controller. It adds new modules, which depend on MD-SAL and netty modules created with the initial config files of the controller. There are multiple config files in the bgpcep project. Only the 30-programming.xml file located under the programming-parent/controller-config project will be described in this section. This file contains the configuration for an instance of the instruction-scheduler module:

----
<?xml version="1.0" encoding="UTF-8"?>
<!-- vi: set et smarttab sw=4 tabstop=4: -->
<!--
      Copyright (c) 2013 Cisco Systems, Inc. and others.  All rights reserved.

 This program and the accompanying materials are made available under the
 terms of the Eclipse Public License v1.0 which accompanies this distribution,
 and is available at http://www.eclipse.org/legal/epl-v10.html.
-->
<snapshot>
	<required-capabilities>
		<capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding?module=opendaylight-md-sal-binding&amp;revision=2013-10-28</capability>
		<capability>urn:opendaylight:params:xml:ns:yang:controller:netty?module=netty&amp;revision=2013-11-19</capability>
		<capability>urn:opendaylight:params:xml:ns:yang:controller:programming:impl?module=config-programming-impl&amp;revision=2013-11-15</capability>
		<capability>urn:opendaylight:params:xml:ns:yang:controller:programming:spi?module=config-programming-spi&amp;revision=2013-11-15</capability>
	</required-capabilities>
	<configuration>

		<data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
			<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
				<module>
					<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:programming:impl">prefix:instruction-scheduler-impl</type>
					<name>global-instruction-scheduler</name>
					<data-provider>
						<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
						<name>binding-data-broker</name>
					</data-provider>
					<notification-service>
						<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-notification-service</type>
						<name>binding-notification-broker</name>
					</notification-service>
					<rpc-registry>
						<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
						<name>binding-rpc-broker</name>
					</rpc-registry>
					<timer>
						<type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-timer</type>
						<name>global-timer</name>
					</timer>
				</module>
			</modules>

			<services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
				<service>
					<type xmlns:pgmspi="urn:opendaylight:params:xml:ns:yang:controller:programming:spi">pgmspi:instruction-scheduler</type>
					<instance>
						<name>global-instruction-scheduler</name>
						<provider>/modules/module[type='instruction-scheduler-impl'][name='global-instruction-scheduler']</provider>
					</instance>
				</service>
			</services>
		</data>

	</configuration>
</snapshot>
----
Instruction-scheduler is instantiated as a module of type _instruction-scheduler-impl_ with the name *global-instruction-scheduler:* +
----
<module>
       <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:programming:impl">prefix:instruction-scheduler-impl</type>
       <name>global-instruction-scheduler</name>
       ...
----
There is also an alias created for this module instancfe, and the alias is *global-instruction-scheduler* of type _instruction-scheduler_: +
----
...
<service>
	<type xmlns:pgmspi="urn:opendaylight:params:xml:ns:yang:controller:programming:spi">pgmspi:instruction-scheduler</type>
	<instance>
		<name>global-instruction-scheduler</name>
		<provider>/modules/module[type='instruction-scheduler-impl'][name='global-instruction-scheduler']</provider>
	</instance>
</service>
...
----
The type of the alias is instruction-scheduler. This type refers to a certain service that is implemented by the instruction-scheduler-impl module. With this service type, the global-instruction-scheduler instance can be injected into any other module that requires instruction-scheduler as a dependency.
One module can provide (implement) multiple services, and each of these services can be assigned an alias. This alias can be later used to reference the implementation it is pointing to.
If no alias is assigned by the user, a default alias will be assigned for each provided service.
The default alias is constructed from the name of the module instance with a prefix *ref_* and a possible suffix containing a number to resolve name clashes.
It is recommended that users provide aliases for each service of every module instance, and use these aliases for dependency injection. References to the alias global-instruction-scheduler can be found in subsequent config files in the bgpcep project for example, _32-pcep.xml_ located under the _pcep-parent/pcep-controller-config_ project.

The configuration contains four dependencies on the MD-SAL and the netty modules: +
----
...
<data-provider>
	<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
	<name>binding-data-broker</name>
</data-provider>
<notification-service>
	<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-notification-service</type>
	<name>binding-notification-broker</name>
</notification-service>
<rpc-registry>
	<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
	<name>binding-rpc-broker</name>
</rpc-registry>
<timer>
	<type xmlns:netty="urn:opendaylight:params:xml:ns:yang:controller:netty">netty:netty-timer</type>
	<name>global-timer</name>
</timer>
...
----

MD-SAL dependencies: +

* Data-provider dependency
* Notification-service dependency
* Rpc-registry dependency

All MD-SAL dependencies can be found in the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Configuration:Initial#Current_configuration_for_controller_distribution[MD-SAL initial configuration file]. For example, rpc-registry dependency points to an alias binding-rpc-broker of the type binding-rpc-registry. This alias further points to an instance of the binding-broker-impl named binding-broker-impl.
The Yang module that defines the binding-broker-impl module : https://git.opendaylight.org/gerrit/gitweb?p=controller.git;f=opendaylight/md-sal/sal-binding-broker/src/main/yang/opendaylight-binding-broker-impl.yang;a=blob[opendaylight-binding-broker-impl.yang].

*Netty dependencies:* +

* Timer dependency

This configuration expects these dependencies to be already up and ready. It is the responsibility of the configuration subsystem to find the dependency and inject it.
If the configuration of a module points to a non-existing dependency, the configuration subsystem will produce an exception during the validation phase.
Every user-created configuration needs to point to existing dependencies. In the case of multiple initial configuration files that depend on one another, the resolution order can be ensured by the names of the files. Files are sorted by their names in ascending order. This means that every configuration file will have the visibility of modules from all previous configuration files by means of aliases.

NOTE: The configuration provided by initial config files can also be pushed to the controller at runtime using netconf client. The whole configuration located under the data tag needs to be inserted into the config tag in the edit-config rpc. For more information, see https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Main#Examples[Examples].

==== Configuration Persister

As a part of the configuration subsystem, the purpose of the persister is to save and load a permanent copy of a configuration. The Persister interface represents basic operations over a storage - persist configuration and load last config, configuration snapshot is represented as string and set of it's capabilities. StorageAdapter represents an adapter interface to the ConfigProvider - subset of BundleContext, allowing access to the OSGi framework system properties.

===== Persister implementation

Configuration persister implementation is part of the Controller Netconf. PersisterAggregator class is the implementation of the Presister interface. The functionality is delegated to the storage adapters. Storage adapters are low level persisters that do the heavy lifting for this class. Instances of storage adapters can be injected directly by means of the constructor, or instantiated from a full name of its class provided in a properties file. There can be many persisters configured, and varying numbers of them can be used.

*Example of presisters configuration:* +
----
netconf.config.persister.active=2,3
 # read startup configuration
 netconf.config.persister.1.storageAdapterClass=org.opendaylight.controller.config.persist.storage.directory.xml.XmlDirectoryStorageAdapter
 netconf.config.persister.1.properties.fileStorage=configuration/initial/

 netconf.config.persister.2.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.FileStorageAdapter
 netconf.config.persister.2.readonly=true
 netconf.config.persister.2.properties.fileStorage=configuration/current/controller.config.1.txt

 netconf.config.persister.3.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.FileStorageAdapter
 netconf.config.persister.3.properties.fileStorage=configuration/current/controller.config.2.txt
 netconf.config.persister.3.properties.numberOfBackups=3
----

During server startup, ConfigPersisterNotificationHandler requests the last snapshot from the underlying storages. Each storage can respond by giving a snapshot or an absent response. The PersisterAggregator#loadLastConfigs() will search for the first non-absent response from storages ordered backwards as user specified (first '3', then '2'). When a commit notification is received, '2' will be omitted because the read-only flag is set to true, so only '3' will have a chance to persist the new configuration.
If read-only was false, or not specified, both storage adapters would be called in the order specified by 'netconf.config.persister' property.

=== Persister Notification Handler

ConfigPersisterNotificationHandler class is responsible for listening for netconf notifications containing the latest committed configuration.
The listener can handle incoming notifications, or delegates the configuration saving or loading to the persister.

==== Storage Adapter implementations

*XML File Storage* +

The XmlFileStorageAdapter implementation stores configuration in an xml file.

*XML Directory Storage* +

XmlDirectoryStorageAdapter retrieves the initial configuration from a directory. If multiple xml files are present, files are ordered based on the file names and pushed in this order (for example, 00.xml, then 01.xml..) Each file defines its required capabilities, so it will be pushed when those capabilities are advertized by ODL. Writing to this persister is not supported.

*No-Operation Storage* +

NoOpStorageAdapter serves as a dummy implementation of the storage adapter.

*Obsolete storage adapters* +

* File Storage

* FileStorageAdapter implements StorageAdapter, and provides file based configuration persisting.
File path and name is stored as a property and a number of stored backups, expressing the count of the last configurations to be persisted too.
The implementation can handle persisting input configuration, and load the last configuration.

* Directory Storage

* DirectoryStorageAdapter retrieves initial configurations from a directory. If multiple files are present, snapshot and required capabilities will be merged together. See configuration later on this page for details. Writing to this persister is not supported.

* Autodetect Directory Storage

* AutodetectDirectoryStorageAdapter retrieves initial configuration from a directory (exactly as Xml Directory Storage) but supports xml as well as plaintext format for configuration files. Xml and plaintext files can be combined in one directory. Purpose of this persister is to keep backwards compatibility for plaintext configuration files.

IMPORTANT: This functionality will be removed in later releases since Plaintext File/Directory adapters are deprecated, and will be fully replaced by xml storage adapters.

===== Persisted snapshot format

Configuration snapshots are persisted in xml files for both file and directory adapters. They share the same format: +
----
<snapshot>
    <required-capabilities>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:netty?module=netty&amp;revision=2013-11-19</capability>
        ...
    </required-capabilities>
    <configuration>

        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
             ...
            </modules>

            <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
             ...
            </services>

        </data>

    </configuration>
</snapshot>
----
The whole snapshot is encapsulated in the snapshot tag that contains two children elements: +

* The required-capabilities tag contains the list of yang capabilities that are required to push configurations located under the configuration tag. The config persister will not push the configuration before the netconf endpoint for the config subsystem reports all needed capabilities. Every yang model that is referenced within this xml file (as namespace for xml tag) must be referenced as a capability in this list.
* The configuration tag contains the configurations to be pushed to the config subsystem. It is wrapped in a data tag with the base netconf namespace. The whole data tag, with all its child elements, will be inserted into an edit-config rpc as config tag. For more information about the structure of configuration data, see  base yang model for the config subsystem and all the configuration yang files for the controller modules as well as those provided examples. Examples contain multiple explained edit-config rpcs that change the configuration.

NOTE:  XML File adapter adds additional tags to the xml format since it supports multiple snapshots per file.

The xml format for xml file adapter: +
----
<persisted-snapshots>
   <snapshots>
      <snapshot>
         <required-capabilities>
            <capability>urn:opendaylight:params:xml:ns:yang:controller:shutdown:impl?module=shutdown-impl&amp;revision=2013-12-18</capability>
         </required-capabilities>
         <configuration>
            <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
               <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                 ....
               </modules>
               <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                 ...
               </services>
            </data>
         </configuration>
      </snapshot>
      <snapshot>
         <required-capabilities>
            <capability>urn:opendaylight:params:xml:ns:yang:controller:shutdown:impl?module=shutdown-impl&amp;revision=2013-12-18</capability>
         </required-capabilities>
         <configuration>
            <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
               <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                 ....
               </modules>
               <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                 ...
               </services>
            </data>
         </configuration>
      </snapshot>
   </snapshots>
</persisted-snapshots>
----


=== OpenDaylight Controller configuration: FAQs
====  Generic questions about the configuration subsystem
*There is already JMX. Why do we need another system?*

Java Management Extensions (JMX) provides programmatic access to management data, defining a clear structure on the level of a single object (MBeans). It provides the mechanism to query and set information exposed from these MBeans, too. It is adequate for replacing properties, but it does not treat the JVM container for what it is: a collection of applications working in concert. When the configuration problem is taken to the level of an entire system, there are multiple issues which JMX does not solve:

* The need to validate that a proposed system is semantically valid before an attempt to change is made
* The ability to synchronize modification multiple properties at the same time, such that both occur at the same time
* The ability to express dependencies between applications
* Machine-readable descriptions of layouts of configuration data

*Why use YANG?*

The problem of configuring a device has been tackled in https://ietf.org/[IETF] for many years now, initially using https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol[SNMP] (with https://en.wikipedia.org/wiki/Management_information_base[MIB] as the data definition language). While the protocol has been successful for monitoring devices, it has never gained traction as the unified way of configuring devices. The reasons for this have been https://tools.ietf.org/html/rfc3535[analyzed] and https://datatracker.ietf.org/doc/rfc6241/[NETCONF] was standardized as the successor protocol. NETCONF provides the abstractions to deal with configuration validation, and relies on http://tools.ietf.org/html/rfc6020[YANG] as its data modeling language. The configuration subsystem is designed to completely align with NETCONF such that it can be used as the native transport with minimal translation.

=== OpenDaylight Controller configuration: Component map
[cols="5,5a",^,options="header",width="75%"]
|===
| Component | Description
| config-subsystem-core | Config subsystem core.
			Manages the configuration of the controller.

Responsibilities:


* Scanning of bundles for ModuleFactories.

* Transactional management of lifecycle and dependency injection for config modules.

* Exposure of modules and their configuration into JMX.
| netty-config| Config modules for netty related resources, for example, netty-threadgroup, netty-timer and others.

Contains config module definition in the form of yang schemas + generated code binding for the config subsystem.
| controller-shutdown | Controller shutdown mechanism.

Brings down the whole OSGi container of the controller.

Authorization required in the form of a "secret string".

Also contains config module definition in the form of yang schemas + generated code binding for the config subsystem. This makes it possible to invoke shutdown by means of the config-subsystem.
| threadpool-config | Config modules for threading related resources, for example, threadfactories, fixed-threadpool, and others.

Contains config module definition in the form of yang schemas + generated code binding for the config subsystem.
| logback-config | Config modules for logging (logback) related resources, for example, loggers, appenders, and others.

Contains config module definition in the form of yang schemas + generated code binding for the config subsystem.
| netconf-config-dispatcher-config | Config modules for netconf-dispatcher(from netconf subsystem).

Contains config module definition in the form of yang schemas + generated code binding for the config subsystem.
| yang-jmx-config-generator | Maven plugin that generates the config subsystem code binding from provided yang schemas. This binding is required when the bundles want to participate in the config subsystem.
| yang-jmx-config-generator-testing-modules | Testing resources for the maven plugin.
| config-persister | Contains the api definition for an extensible configuration persister(database for controller configuration).

The persister (re)stores the configuration for the controller. Persister implementation can be found in the netconf subsystem.

The adapter bundles contain concrete implementations of storage extension. They store the config as xml files on the filesystem.
| config-module-archetype | Maven archetype for "config subsystem aware" bundles.

This archetype contains blueprints for yang-schemas, java classes, and other files(for example, pom.xml) required for a bundle to participate in the config subsystem.

This archetype generates a bundle skeleton that can be developed into a full blown "config subsystem aware" bundle.
|===

=== OpenDaylight Controller: Netconf component map

[cols="2", options="header", width="75%"]
|===
|Component | Description

| netconf-server | Implementation of the generic (extensible) netconf server over tcp/ssh. Handles the general communication over the network, and forwards the rpcs to its extensions that implement the specific netconf rpc handles (For example: get-config).
| netconf-to-config-mapping | API definition for the netconf server extension with the base implementation that transforms the netconf rpcs to java calls for the config-subsystem (config-subsystem netconf extension).
| netconf-client | Netconf client basic implementation. Simple netconf client that supports netconf communication with remote netconf devices using xml format.
| netconf-monitoring | Netconf-monitoring yang schemas with the implementation of a netconf server extension that handles the netconf-monitoring related handlers (For example: adding netconf-state to get rpc)
| config-persister-impl | Extensible implementation of the config persister that persists the configuration in the form of xml,(easy to inject to edit-config rpc) and loads the initial configuration from the persisted files. The configuration is stored after every successful commit rpc.
| netconf-cli | Prototype of a netconf cli.
|===

=== OpenDaylight Controller Configuration: Examples sample project
*Sample maven project* +

In this example, we will create a maven project that provides two modules, each implementing one service. We will design a simple configuration, as well as runtime data for each module using yang.
A sample maven project called config-demo was created. This project contains two Java interfaces: Foo and Bar. Each interface has one default implementation per interface, FooImpl and BarImpl. Bar is the producer in our example and produces integers when the method getNextEvent() is called. Foo is the consumer, and its implementation depends on a Bar instance. Both implementations require some configuration that is injected by means of constructors.

* Bar.java:
----
package org.opendaylight.controller.config.demo;

public interface Bar {

    int getNextEvent();

}
----
* BarImpl.java:
----
package org.opendaylight.controller.config.demo;

public class BarImpl implements Bar {

    private final int l1, l2;
    private final boolean b;

    public BarImpl(int l1, int l2, boolean b) {
        this.l1 = l1;
        this.currentL = l1;
        this.l2 = l2;
        this.b = b;
    }

    private int currentL;

    @Override
    public int getNextEvent() {
        if(currentL==l2)
            return -1;
        return currentL++;
    }
}
----
* Foo.java:
----
package org.opendaylight.controller.config.demo;

public interface Foo {

    int getEventCount();
}
----
* FooImpl.java:
----
package org.opendaylight.controller.config.demo;

public class FooImpl implements Foo {

    private final String strAttribute;
    private final Bar barDependency;
    private final int intAttribute;

    public FooImpl(String strAttribute, int intAttribute, Bar barDependency) {
        this.strAttribute = strAttribute;
        this.barDependency = barDependency;
        this.intAttribute = intAttribute;
    }

    @Override
    public int getEventCount() {
        int count = 0;
        while(barDependency.getNextEvent() != intAttribute) {
            count++;
        }
        return count;
    }
}
----
* pom.xml (config-demo project is defined as a sub-module of the controller project, and at this point contains only the configuration for maven-bundle-plugin):
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <artifactId>commons.opendaylight</artifactId>
        <groupId>org.opendaylight.controller</groupId>
        <version>1.4.1-SNAPSHOT</version>
        <relativePath>../commons/opendaylight/pom.xml</relativePath>
    </parent>
    <groupId>org.opendaylight.controller</groupId>
    <version>0.1.1-SNAPSHOT</version>
    <artifactId>config-demo</artifactId>
    <packaging>bundle</packaging>
    <name>${project.artifactId}</name>
    <prerequisites>
        <maven>3.0.4</maven>
    </prerequisites>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.felix</groupId>
                <artifactId>maven-bundle-plugin</artifactId>
                <version>2.4.0</version>
                <extensions>true</extensions>
                <configuration>
                    <instructions>
                        <Bundle-Name>${project.groupId}.${project.artifactId}</Bundle-Name>
                        <Export-Package>
                            org.opendaylight.controller.config.demo,
                        </Export-Package>
                    </instructions>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
----

==== Describing the module configuration using yang
In order to fully leverage the utilities of the configuration subsystem, we need to describe the services, modules, their configurations, and the runtime state using the yang modeling language. We will define two services and two modules, which will be used to configure the instances of FooImpl and BarImpl. This definition will be split into two yang files: config-demo.yang (service definition) and config-demo-impl.yang (module definition).

* config-demo.yang
----
module config-demo {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo";
    prefix "demo";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "Service definition for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }

    // Service definition for service foo that encapsulates instances of org.opendaylight.controller.config.demo.Foo
    identity foo {
        description
            "Foo service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Foo";
    }

    identity bar {
        description
            "Bar service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Bar";
    }
}
----
The config yang module needs to be imported in order to define the services. There are two services defined, and these services correspond to the Java interfaces Foo and Bar (specified by the config:java-class extension).

* config-demo-impl.yang
----
module config-demo-impl {

    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo:java";
    prefix "demo-java";

    // Dependency on service definition for config-demo
    /* Service definitions could be also located in this yang file or even
     * in a separate maven project that is marked as maven dependency
     */
    import config-demo { prefix demo; revision-date 2013-10-14;}

    // Dependencies on config subsystem definition
    import config { prefix config; revision-date 2013-04-05; }
    import rpc-context { prefix rpcx; revision-date 2013-06-17; }


    description
        "Service implementation for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }
                                                                      //----- module foo-impl ----- //
    // Module implementing foo service                                                              //
    identity foo-impl {                                                                             //
        base config:module-type;                                                                    //
        config:provided-service demo:foo;                                                           //
        config:java-name-prefix FooImpl;                                                            //
    }                                                                                               //
                                                                                                    //
    // Configuration for foo-impl module                                                            //
    augment "/config:modules/config:module/config:configuration" {                                  //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
            leaf str-attribute {                                                                    //
                type string;                                                                        //
            }                                                                                       //
                                                                                                    //
            leaf int-attribute {                                                                    //
                type int32;                                                                         //
            }                                                                                       //
                                                                                                    //
                                                                                                    //
            // Dependency on bar service instance                                                   //
            container bar-dependency {                                                              //
                uses config:service-ref {                                                           //
                    refine type {                                                                   //
                        mandatory true;                                                             //
                        config:required-identity demo:bar;                                          //
                    }                                                                               //
                }                                                                                   //
            }                                                                                       //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                                    //
    // Runtime state definition for foo-impl module                                                 //
    augment "/config:modules/config:module/config:state" {                                          //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                      // ---------- //
    // Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:bar;
        config:java-name-prefix BarImpl;
    }

    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }

                leaf int-attribute2 {
                    type int32;
                }

                leaf bool-attribute {
                    type boolean;
                }
            }

        }
    }

    augment "/config:modules/config:module/config:state" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

        }
    }

}
----
The config yang module as well as the config-demo yang module need to be imported. There are two modules defined: foo-impl and bar-impl. Their configuration (defined in the augment "/config:modules/config:module/config:configuration" block) corresponds to the configuration of the FooImpl and BarImpl Java classes. In the constructor of FooImpl.java, we see that the configuration of foo-impl module defines three similar attributes. These arguments are used to instantiate the FooImpl class. These yang files are placed under the src/main/yang folder.

==== Updating the maven configuration in pom.xml

The yang-maven-plugin must be added to the pom.xml. This plugin will process the yang files, and generate the configuration code for the defined modules. Plugin configuration: +
----
<plugin>
    <groupId>org.opendaylight.yangtools</groupId>
    <artifactId>yang-maven-plugin</artifactId>
    <version>${yangtools.version}</version>
    <executions>
        <execution>
            <goals>
                <goal>generate-sources</goal>
            </goals>
            <configuration>
                <codeGenerators>
                    <generator>
                        <codeGeneratorClass>
                            org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                        </codeGeneratorClass>
                        <outputBaseDir>${project.build.directory}/generated-sources/config</outputBaseDir>
                        <additionalConfiguration>
                            <namespaceToPackage1>
                                urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                            </namespaceToPackage1>
                        </additionalConfiguration>
                    </generator>
                </codeGenerators>
                <inspectDependencies>true</inspectDependencies>
            </configuration>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>org.opendaylight.controller</groupId>
            <artifactId>yang-jmx-generator-plugin</artifactId>
            <version>${config.version}</version>
        </dependency>
    </dependencies>
</plugin>
----
The configuration important for the plugin: the output folder for the generated files, and the mapping between the yang namespaces and the java packages (Inspect dependencies must be set to true.). The default location for the yang files is under the src/main/yang folder. This plugin is backed by the artifact yang-jmx-generator-plugin and its class org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator is responsible for code generation. This artifact is part of the configuration subsystem.

In addition to the yang-maven-plugin, it is neccessary to add the build-helper-maven-plugin in order to add the generated sources to the build process:
----
<plugin>
   <groupId>org.codehaus.mojo</groupId>
   <artifactId>build-helper-maven-plugin</artifactId>
   <version>1.8</version>
   <executions>
       <execution>
           <id>add-source</id>
           <phase>generate-sources</phase>
           <goals>
               <goal>add-source</goal>
           </goals>
           <configuration>
               <sources>
                  <source>${project.build.directory}/generated-sources/config</source>;
               </sources>
           </configuration>
       </execution>
   </executions>
</plugin>
----
Earlier, the configuration yang module in the yang files was imported. In order to acquire this yang module, we need to add a dependency to the pom file:
----
<dependency>
    <groupId>org.opendaylight.controller</groupId>
    <artifactId>config-api</artifactId>
    <version>${config.version}</version>
</dependency>
----
In addition, a couple of utility dependencies must be added:
----
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
</dependency>
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
</dependency>
----
Run *mvn clean install*.

==== Generated java files

A set of new source files divided into two groups is seen. The first group is located under the ${project.build.directory}/generated-sources/config directory, which was specified in the yang-maven-plugin configuration. The second group is located under the src/main/java directory. Both groups then define the package org.opendaylight.controller.config.yang.config.demo.impl. The first group contains code that must not be edited in any way, since this code can be regenerated by the plugin if necessary. The code that needs to be edited belongs to the second group and is located under src/main/java.

===== Generated config source files examples

* BarImplModuleMXBean.java
----
public interface BarImplModuleMXBean
{
    public org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute getDtoAttribute();

    public void setDtoAttribute(org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute dtoAttribute);

}
----
The BarImplModuleMXBean interface represents the getter and the setter for dtoAttribute that will be exported to the configuration registry by means of JMX. The attribute was defined in the yang model: in this case, it is the composite type which was converted to OpenType.

* Attribute definition from config-demo-impl.yang
----
// Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:foo;
        config:java-name-prefix BarImpl;
    }

    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }

                leaf int-attribute2 {
                    type int32;
                }

                leaf bool-attribute {
                    type boolean;
                }
            }

        }
    }
----
From the container dto-attribute, the DtoAttribute java file was generated. The Class contains the plain constructor, and the getters and setters for the attributes defined as container leaves.
Not only is ModuleMXBean generated from this module definition, but also BarImplModuleFactory and BarImplModule stubs (in fact AbstractBarImplModuleFactory and AbstractBarImplModule are generated too.).

* AbstractBarImplModule.java +
This abstract class is almost fully generated: only the method validate() has an empty body and the method createInstance() is abstract. The user must implement both methods by user. AbstractBarImplModule implements its ModuleMXBean, Module, RuntimeBeanRegistratorAwareModule, and the dependent service interface as defined in yang. Moreover, the class contains two types of constructors: one for the module created from the old module instance, and the second for module creation from scratch.

* AbstractBarImplModuleFactory.java +
Unlike AbstractModule, AbstractFactory is fully generated, but it is still an abstract class. The factory is responsible for module instances creation, and provides two type of instantiateModule methods for both module constructor types. It implements the ModuleFactory interface.

Next, create the runtime bean for FooImplModule. Runtime beans are designated to capture data about the running module.

* Add runtime bean definition to config-demo-impl.yang +

===== Modifying generated sources

Generated source files: +

* src/main/java/**/BarImplModule
* src/main/java/**/BarImplModuleFactory
* src/main/java/**/FooImplModule
* src/main/java/**/FooImplModuleFactory

*BarImplModule* +
We will start by modifying BarImplModule. Two constructors and two generated methods are seen:
----
@Override
    public void validate(){
        super.validate();
        // Add custom validation for module attributes here.
    }

    @Override
    public java.lang.AutoCloseable createInstance() {
        //TODO:implement
        throw new java.lang.UnsupportedOperationException("Unimplemented stub method");
    }
----
In *validate*, specify the validation for configuration attributes, for example:
----
@Override
    public void validate(){
        super.validate();
        Preconditions.checkNotNull(getDtoAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getBoolAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute2());
        Preconditions.checkState(getDtoAttribute().getIntAttribute() > getDtoAttribute().getIntAttribute2());
    }
----
In *createInstance* you need to create a new instance of the bar service => Bar interface, for example:
----
@Override
    public java.lang.AutoCloseable createInstance() {
        return new BarImpl(getDtoAttribute().getIntAttribute(), getDtoAttribute().getIntAttribute2(), getDtoAttribute()
                .getBoolAttribute());
    }
----
===== Notes:

* createInstance returns AutoCloseable so the returned type needs to implement it. (You can make BarImpl implement AutoCloseable, or create a Wrapper class around the BarImpl instance that implements AutoCloseable, or even extend the BarImpl class and make it implement it.)
* You can access all the configuration attributes by means of the getter methods.
* In config-demo-impl.yang, we defined the bar-impl configuration as a container dto-attribute. The code generator creates a transfer object DtoAttribute that you can access by means of the getDtoAttribute() method, and retrieve configuration data from it. You can even add a new constructor to BarImpl that takes this transfer object, and reduces the number of arguments.

*FooImplModule* +
We will not add any custom validation in this module. The createInstance method will look as follows: +
----
 @Override
    public java.lang.AutoCloseable createInstance() {
        return new FooImpl(getStrAttribute(), getIntAttribute(), getBarDependencyDependency());
    }
----
===== Adding support for default instances

In order to provide a default instance of module bar-impl, we need to further modify the generated code by the overriding method getDefaultModules in src/main/java/**/BarImplModuleFactory class. The body of this class is empty thus far, and it inherits the default behaviour from its parent abstract factory. Use the following code to replace the empty body:
----
public static final ModuleIdentifier defaultInstance1Id = new ModuleIdentifier(NAME, "defaultInstance1");

    @Override
    public Set<BarImplModule> getDefaultModules(DependencyResolverFactory dependencyResolverFactory, BundleContext bundleContext) {
        DependencyResolver depResolver1 = dependencyResolverFactory.createDependencyResolver(defaultInstance1Id);
        BarImplModule defaultModule1 = new BarImplModule(defaultInstance1Id, depResolver1);
        defaultModule1.setDtoAttribute(getDefaultConfiguration(bundleContext));

        return Sets.newHashSet(defaultModule1);
    }

    private DtoAttribute getDefaultConfiguration(BundleContext bundleContext) {
        DtoAttribute defaultConfiguration = new DtoAttribute();

        String property = bundleContext.getProperty("default.bool");
        defaultConfiguration.setBoolAttribute(property == null ? false : Boolean.parseBoolean(property));

        property = bundleContext.getProperty("default.int1");
        defaultConfiguration.setIntAttribute(property == null ? 55 : Integer.parseInt(property));

        property = bundleContext.getProperty("default.int2");
        defaultConfiguration.setIntAttribute2(property == null ? 0 : Integer.parseInt(property));

        return defaultConfiguration;
    }
----
The _getDefaultModules_ method now produces an instance of the bar-impl module with the name _defaultInstance1_. (It is possible to produce multiple default instances since the return type is a Set of module instances.) Note the getDefaultConfiguration method. It provides the default configuration for default instances by trying to retrieve system properties from bundleContext (or provides hardcoded values in case the system property is not present).

For the controller distribution, system properties can be fed by means of _config.ini_ file.

The method _getDefaultModules_ is called automatically after a bundle containing this factory is started in the OSGi environment. Its default implementation returns an empty Set.

The default instances approach is similar to the Activator class approach in OSGi with the advantage of default instances being managed by the configuration subsystem. This approach can either replace the Activator class approach, or be used along with it.

*Verifying the default instances in distribution* +

If we add the config-demo bundle to the opendaylight distribution, we can verify the presence of the default instance. The file pom.xml under the opendaylight/distribution/opendaylight folder needs to be modified by adding the config-demo dependency:
----
<dependency>
    <groupId>${project.groupId}</groupId>
    <artifactId>config-demo</artifactId>
    <version>0.1.1-SNAPSHOT</version>
</dependency>
----
Now we need to rebuild the conf-demo module using mvn clean install. Then, we can build the distribution using the same mvn command under the _opendaylight/distribution/opendaylight_ folder. If we go to the _opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight_ folder, and execute run.sh, the opendaylight distribution should start.

We can check the presence of the default instances by means of JMX using a tool such as _jvisualvm_.

=== OpenDaylight Controller:Configuration examples user guide
==== Configuring thread pools with yangcli-pro
Requirements: yangcli-pro version 13.04-9.2 or later +

===== Connecting to plaintext TCP socket and ssh
Currently SSH is exposed by the controller. The network interface and port are configured in configuration/config.ini . The current configuration of netconf is as follows: +
----
# Netconf startup configuration
#netconf.tcp.address=127.0.0.l
#netconf.tcp.port=8383

netconf.ssh.address=0.0.0.0
netconf.ssh.port=1830
----
To connect the yangcli-pro client, use the following syntax: +
----
yangcli-pro --user=admin --password=admin --transport=ssh --ncport=1830 --server=localhost
----
If the plaintext TCP port is not commented out, one can use the following: +
----
yangcli-pro --user=a --password=a --transport=tcp --ncport=8383 --server=localhost
----
Authentication in this case is ignored.

For better debugging, include following arguments: +
----
--log=/tmp/yuma.log --log-level=debug4 --log-console
----

NOTE:  When the log file is set, the output will not appear on stdout.

===== Configuring threadfactory
The threadfactory is a service interface that can be plugged into threadpools, defined in config-threadpool-api (see the https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=blob;f=opendaylight/config/threadpool-config-api/src/main/yang/threadpool.yang;h=8f3064822be319dfee6fd7c7061c8bee14db268f;hb=refs/heads/master[yang file].
The implementation to be used is called threadfactory-naming. This implementation will set a name for each thread created using a configurable prefix and auto incremented index. See the https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=blob;f=opendaylight/config/threadpool-config-impl/src/main/yang/threadpool-impl.yang;h=a2366f285a0c0b8682b1093f18fb5ee184c9cde3;hb=refs/heads/master[Yang file].

. Launch yangcli-pro and connect to the server.
. Enter *get-config source=running* to see the current configuration. +
Example output: +
----
rpc-reply {
  data {
    modules {
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
    }
    services {
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----
[start=3]
. Enter the merge /modules/module.
. At the prompt, enter the string value for the leaf <name>. This is the name of the config module. Enter threadfactory-bgp.
. Set the identityref for the leaf <type>. Press Tab to see a list of available module names. Enter threadfactory-naming.
. At the prompt, choose the case statement. Example output:
----
 1: case netty-threadgroup-fixed:
       leaf thread-count
  2: case netty-hashed-wheel-timer:
       leaf tick-duration
       leaf ticks-per-wheel
       container thread-factory
  3: case async-eventbus:
       container threadpool
  4: case threadfactory-naming:
       leaf name-prefix
  5: case threadpool-fixed:
       leaf max-thread-count
       container threadFactory
  6: case threadpool-flexible:
       leaf max-thread-count
       leaf minThreadCount
       leaf keepAliveMillis
       container threadFactory
  7: case threadpool-scheduled:
       leaf max-thread-count
       container threadFactory
  8: case logback:
       list file-appenders
       list rolling-appenders
       list console-appenders
       list loggers
----
In this case, we chose 4. +
[start=7]
. Next fill in the string value for the leaf <name-prefix>. Enter bgp.
: (You should get an OK response from the server.)
[start=8]
. Optionally issue get-config source=candidate to verify the change.
. Issue commit.
. Issue get-config source=running. Example output: +
----
rpc-reply {
  data {
    modules {
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
      module  threadfactory-bgp {
        type th-java:threadfactory-naming
        name threadfactory-bgp
        name-prefix bgp
      }
    }
    services {
      service  th:threadfactory {
        type th:threadfactory
        instance  ref_threadfactory-bgp {
          name ref_threadfactory-bgp
          provider /modules/module[type='threadfactory-naming'][name='threadfactory-bgp']
        }
      }
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----
==== Configuring fixed threadpool

Service interface threadpool is defined in the config-threadpool-api. The implementation used is called threadpool-fixed that is defined in config-threadpool-impl. This implementation creates a threadpool of fixed size. There are two mandatory attributes: size and dependency on a threadfactory.

. Issue get-config source=running. As you can see in the last step of configuring threadfactory, /services/service, the node associated with it has instance name ref_threadfactory-bgp.
. Issue merge /modules/module.
. Enter the name bgp-threadpool.
. Enter the type threadpool.
. Select the appropriate case statement.
. Enter the value for leaf <max-thread-count>: 100.
. Enter the threadfactory for attribute threadfactory/type. This is with reference to /services/service/type, in other words, the service interface.
. Enter ref_threadfactory-bgp.
Server response must be an OK message.
[start=9]
. Issue commit.
. Issue get-config source=running.
Example output: +
----
rpc-reply {
  data {
    modules {
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
      module  bgp-threadpool {
        type th-java:threadpool-fixed
        name bgp-threadpool
        threadFactory {
          type th:threadfactory
          name ref_threadfactory-bgp
        }
        max-thread-count 100
      }
      module  threadfactory-bgp {
        type th-java:threadfactory-naming
        name threadfactory-bgp
        name-prefix bgp
      }
    }
    services {
      service  th:threadpool {
        type th:threadpool
        instance  ref_bgp-threadpool {
          name ref_bgp-threadpool
          provider /modules/module[type='threadpool-fixed'][name='bgp-threadpool']
        }
      }
      service  th:threadfactory {
        type th:threadfactory
        instance  ref_threadfactory-bgp {
          name ref_threadfactory-bgp
          provider /modules/module[type='threadfactory-naming'][name='threadfactory-bgp']
        }
      }
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----
To see the actual netconf messages, use the logging arguments described at the top of this page. To validate that a threadpool has been created, a tool like VisualVM can be used.

==== Logback configuration - Yuma
This approach to configure logback will utilize a 3rd party cli netconf client from Yuma. We will modify existing console appender in logback and then call reset rpc on logback to clear its status list.

For initial configuration of the controller and startup parameters for yuma, see the threadpool example: https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:Threadpool[Threadpool configuration using Yuma].

Start the controller and yuma cli client as in the previous example.

There is no need to initialize the configuration module wrapping logback manually, since it creates a default instance. Therefore you should see the output containing logback configuration after the execution of get-config source=running command in yuma:
----
rpc-reply {
  data {
    modules {
      module  singleton {
        type logging:logback
        name singleton
        console-appenders {
          threshold-filter ERROR
          name STDOUT
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{36} - %msg%n'
        }
        file-appenders {
          append true
          file-name logs/audit.log
          name audit-file
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} %msg %n'
        }
        loggers {
          level WARN
          logger-name org.opendaylight.controller.logging.bridge
        }
        loggers {
          level INFO
          logger-name audit
          appenders audit-file
        }
        loggers {
          level ERROR
          logger-name ROOT
          appenders STDOUT
          appenders opendaylight.log
        }
        loggers {
          level INFO
          logger-name org.opendaylight
        }
        loggers {
          level WARN
          logger-name io.netty
        }
        rolling-appenders {
          append true
          max-file-size 10MB
          file-name logs/opendaylight.log
          name opendaylight.log
          file-name-pattern logs/opendaylight.%d.log.zip
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{35} - %msg%n'
          clean-history-on-start false
          max-history 1
          rolling-policy-type TimeBasedRollingPolicy
        }
      }
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
    }
    services {
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----

===== Modifying existing console appender in logback
. Start edit-config with merge option:
----
merge /modules/module
----
[start=2]
. For Name of the module, enter *singleton*.
. For Type, enter *logback*.
. Pick the corresponding case statement with the name logback.
We do not want to modify file-appenders, rolling-appenders and loggers lists, so the answer to questions from yuma is N (for no):
----
Filling optional case /modules/module/configuration/logback:
Add optional list 'file-appenders'?
Enter Y for yes, N for no, or C to cancel: [default: Y]
----
[start=5]
. As we want to modify console-appenders, the answer to the question from Yuma is Y:
----
Filling optional case /modules/module/configuration/logback:
Add optional list 'console-appenders'?
Enter Y for yes, N for no, or C to cancel: [default: Y]
----
[start=6]
. This will start a new configuration process for console appender and we will fill following values:

* <encoder-pattern> %date{"yyyy-MM-dd HH:mm:ss.SSS z"} %msg %n
* <threshold-filter> INFO
* <name> STDOUT
[start=7]
. Answer N to the next question.
----
Add another list?
Enter Y for yes, N for no, or C to cancel: [default: N]
----
Notice that we changed the level for threshold-filter for STDOUT console appender from ERROR to INFO. Now issue a commit command to commit the changed configuration, and the response from get-config source=running command should look like this:
----
rpc-reply {
  data {
    modules {
      module  singleton {
        type logging:logback
        name singleton
        console-appenders {
          threshold-filter INFO
          name STDOUT
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{36} - %msg%n'
        }
        file-appenders {
          append true
          file-name logs/audit.log
          name audit-file
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} %msg %n'
        }
        loggers {
          level WARN
          logger-name org.opendaylight.controller.logging.bridge
        }
        loggers {
          level INFO
          logger-name audit
          appenders audit-file
        }
        loggers {
          level ERROR
          logger-name ROOT
          appenders STDOUT
          appenders opendaylight.log
        }
        loggers {
          level INFO
          logger-name org.opendaylight
        }
        loggers {
          level WARN
          logger-name io.netty
        }
        rolling-appenders {
          append true
          max-file-size 10MB
          file-name logs/opendaylight.log
          name opendaylight.log
          file-name-pattern logs/opendaylight.%d.log.zip
          encoder-pattern '%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{35} - %msg%n'
          clean-history-on-start false
          max-history 1
          rolling-policy-type TimeBasedRollingPolicy
        }
      }
      module  binding-broker-singleton {
        type binding-impl:binding-broker-impl-singleton
        name binding-broker-singleton
      }
    }
    services {
      service  md-sal-binding:binding-broker-osgi-registry {
        type md-sal-binding:binding-broker-osgi-registry
        instance  ref_binding-broker-singleton {
          name ref_binding-broker-singleton
          provider /modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']
        }
      }
    }
  }
}
----
==== Invoking RPCs
*Invoking Reset RPC on logback* +
The configuration module for logback exposes some information about its current state(list of logback status messages). This information can be accessed using get netconf operation or get command from yuma. Example response after issuing get command in yuma:
----
rpc-reply {
  data {
    modules {
      module  singleton {
        type logging:logback
        name singleton
        status {
          message 'Found resource [configuration/logback.xml] at
[file:/.../controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-
osgipackage/opendaylight/configuration/logback.xml]'
          level INFO
          date 2479534352
        }
        status {
          message 'debug attribute not set'
          level INFO
          date 2479534441
        }
        status {
          message 'Will scan for changes in
[[/.../controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-
osgipackage/opendaylight/configuration/logback.xml]]
every 60 seconds.'
          level INFO
          date 2479534448
        }
        status {
          message 'Adding ReconfigureOnChangeFilter as a turbo filter'
          level INFO
          date 2479534448
        }
 ...
----
Logback also exposes an rpc called reset that wipes out the list of logback status messages and to invoke an rpc with name reset on module named singleton of type logback, following command needs to be issued in yuma:
----
reset context-instance="/modules/module[type='logback' and name='singleton']"
----
After an ok response, issuing get command should produce response with empty logback status message list:
----
rpc-reply {
  data {
    modules {
      module  singleton {
        type logging:logback
        name singleton
      }
    }
  }
}
----
This response confirms successful execution of the reset rpc on logback.

*Invoking shutdown RPC* +
This command entered in yuma will shut down the server. If all bundles do not stop correctly within 10 seconds, it will force the process to exit.
----
shutdown context-instance="/modules/module[type='shutdown' and name='shutdown']",input-secret="",max-wait-time="10000",reason="reason"
----
=== OpenDaylight Controller Configuration: Logback Examples
==== Logback Configuration Example

The Logback logger configuration is part of the config subsystem. This module allows changes to the Logback configuration at runtime. It is used here as an example to demonstrate the YANG to Java code generator and to show how the configuration transaction works.

==== Java code generation
The logging configuration YANG module definition can be found in the config-logging.yang file. The code is generated by the yang-maven-plugin and yang-jmx-generator-plugin. The output java files are located as defined in the plugin configuration, where additional configuration parameters can be set. The logback module is defined as identity, with the base "config:module-type"; it does not provide or depend on any service interface.
----
identity logback {
    description
        "Actual state of logback configuration.";
    base config:module-type;
    config:java-name-prefix Logback;
}
----
The next logback module attributes are defined in the "/config:modules/config:module/config:configuration" augment as the snippet below shows.
----
augment "/config:modules/config:module/config:configuration" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";

        list console-appenders {

            leaf encoder-pattern {
                type string;
                mandatory true;
            }

            leaf threshold-filter {
                type string;
                default 'ALL';
            }

            leaf name {
                type string;
                mandatory true;
            }
            config:java-name-prefix ConsoleAppenderTO;
        }
         ...
----
Now LogbackModule and LogbackModuleFactory can be generated. In fact, three more java files related to this module will be generated. By the augment definition, TypeObjects too are generated (that is to say, ConsoleAppenderTO). They are regular java classes with getters and setters for arguments defined as leaves.

* *LogbackModuleMXBean* is the interface containing getters and setters for attributes defined in the configuration augment.
* *AbstractLogbackModule* is the abstract java class, which implements Module, RuntimeBeanRegistratorAwareModule, and LogbackModuleMXBean. It contains almost all functionality, except validate and createInstance methods.
* *AbstractLogbackModuleFactory* is the abstract java class responsible for creating module instances. It implements the ModuleFactory interface.
* *LogbackModule* class extends AbstractLogbackModule. It is located in a different place (source/main/java) and can be modified by the user, so that the abstract method is implemented and the validate method is overridden.
* *LogbackModuleFactory* class extends AbstractLogbackModuleFactory and overrides its instantiateModule methods.
Next, the runtime bean is defined in the "/config:modules/config:module/config:state" augment. +
----
augment "/config:modules/config:module/config:state" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";

        rpcx:rpc-context-instance "logback-rpc";

        list status {
            config:java-name-prefix StatusTO;

            leaf level {
                type string;
            }

            leaf message {
                type string;
            }

            leaf date {
                type uint32;
            }
        }
    }
}
----
* The *Generator* plugin creates another set of java files.
* *LogbackRuntimeMXBean* is the interface extending RuntimeBean. It contains the getter method for the argument defined in the augment.
* *LogbackRuntimeRegistrator* class serves as the registrator for runtime beans.
* *LogbackRuntimeRegistration* class serves as the registration ticket. An instance is returned after registration.

The Logback config also defines logback-rpc with the reset method. It is also defined in the state augment, owing to the context.
----
identity logback-rpc;
rpc reset {
    input {
        uses rpcx:rpc-context-ref {
            refine context-instance {
                rpcx:rpc-context-instance logback-rpc;
            }
        }
    }
}
----
The Reset method is defined in the LogbackRuntimeMXBean interface.

==== Logback configuration: Jolokia

To create configuration on the running OSGi server: Jolokia (http://www.jolokia.org/) is used as a JMX-HTTP bridge, which listens at http://localhost:8080/controller/nb/v2/jolokia and curl to request over HTTP.

. Start the controller. Find more here: https://wiki.opendaylight.org/view/OpenDaylight_Controller:Pulling,_Hacking,_and_Pushing_the_Code_from_the_CLI
. Request Jolokia:
----
curl http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The response must resemble the following: +
----
{
    "timestamp": 1382425537,
    "status": 200,
    "request": {
        "type": "version"
    },
    "value": {
        "protocol": "7.0",
        "agent": "1.1.1",
        "info": {
            "product": "equinox",
            "vendor": "Eclipse",
            "version": "3.8.1.v20120830-144521"
        }
    }
}
----
Jolokia is working.
To configure Logback, first, create a configuration transaction. ConfigResgistryModule offers the operation beginConfig(), and to invoke it:
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":[],"operation":"beginConfig"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The configuration transaction was created. The response received: +
----
{
    "timestamp": 1383034210,
    "status": 200,
    "request": {
        "operation": "beginConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction"
    }
}
----
At this stage, the transaction can be aborted, but we want to create the module bean to be configured. In the created ConfigTransaction call createModule method, the module identifier is logback, and the name must be singleton as only one instance of the Logback configuration is needed.
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction","arguments":["logback","singleton"],"operation":"createModule"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The LogbackModule bean was created. The response returned:
----
{
    "timestamp": 1383034580,
    "status": 200,
    "request": {
        "operation": "createModule",
        "mbean": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction",
        "arguments": [
            "logback",
            "singleton"
        ],
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,instanceName=singleton,moduleFactoryName=logback,type=Module"
    }
}
----
* The configuration bean attributes are set to values obtained from the loggers configuration, with which the server was started. To see attributes, request:
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"read", "mbean":"org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
In the response body, the value contains all attributes (CompositeData) and its nested attribute values.
* Now, the proposed configuration can be committed.
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":["org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"],"operation":"commitConfig"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The configuration was successfully validated and committed, and the module instance created.
----
{
    "timestamp": 1383034793,
    "status": 200,
    "request": {
        "operation": "commitConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "arguments": [
            "org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"
        ],
        "type": "exec"
    },
    "value": {
        "newInstances": [
            {
                "objectName": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=Module"
            }
        ],
        "reusedInstances": [],
        "recreatedInstances": []
    }
}
----
* The runtime bean was registered, and can provide the status information of the configuration and rpc operation reset. To see the status, try requesting:
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"read","mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The entire logback status is in the response body.

* To invoke the rpc method reset:
----
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec",
"mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback",
"operation":"reset","arguments":[]}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
----
The answer:
----
{
    "timestamp": 1383035001,
    "status": 200,
    "request": {
        "operation": "reset",
        "mbean": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=RuntimeBean",
        "type": "exec"
    },
    "value": null
}
----
Now, the runtime bean status attribute will be empty:
----
{
    "timestamp": 1383035126,
    "status": 200,
    "request": {
        "mbean": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=RuntimeBean",
        "type": "read"
    },
    "value": {
        "StatusTO": []
    }
}
----
==== Logback configuration: Netconf

In this case, NETCONF RPCs are used to configure logback. The Netconf server listens at port 8383. To communicate over TCP, telnet is used. More about NETCONF is available at: http://tools.ietf.org/html/rfc6241. Netconf implementation is a part of the Controller - netconf-subsystem. The RPCs of Netconf are XML, and the operations are mapped to JMX operations.
* A server re-start is required. The procedure is the same as above.
* Open a terminal and connect to the server:
----
telnet localhost 8383
----
A Hello message received from the server contains the server capabilities and session-id. To establish connection to the client,send a hello message:
----
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <capabilities>
        <capability>urn:ietf:params:netconf:base:1.0</capability>
    </capabilities>
</hello>
]]>]]>
----
* With the connection created, the client and server can communicate. To see the running modules and services, send an RPC to the server:
----
<rpc id="a" a="64" xmlnx="a:b:c:d" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <running/>
        </source>
    </get-config>
</rpc>
]]>]]>
----

* To configure logback, create a configuration transaction, and create a configuration module. It can be done in one step (in client point of view):
----
<rpc message-id="a" a="64" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
        <target>
            <candidate/>
        </target>
        <default-operation>merge</default-operation>
        <config>
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <name>singleton</name>
                    <type xmlns:logging="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
                        logging:logback
                    </type>
                </module>
            </modules>
        </config>
    </edit-config>
</rpc>
]]>]]>
----

If the configuration worked, the client receives a positive response:

----
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
<ok/>
</rpc-reply>
]]>]]>
----

* The Logback configuration bean attributes contain values loaded from the running Logback configuration. Send a request to the server with an RPC:
----
<rpc id="a" a="64" xmlnx="a:b:c:d" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <candidate/>
        </source>
    </get-config>
</rpc>
]]>]]>
----

* The reply includes the entire configuration that started the server. Assume that we want to change the RollingFileAppender named opendaylight.log attributes - maxFileSize, filename, and maxHistory. ( attribute of TimeBasedRollingPolicy). The proposed configuration:

----
<rpc message-id="a" a="64" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
        <target>
            <candidate/>
        </target>
        <default-operation>merge</default-operation>
        <config>
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <name>singleton</name>
                    <type xmlns:logging="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
                        logging:logback
                    </type>
		    <rolling-appenders xmlns="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
			<append>true</append>
			<max-file-size>5MB</max-file-size>
			<file-name>logs/opendaylight-new.log</file-name>
			<name>opendaylight.log</name>
			<file-name-pattern>logs/opendaylight.%d.log.zip</file-name-pattern>
			<encoder-pattern>%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{35} - %msg%n</encoder-pattern>
			<clean-history-on-start>false</clean-history-on-start>
			<max-history>7</max-history>
			<rolling-policy-type>TimeBasedRollingPolicy</rolling-policy-type>
		    </rolling-appenders>
                </module>
            </modules>
        </config>
    </edit-config>
</rpc>
]]>]]>
----
This configuration is merged with the proposed module configuration. If it passes the validation process successfully, an "ok" reply is received.

* The configuration bean is ready to be committed:
----
<rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <commit></commit>
</rpc>
]]>]]>
----
If successful, the ok message is received obtained, and the logback configuration is set. To verify, look into the logs directory to find a new log file named opendaylight-new.log

* Correctly close the session with the session-id:
----
<rpc message-id="2" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <close-session xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"/>
</rpc>
]]>]]>
----
===== Logback configuration - Yuma

For a yangcli-pro example, see the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:User_guide[user guide].

=== Opendaylight Controller: Configuration Logback.xml
Logging in ODL container is done by means of http://logback.qos.ch/[Logback]. Comprehensive documentation is available at http://logback.qos.ch/documentation.html.

By default, logging messages are appended to stdout of the java process and to file logs/opendaylight.log. When debugging a problem it might be useful to increase logging level:
----
<logger name="org.opendaylight.controller" level="DEBUG"/>
----
Logger tags can be appended under root node <configuration/>. Name of logger is used to select all loggers to which specified rules should apply. Loggers are usually named after class in which they reside. The example above matches all loggers in controller - they all are starting with org.opendaylight.controller . There are 5 logging levels: TRACE,DEBUG,INFO, WARN, ERROR. Additionally one can specify which appenders should be used for given loggers. This might be helpful to redirect certain log messages to another file or send them to syslog or over SMTP.
== OpenDaylight Controller Configuration: Examples of Threadpool

=== Configuration example of thread pools using yangcli-pro

For a yangcli-pro example, see the https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:User_guide[Examples User Guide].

=== Configuration example of thread pools using telnet
It is also possible to manipulate the configuration without the yuma cli. With just a telnet or ssh connection, it is possible to send the plain text containing netconf rpcs encoded in the xml format and achieve the same results as with yuma cli.

This example reproduces the configuration of a threadpool and a threadfactory from the previous example using just a telnet connection. We can also use ssh connection, with the netconf rpcs sending procedure remaining the same. For detailed information about initial configuration for the controller as well as the configuration process, see the example using yuma cli.

=== Connecting to plaintext TCP socket

. Open a telnet connection:
----
telnet 127.0.0.1 8383
----
[start=2]
. Open an ssh connection:
----
ssh netconf@127.0.0.1 -p 1830 -s netconf
----
The password for user netconf is : netconf, and the separator for the messages is: +
----
]]>]]>
----
Every message needs end with these 6 characters.

The server sends a hello message: +
----
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
<capabilities>
<capability>urn:ietf:params:netconf:base:1.0</capability>
<capability>urn:ietf:params:netconf:capability:exi:1.0</capability>
<capability>urn:opendaylight:l2:types?module=opendaylight-l2-types&amp;revision=2013-08-27</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:netty:threadgroup?module=threadgroup&amp;revision=2013-11-07</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding?module=opendaylight-md-sal-binding&amp;revision=2013-10-28</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:threadpool?module=threadpool&amp;revision=2013-04-09</capability>
<capability>urn:ietf:params:netconf:capability:candidate:1.0</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:config?module=config&amp;revision=2013-04-05</capability>
<capability>urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring?module=ietf-netconf-monitoring&amp;revision=2010-10-04</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:netty:eventexecutor?module=netty-event-executor&amp;revision=2013-11-12</capability>
<capability>urn:ietf:params:xml:ns:yang:rpc-context?module=rpc-context&amp;revision=2013-06-17</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl?module=opendaylight-sal-binding-broker-impl&amp;revision=2013-10-28</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:netty:timer?module=netty-timer&amp;revision=2013-11-19</capability>
<capability>urn:ietf:params:xml:ns:yang:ietf-inet-types?module=ietf-inet-types&amp;revision=2010-09-24</capability>
<capability>urn:ietf:params:netconf:capability:rollback-on-error:1.0</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl?module=threadpool-impl&amp;revision=2013-04-05</capability>
<capability>urn:ietf:params:xml:ns:yang:ietf-yang-types?module=ietf-yang-types&amp;revision=2010-09-24</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:logback:config?module=config-logging&amp;revision=2013-07-16</capability>
<capability>urn:opendaylight:params:xml:ns:yang:iana?module=iana&amp;revision=2013-08-16</capability>
<capability>urn:opendaylight:yang:extension:yang-ext?module=yang-ext&amp;revision=2013-07-09</capability>
<capability>urn:opendaylight:params:xml:ns:yang:controller:netty?module=netty&amp;revision=2013-11-19</capability>
<capability>http://netconfcentral.org/ns/toaster?module=toaster&amp;revision=2009-11-20</capability>
<capability>urn:opendaylight:params:xml:ns:yang:ieee754?module=ieee754&amp;revision=2013-08-19</capability>
<capability>urn:opendaylight:params:xml:ns:yang:nps-concepts?module=nps-concepts&amp;revision=2013-09-30</capability>
</capabilities>

<session-id>4</session-id>
</hello>
]]>]]>
----
[start=3]
. As the client, you must respond with a hello message:
----
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <capabilities>
        <capability>urn:ietf:params:netconf:base:1.0</capability>
    </capabilities>
</hello>
]]>]]>
----
Although there is no response to the hello message, the session is already established.

=== Configuring threadfactory

. The following is the Xml equivalent to *get-config source=running*: +
----
<rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <running/>
        </source>
    </get-config>
</rpc>
]]>]]>
----
The response containing the current configuration: +
----
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
	<data>
		<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<module>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-broker-impl-singleton</type>
				<name>binding-broker-singleton</name>
			</module>
		</modules>
		<services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<service>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">prefix:binding-broker-osgi-registry</type>
				<instance>
					<name>ref_binding-broker-singleton</name>
					<provider>/modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']</provider>
				</instance>
			</service>
		</services>
	</data>
</rpc-reply>]]>]]>
----
[start=2]
. To create an instance of threadfactory-naming with the name threadfactory-bgp, and the attribute name-prefix set to bgp, send the message:
----
<rpc message-id="101" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
	<edit-config>
		<target>
			<candidate/>
		</target>
		<default-operation>merge</default-operation>
		<config>
			<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
				<module xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="merge">
					<name>threadfactory-bgp</name>
					<type xmlns:th-java="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">th-java:threadfactory-naming</type>
					<name-prefix xmlns="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">bgp</name-prefix>
				</module>
			</modules>
		</config>
	</edit-config>
</rpc>]]>]]>
----
[start=3]
. To commit the threadfactory instance, send a commit message:
----
<rpc message-id="101" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
	<commit/>
</rpc>]]>]]>
----
The Netconf endpoint should respond with ok to edit-config, as well as the commit message: +

----
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
        <ok/>
</rpc-reply>]]>]]>
----
[start=4]
. The response to the get-config message (the same as the first message sent in this example) should contain the commited instance of threadfactory-naming:
----
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
	<data>
		<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<module>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding:impl">prefix:binding-broker-impl-singleton</type>
				<name>binding-broker-singleton</name>
			</module>

			<module>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">prefix:threadfactory-naming</type>
				<name>threadfactory-bgp</name>
				<name-prefix xmlns="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">bgp</name-prefix>
			</module>
		</modules>

		<services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<service>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:threadpool">prefix:threadfactory</type>
				<instance>
					<name>ref_threadfactory-bgp</name>
					<provider>/modules/module[type='threadfactory-naming'][name='threadfactory-bgp']</provider>
				</instance>
			</service>
			<service>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">prefix:binding-broker-osgi-registry</type>
				<instance>
					<name>ref_binding-broker-singleton</name>
					<provider>/modules/module[type='binding-broker-impl-singleton'][name='binding-broker-singleton']</provider>
				</instance>
			</service>
		</services>
	</data>
</rpc-reply>]]>]]>
----
=== Configuring fixed threadpool

* To create an instance of *threadpool-fixed* , with the same configuration and the same dependency as before, send the following message:

----
<rpc message-id="101" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
	<edit-config>
		<target>
			<candidate/>
		</target>
		<default-operation>merge</default-operation>
		<config>
			<modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
				<module xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" nc:operation="merge">
					<name>bgp-threadpool</name>
					<type xmlns:th-java="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">th-java:threadpool-fixed</type>
					<max-thread-count xmlns="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">100</max-thread-count>
					<threadFactory xmlns="urn:opendaylight:params:xml:ns:yang:controller:threadpool:impl">
						<type xmlns:th="urn:opendaylight:params:xml:ns:yang:controller:threadpool">th:threadfactory</type>
						<name>ref_th-bgp</name>
					</threadFactory>
				</module>
			</modules>

			<services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
			<service>
				<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:threadpool">prefix:threadfactory</type>
				<instance>
					<name>ref_th-bgp</name>
					<provider>/modules/module[type='threadfactory-naming'][name='threadfactory-bgp']</provider>
				</instance>
			</service>
		</services>
		</config>
	</edit-config>
</rpc>]]>]]>
----
Notice the _services_ tag. If an instance is to be referenced as a dependency by another module, it needs to be placed under this tag as a service instance with a unique reference name. Tag _provider_ points to a unique instance that is already present in the config subsystem, or is created within the current edit-config operation.
The tag _name_ contains the reference name that can be referenced by other modules to create a dependency. In this case, a new instance of threadpool uses this reference in its configuration under the _threadFactory_ tag).

You should get an ok response again, and the configuration subsystem will inject the dependency into the threadpool. Now you can commit the configuration (ok response once more) and the process is finished. The config subsystem is now in the same state as it was at the end of the previous example.
