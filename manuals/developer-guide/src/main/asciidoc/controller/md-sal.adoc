=== MD-SAL


Model-Driven SAL (MD-SAL) is a set of infrastructure services aimed at providing
common and generic support to application and plugin developers.

The MD-SAL currently provides infrastructure services for the following:

* Data Services
* remote procedure calls (RPC) or Service routing
* Notification subscription and publishing services

This model-driven infrastructure allows developers to develop applications
and plugins against an API type of their choice.
The infrastructure automatically provides the other API types.
The modeling language of choice for MD-SAL is YANG, which is an IETF standard,
for modeling network element configuration. The YANG Tools project and its
development tools provide support for YANG.

MD-SAL provides two different API types: +

* *MD-SAL Binding:* MD-SAL APIs which extensivelly uses APIs and classes generated
  from YANG models, which provides compile-time safety
* *MD-SAL DOM:* (Document Object Model) APIs which uses DOM-like
  represententation of data which is not tied to particular YANG model.
  These APIs are more powerful, but provides less compile-time safety.

NOTE: *MD-SAL DOM APIs* are used by infrastucture components and  allows for
other applications to provide connectors / expose different set of APIs and
derive most of its functionality purely from YANG Model, which all existing
code without modification could benefit from (e.g. RESTCONF,
which is application built on top of MD-SAL and exposes YANG-modeled application
APIs transparently via HTTP and adds support for XML and JSON payload type.)

// FIXME: Add cross-link
NOTE: External APIs for using MD-SAL and MD-SAL enabled components are possible
via NETCONF and RESTCONF

==== Basic YANG concepts and their rendering in APIs

The following are the basic concepts in YANG modeling: +

* Remote Procedure (RPCs): In MD-SAL, RPCs are used for any call or
  invocation that crosses the plugin or module boundaries. RPCs are triggered by
  consumers, and usually have return values.
* Notifications: Asynchronous events, published by components for listeners.
* Configuration and Operational Data tree: The well-defined (by model) tree
  structure that represents the operational state of components and systems.
** Instance Identifier: The path that uniquely identifies the sub-tree in the
  configuration or operational space. Most of the addressing of data is done by
  Instance Identifier.

===== RPC

In YANG, remote procedure calls (RPCs) are used to model any procedure call
implemented by a provider (server), which exposes functionality to consumers
(clients).

In MD-SAL terminology, the term 'RPC' is used to define the input and output for
a procedure (function) that is to be provided by a provider, and mediated by the
MD-SAL.

Currently there are following types of RPCs (RPC services): +

// FIXME: Mount point should be defined earlier
* Global: One service instance (implementation) per controller container or
  mount point
* Routed: Multiple service instances (implementations) per controller container
  or mount point

====== Global RPCs service

* There is only one instance of a Global Service per controller instance.
(Note that a controller instance can consist of a cluster of controller nodes.)

*Routing* +

* Binding-Aware MD-SAL (sal-binding)
** **Rpc Type**: Identified by a generated RpcService class and a name of a
method invoked on that interface
* Binding-Independent MD-SAL (sal-dom)
** **Rpc Type**: Identified by a QName

====== Routed service

* There can be multiple instances (implementations) of a service per controller
instance
* Can be used for southbound plugins or for horizontal scaling (load-balancing)
of northbound plugins (services)

*Routing* +

Routing is done based on the contents of a message, for example, 'Node Reference'.
The field in a message that is used for routing is specified in a YANG model by
using the routing-reference statement from the yang-ext model. +

* Binding Aware MD-SAL (sal-binding)
* RPC Type: Identified by an RpcService subclass and the name of the method
  invoked on that interface
* Instance Identifier: In a data tree, identifies the element instance that will
  be used as the route target.

The used class is: +
----
org.opendaylight.yang.binding.InstanceIdentifier
----

The Instance Identifier is learned from the message payload and from the model.+

* Binding Independent MD-SAL (sal-dom)
* RPC Type: Identified by a QName

* Instance Identifier: In a data tree, identifies the element instance that will
 be used as the route target. The used class is: +
----
org.opendaylight.yang.data.api.InstanceIdentifier
----

// Introde section / using and implementing RPCs
RPCs in various API types: +

// FIXME: Inline example in this section
* Java Generated APIs: For each model there is *Service interface.
See https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping#Rpc[YANG Tools: Yang to Java mapping-RPC]  to understand how YANG statements maps to Service interface.
** Providers expose their implementation of *Service by registering their implementation to RpcProviderRegistry.
** Consumers get the *Service implementation from RpcConsumerRegistry. If the implementer uses a different API type, MD-SAL automatically translates data in the background.
* DOM APIs: RPCs are identified by QName.
** Providers expose their implementation of RPC identified by QName registering their RpcImplementation to RpcProvisionRegistry.
** Consumers get the *Service implementation from RpcConsumerRegistry. If the implementer uses different API type, MD-SAL automatically translates data in the background.

// FIXME: Note with link to RESTCONF / NETCONF section.
// * REST APIs: RPCs are identified by the model name and their name.
// * Consumers invoke RPCs by invoking POST operation to /restconf/operations/model-name:rpc-name.

===== Notification
In YANG, Notifications represent asynchronous events, published by providers
for listeners.

RPCs in various API types: +

// FIXME: Inline example in this section
* Java Generated APIs: For each model, there is *Listener interface and transfer
 object for each notification. See https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping#Notification[YANG Tools: Yang to Java mapping-Notification] to understand how YANG statements map to the Notifications interface.
** Providers publish notifications by invoking the publish method on NotificationPublishService.
** To receive notifications, consumers register their implementation of *Listener to NotificationBrokerService. If the notification publisher uses a different API type, MD-SAL automatically translates data in the background.
* DOM APIs: Notifications are represented only by XML Payload.
** Providers publish notifications by invoking the publish method on NotificationPublishService.
** To receive notifications, consumers register their implementation of *Listener to NotificationBrokerService. If the notification publisher uses a different API type, MD-SAL automatically translates data in the background.

// FIXME: Links to RESTCONF / NETCONF section
// * REST APIs: Notifications are currently not supported.

===== Instance Identifier

The Instance Identifier is the unique identifier of an element (location) in the yang data tree: basically, it is the *path* to the node that uniquely identifies all the parent nodes of the node. The unique identification of list elements requires the specification of key values as well.

MD-SAL currently provides three different APIs to access data in the common data store: +

* Binding APIs (Java generated DTOs)
* DOM APIs

// FIXME: Link to external APIs via RESTCONF / NETCONF

*Example* +

Consider the following simple YANG model for inventory: +
----
module inventory {
    namespace "urn:opendaylight:inventory";
    prefix inv;
    revision "2013-06-07";
    container nodes {
        list node {
            key "id";
            leaf "id" {
                type "string";
            }
        }
    }
}
----
*An example having one instance of node with the name _foo_* +

Let us assume that we want to create an instance identifier for the node foo in
the following formats: +

*  **YANG / XML / XPath version**
----
/inv:nodes/inv:node[id="foo"]
----
* **Binding-Aware version (generated APIs)**
----
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.Nodes;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.Node;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.NodeKey;

import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;

InstanceIdentifier<Node> identifier = InstanceIdentifier.builder(Nodes.class).child(Node.class,new NodeKey("foo")).toInstance();
----
NOTE: The last call, _toInstance()_ does not return an instance of the node, but
the Java version of Instance identifier which uniquely identifies the node *foo*.

* **Binding Independent version (yang-data-api)**

[source,java]
----
import org.opendaylight.yang.common.QName;
import org.opendaylight.yang.data.api.InstanceIdentifier;

QName nodes = QName.create("urn:opendaylight:inventory","2013-06-07","nodes");
QName node = QName.create(nodes,"nodes");
QName idName = QName.create(nodes,"id");
InstanceIdentifier = InstanceIdentifier.builder()
    .node(nodes)
    .nodeWithKey(node,idName,"foo")
    .toInstance();
----
NOTE: The last call, _toInstance()_ does not return an instance of node, but the
 Java version of Instance identifier which uniquely identifies the node *foo*.

//FIXME: Is this section necessary?
// Should be probably separate file / examples and may benefit for cross-linking
// joining with tutorials and text from core-tutorials.
=== Development Recommendations
==== MD-SAL: Plugin types
MD-SAL has four component-types that differ in complexity, expose different
models, and use different subsets of the MD-SAL functionality.

* Southbound Protocol Plugin: Responsible for handling multiple sessions to
  the southbound network devices and providing common abstracted interface
  to access various type of functionality provided by these network devices
* Manager-type application: Responsible for managing the state
  and the configuration of a particular functionality which is exposed by
  southbound protocol plugins
* Protocol Library: Responsible for handling serialization or de-serialization
between the wire protocol format and the Java form of the protocol
* Connector Plugin: Responsible for connecting consumers (and providers) to
  the MD-SAL (and other components) by means of different wire protocol
 or set of APIs

===== Southbound protocol plugin

The responsibilities of the Southbound Protocol plugin include the following:

* Handling multiple sessions to southbound network devices
* Providing a common abstracted interface to access various type
  of functionality provided by the network devices

The Southbound Protocol Plugin should be stateless. The only preserved state
(which is still transient) is the list of connected devices or sessions. Models
mostly use RPCs and Notifications to describe plugin functionality
Example plugins: Openflow Southbound Plugin, Netconf Southbound Plugin,
 BGP Southbound Plugin, and PCEP Southbound Plugin.

===== Manager-type application

The responsibilities of the Manager-type applications include the following:

* Providing configuration-like functionality to set or modify the behaviour
of network elements or southbound plugins
* Coordinating flows and provide higher logic on top of stateless southbound plugins

Manager-type Applications preserve state. Models mostly use Configuration
Data and Runtime Data to describe component functionality.

==== Protocol library
The OpenFlow Protocol Library is a component in OpenDaylight, that mediates
communication between the OpenDaylight controller and the hardware devices
supporting the OpenFlow protocol. The primary goal of the library is to provide
user (or upper layers of OpenDaylight) communication channel, that can be used
for managing network hardware devices.

==== MD-SAL: Southbound plugin development guide
The southbound controller plugin is a functional component.

The plugin: +

* Provides an abstraction of network devices functionality
* Normalizes their APIs to common contracts
* Handles session and connections to them

The plugin development process generally moves through the following phases: +

. Definition of YANG models (API contracts): For Model-Driven SAL,
  the API contracts are defined by YANG models and the Java interfaces generated
  for these models. A developers opts for one of the following: +
** Selects from existing models
** Creates new models
** Augments (extends) existing models
[start=2]
. Code Generation: The Java Interfaces, implementation of Transfer Objects,
  and mapping to Binding-Independent form is generated for the plugin.
  This phase requires the proper configuration of the Maven build
  and YANG Maven Tools.
. Implementation of plugin: The actual implementation of the plugin
  functionality and plugin components.

NOTE: The order of steps is not definitive, and it is up to the developer to
find the most suitable workflow. For additional information, see <<_best_practices>>.

===== Definition of YANG models

In this phase, the developer selects from existing models (provided by controller
or other plugins), writes new models, or augments existing ones. A partial list
of available models could be found at:
https://wiki.opendaylight.org/view/YANG_Tools:Available_Models[YANG Tools:Available Models].

The mapping of YANG to Java is documented at: https://wiki.opendaylight.org/view/Yang_Tools:YANG_to_Java_Mapping[Yang Tools:YANG to Java Mapping.] This mapping provides an overview of how YANG is mapped to Java.

Multiple approaches to model the functionality of the southbound plugin are
available: +

* Using RPCs and Notifications
* Using Configuration Data Description
* Using Runtime Data Description
* Combining approaches

===== RPCs

RPCs can model the functionality invoked by consumers (applications) that use
the southbound plugin. Although RPCs can model any functionality, they are usually used to model functionality that cannot be abstracted as configuration data, for example, PacketOut, or initiating a new session to a device (controller-to-device session).

RPCs are modeled with an RPC statement in the following form: +
+rpc foo {}+ +
This statement is mapped to method. +

*RPC input* +
To define RPC input, use an input statement inside RPC. The structure of the
input is defined with the same statements as the structure of notifications,
configuration, and so on.
----
 rpc foo {
    input {
       ...
    }
 }
----
*RPC output* +
To define the RPC output (structure of result), use the RPC output statement. +
----
 rpc foo {
   output {
      ...
   }
 }
----
*Notifications* +
Use notifications to model events originating in a network device or southbound
plugin which is exposed to consumers to listen.


A notification statement defines a notification:
----
   notification foo {
      ...
   }
----
*Configuration data* +

Configuration data is good for the following purposes: +

* Model or provide CRUD access to the state of protocol plugin and/or network
  devices
* Model any functionality which could be exposed as a configuration to the
  consumers or applications

Configuration data in YANG is defined by using the config substatement with
a true argument. For example: +
----
  container foo {
     config true;
     ...
  }
----
*Runtime (read-only) data* +
Runtime (read-only) data is good to model or provide read access to the state
of the protocol plugin and networtk devices, or network devices. This type of data is good to model statistics or any state data, which cannot be modified by the consumers (applications), but needs exposure (for example, learned topology, or list of connected switches).

Runtime data in YANG is defined by using config subsatement with a false argument:
----
  container foo {
     config false;
  }
----
*Structural elements* +
The structure of RPCs, notifications, configuration data, and runtime data is
modelled using structural elements (data schema nodes). Structural elements define the actual structure of XML, DataDOM documents, and Java APIs for accessing or storing these elements. The most commonly used structural elements are: +

* Container
* List
* Leaf
* Leaf-list
* Choice

===== Augmentations +
Augmentations are used to extend existing models by providing additional
structural elements and semantics. Augmentation cannot change the mandatory
status of nodes in the original model, or introduce any new mandatory statements.

===== Best practices

* YANG models must be located under the src/main/yang folder in your project.
* Design your models so that they are reusable and extendible by third-parties.
* Always try to reuse existing models and types provided by these models. See https://wiki.opendaylight.org/view/YANG_Tools:Available_Models[YANG Tools:Available Models] or others if there is no model which provides you with data structures and types you need.

*Code generation* +
To configure your project for code generation, your build system needs to use
Maven. For the configuration of java API generation,
see https://wiki.opendaylight.org/view/Yang_Tools:Maven_Plugin_Guide[Yang Tools:Maven Plugin Guide].

*Artefacts generated at compile time* +
The following artefacts are generated at compile time: +

* Service interfaces
* Transfer object interfaces
* Builders for transfer objects and immutable versions of transfer objects

===== Implementation +
This step uses generated artefacts to implement the intended functionality
of the southbound plugin. +

*Provider implementation* +
To expose functionality through binding-awareness, the MD-SAL plugin needs
to be compiled against these APIs, and must at least implement
the BindingAwareProvider interface. The provider uses APIs which are available
in the SAL-binding-api Maven artifact. To use this dependency, insert the
following dependency into your pom.xml:
----
<dependency>
       <groupId>org.opendaylight.controller</groupId>
       <artifactId>sal-binding-api</artifactId>
       <version>1.0-SNAPSHOT</version>
   </dependency>
----

*BindingAwareProvider implementation* +
A BindingAwareProvider interface requires the implementation of four methods,
and registering an instance with BindingAwareBroker.
Use AbstractBindingAwareProvider to simplify the implementation.

* void onSessionInitialized(ConsumerContext ctx): This callback is called
when Binding-Aware Provider is initialized and ConsumerContext is injected
into it. ConsumerContext serves to access all functionality which the plugin
is to consume from other controller components.
* void onSessionInitialized(ProviderContext ctx): This callback is called when
Binding-Aware Provider is initialized and ProviderContext is injected into it.
ProviderContext serves to access all functionality which the plugin could use
to provide its functionality to controller components.
* Collection<? extends RpcService> getImplementations(): Shorthand registration
  of an already instantiated implementations of global RPC services. Automated
  registration is currently not supported.
* public Collection<? extends ProviderFunctionality> getFunctionality():
  Shorthand registration of an already instantiated implementations
  of ProviderFunctionality. Automated registration is currently not supported.

NOTE: You also need to set your implementation of AbstractBindingAwareProvider
set as Bundle Activator for MD-SAL to properly load it.

===== Notifications
To publish events, request an instance of NotificationProviderService from
ProviderContext. Use the following:

[source,java]
----
   ExampleNotification notification = (new ExampleNotificationBuilder()).build();
   NotificationProviderService notificationProvider = providerContext.getSALService(NotificationProviderService.class);
   notificationProvider.notify(notification);
----

*RPC implementations* +
To implement the functionality exposed as RPCs, implement the generated
RpcService interface. Register the implementation within ProviderContext
included in the provider.

If the generated RpcInterface is FooService, and the implementation is FooServiceImpl:

[source,java]
----
   @Override
   public void onSessionInitiated(ProviderContext context) {
       context.addRpcImplementation(FooService.class, new FooServiceImpl());
   }
----

==== Best practices

RPC Service interface contract requires you to return
http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html[Future object]
(to make it obvious that call may be asynchronous), but it is not specified how
this Future is implemented. Consider using existing implementations provided by
JDK or Google Guava. Implement your own Future only if necessary.

Consider using
http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/SettableFuture.html[SettableFuture]
if you intend not to use http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/FutureTask.html[FutureTask] or submit http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html[Callables] to http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html[ExecutorService].

IMPORTANT: Do not implement transfer object interfaces unless necessary.
Choose already generated builders and immutable versions. If you want to
implement transfer objects, ensure that instances exposed outside the
plugin are immutable.

include::md-sal-faq.adoc
