=== MD-SAL


Model-Driven SAL (MD-SAL) is a set of infrastructure services aimed at providing
common and generic support to application and plugin developers.

The MD-SAL currently provides infrastructure services for the following:

* Data Services
* remote procedure calls (RPC) or Service routing
* Notification subscription and publishing services

This model-driven infrastructure allows developers to develop applications
and plugins against an API type of their choice.
The infrastructure automatically provides the other API types.
The modeling language of choice for MD-SAL is YANG, which is an IETF standard,
for modeling network element configuration. The YANG Tools project and its
development tools provide support for YANG.

MD-SAL provides two different API types: +

* *MD-SAL Binding:* MD-SAL APIs which extensivelly uses APIs and classes generated
  from YANG models, which provides compile-time safety
* *MD-SAL DOM:* (Document Object Model) APIs which uses DOM-like
  represententation of data which is not tied to particular YANG model.
  These APIs are more powerful, but provides less compile-time safety.

NOTE: *MD-SAL DOM APIs* are used by infrastucture components and  allows for
other applications to provide connectors / expose different set of APIs and
derive most of its functionality purely from YANG Model, which all existing
code without modification could benefit from (e.g. RESTCONF,
which is application built on top of MD-SAL and exposes YANG-modeled application
APIs transparently via HTTP and adds support for XML and JSON payload type.)

// FIXME: Add cross-link
NOTE: External APIs for using MD-SAL and MD-SAL enabled components are possible
via NETCONF and RESTCONF

==== Basic concepts and their rendering in APIs

The following are the basic concepts in YANG modeling: +

* *Remote Procedure Call* (RPCs): In MD-SAL, RPCs are used for any call or
  invocation that crosses the plugin or module boundaries. RPCs are triggered by
  consumers, and usually have return values.
* *Notification*: Asynchronous events, published by components for listeners.
* Configuration and Operational *Data tree*: The well-defined (by model) tree
  structure that represents the operational state of components and systems.
** *Instance Identifier*: The path that uniquely identifies the sub-tree in the
  configuration or operational space. Most of the addressing of data is done by
  Instance Identifier.

In addition to these concepts MD-SAL introduces additional concepts

* *Mount Point*: Separate instance of MD-SAL APIs, which may

===== RPC

In YANG, remote procedure calls (RPCs) are used to model any procedure call
implemented by a provider (server), which exposes functionality to consumers
(clients).

In MD-SAL terminology, the term 'RPC' is used to define the input and output for
a procedure (function) that is to be provided by a provider, and mediated by the
MD-SAL.

Currently there are following types of RPCs (RPC services): +

// FIXME: Mount point should be defined earlier
* Global: One service instance (implementation) per controller container or
  mount point
* Routed: Multiple service instances (implementations) per controller container
  or mount point

====== Global RPCs service

* There is only one instance of a Global Service per controller instance.
(Note that a controller instance can consist of a cluster of controller nodes.)

*Routing* +

* Binding-Aware MD-SAL (sal-binding)
** **Rpc Type**: Identified by a generated RpcService class and a name of a
method invoked on that interface
* Binding-Independent MD-SAL (sal-dom)
** **Rpc Type**: Identified by a QName

====== Routed service

* There can be multiple instances (implementations) of a service per controller
instance
* Can be used for southbound plugins or for horizontal scaling (load-balancing)
of northbound plugins (services)

*Routing* +

Routing is done based on the contents of a message, for example, 'Node Reference'.
The field in a message that is used for routing is specified in a YANG model by
using the routing-reference statement from the yang-ext model. +

* Binding Aware MD-SAL (sal-binding)
* RPC Type: Identified by an RpcService subclass and the name of the method
  invoked on that interface
* Instance Identifier: In a data tree, identifies the element instance that will
  be used as the route target.

The used class is: +
----
org.opendaylight.yang.binding.InstanceIdentifier
----

The Instance Identifier is learned from the message payload and from the model.+

* Binding Independent MD-SAL (sal-dom)
* RPC Type: Identified by a QName

* Instance Identifier: In a data tree, identifies the element instance that will
 be used as the route target. The used class is: +
----
org.opendaylight.yang.data.api.InstanceIdentifier
----

// Introde section / using and implementing RPCs
RPCs in various API types: +

// FIXME: Inline example in this section
* Java Generated APIs: For each model there is *Service interface.
See https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping#Rpc[YANG Tools: Yang to Java mapping-RPC]  to understand how YANG statements maps to Service interface.
** Providers expose their implementation of *Service by registering their implementation to RpcProviderRegistry.
** Consumers get the *Service implementation from RpcConsumerRegistry. If the implementer uses a different API type, MD-SAL automatically translates data in the background.
* DOM APIs: RPCs are identified by QName.
** Providers expose their implementation of RPC identified by QName registering their RpcImplementation to RpcProvisionRegistry.
** Consumers get the *Service implementation from RpcConsumerRegistry. If the implementer uses different API type, MD-SAL automatically translates data in the background.

// FIXME: Note with link to RESTCONF / NETCONF section.
// * REST APIs: RPCs are identified by the model name and their name.
// * Consumers invoke RPCs by invoking POST operation to /restconf/operations/model-name:rpc-name.

===== Notification
In YANG, Notifications represent asynchronous events, published by providers
for listeners.

RPCs in various API types: +

// FIXME: Inline example in this section
* Java Generated APIs: For each model, there is *Listener interface and transfer
 object for each notification. See https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping#Notification[YANG Tools: Yang to Java mapping-Notification] to understand how YANG statements map to the Notifications interface.
** Providers publish notifications by invoking the publish method on NotificationPublishService.
** To receive notifications, consumers register their implementation of *Listener to NotificationBrokerService. If the notification publisher uses a different API type, MD-SAL automatically translates data in the background.
* DOM APIs: Notifications are represented only by XML Payload.
** Providers publish notifications by invoking the publish method on NotificationPublishService.
** To receive notifications, consumers register their implementation of *Listener to NotificationBrokerService. If the notification publisher uses a different API type, MD-SAL automatically translates data in the background.

// FIXME: Links to RESTCONF / NETCONF section
// * REST APIs: Notifications are currently not supported.

===== Instance Identifier

The Instance Identifier is the unique identifier of an element (location) in the yang data tree: basically, it is the *path* to the node that uniquely identifies all the parent nodes of the node. The unique identification of list elements requires the specification of key values as well.

MD-SAL currently provides three different APIs to access data in the common data store: +

* Binding APIs (Java generated DTOs)
* DOM APIs

// FIXME: Link to external APIs via RESTCONF / NETCONF

*Example* +

Consider the following simple YANG model for inventory: +
----
module inventory {
    namespace "urn:opendaylight:inventory";
    prefix inv;
    revision "2013-06-07";
    container nodes {
        list node {
            key "id";
            leaf "id" {
                type "string";
            }
        }
    }
}
----
*An example having one instance of node with the name _foo_* +

Let us assume that we want to create an instance identifier for the node foo in
the following formats: +

*  **YANG / XML / XPath version**
----
/inv:nodes/inv:node[id="foo"]
----
* **Binding-Aware version (generated APIs)**
----
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.Nodes;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.Node;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.NodeKey;

import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;

InstanceIdentifier<Node> identifier = InstanceIdentifier.builder(Nodes.class).child(Node.class,new NodeKey("foo")).toInstance();
----
NOTE: The last call, _toInstance()_ does not return an instance of the node, but
the Java version of Instance identifier which uniquely identifies the node *foo*.

* **Binding Independent version (yang-data-api)**

[source,java]
----
import org.opendaylight.yang.common.QName;
import org.opendaylight.yang.data.api.YangInstanceIdentifier;

QName nodes = QName.create("urn:opendaylight:inventory","2013-06-07","nodes");
QName node = QName.create(nodes,"nodes");
QName idName = QName.create(nodes,"id");
YangInstanceIdentifier identifier = YangInstanceIdentifier.builder()
    .node(nodes)
    .nodeWithKey(node,idName,"foo")
    .toInstance();
----
NOTE: The last call, _toInstance()_ does not return an instance of node, but the
 Java version of Instance identifier which uniquely identifies the node *foo*.


include::md-sal-faq.adoc
