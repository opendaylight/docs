// Source: https://ask.opendaylight.org/question/99/how-does-request-routing-works/
=== MD-SAL RPC Routing

MD-SAL provides capability to model and use content-based RPC routing
defined by loaded YANG models. RPCs are delivered to instance of implementation
based on content of RPC input, which contains routing information
(context reference).

MD-SAL does not dictate name of leaf which is used for RPC routing, but provides
necessary functionality for YANG model author to define this in their model
of RPCs.

MD-SAL routing behavior is modeled using following terminology and its
application to YANG models:

Context Type::
  Logical type of RPC routing. Context type is modeled as YANG `identity`
  and is referenced in model to provide scoping information.
Context Instance::
  Conceptual location in data tree, which represents context in which RPC
  could be executed. Context instance usually represent logical point
  to which RPC execution is attached.
Context Reference::
  Field of RPC input payload which contains Instance Identifier referencing
  *Context Instance*  in which RPC should be executed.


==== Modeling of routed RPC

In order to define routed RPCs, YANG model author needs to declare (or reuse)
_context type_, set of possible _context instances_ and finally RPCs which
will contain _context reference_ on which they will be routed.

===== Declaration of routing context type

[source,yang]
----
  identity node-context {
      description "Identity used to mark node context";
  }
----

line 39, declares identity named `node-context`, which is used as marker
for node-based routing and is used at other places to reference that
routing type.

===== Declaration of possible context instances

In order for defining possible values of context instances for routed RPCs,
we need to model that set accordingly using `context-instance` extension from
`yang-ext` model.

[source,yang]
----
import yang-ext { prefix ext; }

/** Base structure **/
container nodes {
    list node {
        key "id";
        ext:context-instance "node-context";
        uses node;
    }
}
----


Statement `ext:context-instance "node-context";` marks any instance of
`list node` as possible valid context instance in `node-context` based routing.

NOTE: Existence of context instance node in operational or config data tree
is not strongly tied to existence of RPC. This is not enforced by MD-SAL,
but rather needs to be documented in YANG models.

===== Declaration of Routed RPC

To declare RPC to be routed based on `node-context` we need to add leaf
of `instance-identifier` type (or type derived from `instance-identifier`)
to the RPC and mark it as *Context reference*.

This is achieved using YANG extension `context-reference` from `yang-ext` model
on leaf, which will be used for RPC routing.

[source,yang]
----
rpc example-routed-rpc  {
    input {
        leaf node {
            ext:context-reference "node-context";
            type "instance-identifier";
        }
    }
}
----

Statement `ext:context-reference "node-context"` marks `leaf node` as
_context reference_ of type `node-context`. Value of this leaf, will be used
by MD-SAL to select RPC implementation, which registered itself as implementation
of RPC for particular _context instance_.


==== Using Routed RPCs

NOTE: From user perspective (one invoking RPCs) there is no difference between
routed and non-routed RPCs. Routing information is just additional leaf in
RPC which needs to have value.

// TODO: Add simple snippet of invoking such RPC even if it does not differ
// from normal one.

==== Implementation of Routed RPC

// TODO: Update this section to show some other example model
// along with binding and DOM implementations

Implementation

===== Registering implementations

// FIXME: Clean up bit wording in following section, use different example

Implementations of that RPC (southbound plugins) will specify
instance-identifier for node for which they want to provide this
implementation during registration and consumers are required to specify
that instance-identifier (identifier of node) when invoking RPC.

Simple code which showcases that for add-flow via Binding-Aware APIs
(https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=blob;f=opendaylight/md-sal/sal-binding-it/src/test/java/org/opendaylight/controller/test/sal/binding/it/RoutedServiceTest.java;h=d49d6f0e25e271e43c8550feb5eef63d96301184;hb=HEAD[RoutedServiceTest.java]
):

[source, java]
----
  61             @Override
  62             public void onSessionInitiated(ProviderContext session) {
  63                 assertNotNull(session);
  64                 firstReg = session.addRoutedRpcImplementation(SalFlowService.class, salFlowService1);
  65             }
----
Line 64: We are registering salFlowService1 as implementation of
SalFlowService RPC

[source, java]
----
  107         NodeRef nodeOne = createNodeRef("foo:node:1");
  109         /**
  110          * Provider 1 registers path of node 1
  111          */
  112         firstReg.registerPath(NodeContext.class, nodeOne);
----

Line 107: We are creating NodeRef (encapsulation of InstanceIdentifier)
for "foo:node:1". Line 112: We register salFlowService1 as
implementation for nodeOne.

The salFlowService1 will be executed only for RPCs which contains
Instance Identifeir for foo:node:1.
