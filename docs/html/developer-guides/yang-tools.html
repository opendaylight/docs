
<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>YANG Tools Developer Guide &#8212; OpenDaylight Documentation Chromium documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css?v=0bf093e7" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.11.2/css/jquery.dataTables.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/ribbon.css?v=cb953b18" />
    <link rel="stylesheet" href="../_static/css/warning-header.css" type="text/css" />
    <script src="../_static/documentation_options.js?v=7b4a4459"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="https://cdn.datatables.net/1.11.2/js/jquery.dataTables.min.js"></script>
    <script class="init" type="text/javascript">$(document).ready( function () { $('table.datatable').DataTable(); } );</script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Documentation Guide" href="../documentation.html" />
    <link rel="prev" title="ODL Parent Developer Guide" href="odl-parent-developer-guide.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>

  </head><body>
  <div class="ribbon">
    <a href="https://jira.opendaylight.org/secure/CreateIssueDetails!init.jspa
?pid=10121
&issuetype=10104
&components=10228
&priority=2
&description=version:+Chromium%0Apage:+developer-guides/yang-tools%0A%0A" target="_blank">
      Report Issue
    </a>
  </div>
  

<div id="navbar" class="navbar navbar-default navbar-fixed-top">
  <!-- Outdated version warning banner -->
  
    <style>
      body {
        padding-top: 60px;
     }
    </style>
  
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          OpenDaylight Documentation</a>
        <span class="navbar-text navbar-version pull-left"><b>Chromium</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../downloads.html">OpenDaylight Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started-guide/index.html">Getting Started Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../documentation.html">Documentation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-process/index.html">OpenDaylight Release Process Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../javadoc.html">Java API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-guide/index.html">OpenDaylight User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributor-guides/index.html">Contributor Guides</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">YANG Tools Developer Guide</a><ul>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#architecture">Architecture</a></li>
<li><a class="reference internal" href="#concepts">Concepts</a></li>
<li><a class="reference internal" href="#components">Components</a><ul>
<li><a class="reference internal" href="#yang-model-api">YANG Model API</a></li>
<li><a class="reference internal" href="#yang-parser">YANG Parser</a></li>
<li><a class="reference internal" href="#yang-data-api">YANG data API</a></li>
<li><a class="reference internal" href="#yang-data-codecs">YANG data Codecs</a></li>
<li><a class="reference internal" href="#yang-maven-plugin">YANG Maven Plugin</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-tutorials">How to / Tutorials</a><ul>
<li><a class="reference internal" href="#working-with-yang-model">Working with YANG Model</a></li>
<li><a class="reference internal" href="#working-with-yang-data">Working with YANG data</a></li>
<li><a class="reference internal" href="#serialization-deserialization-of-yang-data">Serialization / deserialization of YANG data</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">YANG Tools Developer Guide</a><ul>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#architecture">Architecture</a></li>
<li><a class="reference internal" href="#concepts">Concepts</a></li>
<li><a class="reference internal" href="#components">Components</a><ul>
<li><a class="reference internal" href="#yang-model-api">YANG Model API</a></li>
<li><a class="reference internal" href="#yang-parser">YANG Parser</a></li>
<li><a class="reference internal" href="#yang-data-api">YANG data API</a></li>
<li><a class="reference internal" href="#yang-data-codecs">YANG data Codecs</a></li>
<li><a class="reference internal" href="#yang-maven-plugin">YANG Maven Plugin</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-tutorials">How to / Tutorials</a><ul>
<li><a class="reference internal" href="#working-with-yang-model">Working with YANG Model</a></li>
<li><a class="reference internal" href="#working-with-yang-data">Working with YANG data</a></li>
<li><a class="reference internal" href="#serialization-deserialization-of-yang-data">Serialization / deserialization of YANG data</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<center>
<div class="btn-group" role="group" aria-label="...">
    
    <a class="btn btn-default" href="odl-parent-developer-guide.html">Prev Page</a>
    

    
    <a class="btn btn-default" href="../documentation.html">Next Page</a>
    
</div>
</center>
        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <section id="yang-tools-developer-guide">
<span id="yangtools-developer-guide"></span><h1>YANG Tools Developer Guide<a class="headerlink" href="#yang-tools-developer-guide" title="Link to this heading">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>YANG Tools is set of libraries and tooling providing support for use
<a class="reference external" href="https://tools.ietf.org/html/rfc6020">YANG</a> for Java (or other
JVM-based language) projects and applications. The YANG Tools provides
following features in OpenDaylight:</p>
<ul class="simple">
<li><p>Parsing of YANG sources and semantic inference of relationship across
YANG models as defined in
<a class="reference external" href="https://tools.ietf.org/html/rfc6020">RFC6020</a></p></li>
<li><p>Representation of YANG-modeled data in Java</p>
<ul>
<li><p><strong>Normalized Node</strong> representation - DOM-like tree model, which
uses conceptual meta-model more tailored to YANG and OpenDaylight
use-cases than a standard XML DOM model allows for.</p></li>
</ul>
</li>
<li><p>Serialization / deserialization of YANG-modeled data driven by YANG
models</p>
<ul>
<li><p>XML - as defined in
<a class="reference external" href="https://tools.ietf.org/html/rfc6020">RFC6020</a></p></li>
<li><p>JSON - as defined in
<a class="reference external" href="https://tools.ietf.org/html/rfc6020">draft-lhotka-netmod-yang-json-01</a></p></li>
<li><p>Support for third-party generators processing YANG models.</p></li>
</ul>
</li>
</ul>
<section id="architecture">
<h3>Architecture<a class="headerlink" href="#architecture" title="Link to this heading">¶</a></h3>
<p>YANG tools consist of the following logical subsystems:</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text"><strong>YANG Tools</strong></span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 28.6%" />
<col style="width: 71.4%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tool</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Commons</strong></p></td>
<td><p>Set of general purpose code, which is not specific to
YANG, but is also useful outside YANG Tools implementation.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>YANG Model and Parser</strong></p></td>
<td><p>YANG semantic model and lexical and
semantic parser of YANG models, which creates in-memory
cross-referenced representation of YANG models, which is used by other
components to determine their behavior based on the model.</p></td>
</tr>
<tr class="row-even"><td><p><strong>YANG data</strong></p></td>
<td><p>Definition of Normalized Node APIs and Data Tree
APIs, reference implementation of these APIs and implementation of
XML and JSON codecs for Normalized Nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>YANG Maven Plugin</strong></p></td>
<td><p>Maven plugin which integrates YANG parser
into Maven build life-cycle and provides code-generation framework for
components, which wants to generate code or other artefacts based on YANG model.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="concepts">
<h3>Concepts<a class="headerlink" href="#concepts" title="Link to this heading">¶</a></h3>
<p>Project defines base concepts and helper classes which are
project-agnostic and could be used outside of YANG Tools project scope.</p>
</section>
<section id="components">
<h3>Components<a class="headerlink" href="#components" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">yang-common</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-data-api</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-data-codec-gson</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-data-codec-xml</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-data-impl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-data-jaxen</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-data-transform</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-data-util</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-maven-plugin</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-maven-plugin-it</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-maven-plugin-spi</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-model-api</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-model-export</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-model-util</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-parser-api</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yang-parser-impl</span></code></p></li>
</ul>
<section id="yang-model-api">
<h4>YANG Model API<a class="headerlink" href="#yang-model-api" title="Link to this heading">¶</a></h4>
<p>Class diagram of yang model API</p>
<figure class="align-default" id="id2">
<img alt="../_images/yang-model-api.png" src="../_images/yang-model-api.png" />
<figcaption>
<p><span class="caption-text">YANG Model API</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="yang-parser">
<h4>YANG Parser<a class="headerlink" href="#yang-parser" title="Link to this heading">¶</a></h4>
<p>YANG Statement Parser works on the idea of statement concepts as defined
in RFC6020, section 6.3. We come up here with basic ModelStatement and
StatementDefinition, following RFC6020 idea of having sequence of
statements, where every statement contains keyword and zero or one
argument. ModelStatement is extended by DeclaredStatement (as it comes
from source, e.g. YANG source) and EffectiveStatement, which contains
other sub-statements and tends to represent result of semantic processing
of other statements (uses, augment for YANG). IdentifierNamespace
represents common superclass for YANG model namespaces.</p>
<p>Input of the YANG Statement Parser is a collection of
StatementStreamSource objects. StatementStreamSource interface is used
for inference of effective model and is required to emit its statements
using supplied StatementWriter. Each source (e.g. YANG source) has to be
processed in three steps in order to emit different statements for each
step. This package provides support for various namespaces used across
statement parser in order to map relations during declaration phase
process.</p>
<p>Currently, there are two implementations of StatementStreamSource in
YANGtools:</p>
<ul class="simple">
<li><p>YangStatementSourceImpl - intended for yang sources</p></li>
<li><p>YinStatementSourceImpl - intended for yin sources</p></li>
</ul>
</section>
<section id="yang-data-api">
<h4>YANG data API<a class="headerlink" href="#yang-data-api" title="Link to this heading">¶</a></h4>
<p>Class diagram of yang data API</p>
<figure class="align-default" id="id3">
<img alt="../_images/yang-data-api.png" src="../_images/yang-data-api.png" />
<figcaption>
<p><span class="caption-text">YANG data API</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="yang-data-codecs">
<h4>YANG data Codecs<a class="headerlink" href="#yang-data-codecs" title="Link to this heading">¶</a></h4>
<p>Codecs which enable serialization of NormalizedNodes into YANG-modeled
data in XML or JSON format and deserialization of YANG-modeled data in
XML or JSON format into NormalizedNodes.</p>
</section>
<section id="yang-maven-plugin">
<h4>YANG Maven Plugin<a class="headerlink" href="#yang-maven-plugin" title="Link to this heading">¶</a></h4>
<p>Maven plugin which integrates YANG parser into Maven build life-cycle and
provides code-generation framework for components, which wants to
generate code or other artefacts based on YANG model.</p>
</section>
</section>
</section>
<section id="how-to-tutorials">
<h2>How to / Tutorials<a class="headerlink" href="#how-to-tutorials" title="Link to this heading">¶</a></h2>
<section id="working-with-yang-model">
<h3>Working with YANG Model<a class="headerlink" href="#working-with-yang-model" title="Link to this heading">¶</a></h3>
<p>First thing you need to do if you want to work with YANG models is to
instantiate a SchemaContext object. This object type describes one or
more parsed YANG modules.</p>
<p>In order to create it you need to utilize YANG statement parser which
takes one or more StatementStreamSource objects as input and then
produces the SchemaContext object.</p>
<p>StatementStreamSource object contains the source file information. It
has two implementations, one for YANG sources - YangStatementSourceImpl,
and one for YIN sources - YinStatementSourceImpl.</p>
<p>Here is an example of creating StatementStreamSource objects for YANG
files, providing them to the YANG statement parser and building the
SchemaContext:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">StatementStreamSource</span><span class="w"> </span><span class="n">yangModuleSource</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">YangStatementSourceImpl</span><span class="p">(</span><span class="s">&quot;/example.yang&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="n">StatementStreamSource</span><span class="w"> </span><span class="n">yangModuleSource2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">YangStatementSourceImpl</span><span class="p">(</span><span class="s">&quot;/example2.yang&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>

<span class="n">CrossSourceStatementReactor</span><span class="p">.</span><span class="na">BuildAction</span><span class="w"> </span><span class="n">reactor</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">YangInferencePipeline</span><span class="p">.</span><span class="na">RFC6020_REACTOR</span><span class="p">.</span><span class="na">newBuild</span><span class="p">();</span>
<span class="n">reactor</span><span class="p">.</span><span class="na">addSources</span><span class="p">(</span><span class="n">yangModuleSource</span><span class="p">,</span><span class="w"> </span><span class="n">yangModuleSource2</span><span class="p">);</span>

<span class="n">SchemaContext</span><span class="w"> </span><span class="n">schemaContext</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">reactor</span><span class="p">.</span><span class="na">buildEffective</span><span class="p">();</span>
</pre></div>
</div>
<p>First, StatementStreamSource objects with two constructor arguments
should be instantiated: path to the yang source file (which is a regular
String object) and a Boolean which determines if the path is absolute or
relative.</p>
<p>Next comes the initiation of new yang parsing cycle - which is
represented by CrossSourceStatementReactor.BuildAction object. You can
get it by calling method <code class="docutils literal notranslate"><span class="pre">newBuild()</span></code> on CrossSourceStatementReactor
object (RFC6020_REACTOR) in YangInferencePipeline class.</p>
<p>Then you should feed yang sources to it by calling method <code class="docutils literal notranslate"><span class="pre">addSources()</span></code>
that takes one or more StatementStreamSource objects as arguments.</p>
<p>Finally, you call the method <code class="docutils literal notranslate"><span class="pre">buildEffective()</span></code> on the reactor object which
returns <code class="docutils literal notranslate"><span class="pre">EffectiveSchemaContext</span></code> (that is a concrete implementation of
<code class="docutils literal notranslate"><span class="pre">SchemaContext</span></code>). Now you are ready to work with contents of the added
YANG sources.</p>
<p>Let us explain how to work with models contained in the newly created
<code class="docutils literal notranslate"><span class="pre">SchemaContext</span></code>. If you want to get all the modules in the <code class="docutils literal notranslate"><span class="pre">schemaContext</span></code>,
you have to call method <code class="docutils literal notranslate"><span class="pre">getModules()</span></code> which returns a Set of modules. If
you want to get all the data definitions in <code class="docutils literal notranslate"><span class="pre">schemaContext</span></code>, you need to
call method <code class="docutils literal notranslate"><span class="pre">getDataDefinitions</span></code>, etc.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Module</span><span class="o">&gt;</span><span class="w"> </span><span class="n">modules</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">schemaContext</span><span class="p">.</span><span class="na">getModules</span><span class="p">();</span>
<span class="n">Set</span><span class="o">&lt;</span><span class="n">DataSchemaNodes</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dataSchemaNodes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">schemaContext</span><span class="p">.</span><span class="na">getDataDefinitions</span><span class="p">();</span>
</pre></div>
</div>
<p>Usually you want to access specific modules. Getting a concrete module
from SchemaContext is a matter of calling one of these methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">findModuleByName()</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findModuleByNamespace()</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findModuleByNamespaceAndRevision()</span></code>.</p></li>
</ul>
<p>In the first case, you need to provide module name as it is defined in
the yang source file and module revision date if it specified in the
yang source file (if it is not defined, you can just pass a null value).
In order to provide the revision date in proper format, you can use a
utility class named SimpleDateFormatUtil.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Module</span><span class="w"> </span><span class="n">exampleModule</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">schemaContext</span><span class="p">.</span><span class="na">findModuleByName</span><span class="p">(</span><span class="s">&quot;example-module&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>
<span class="c1">// or</span>
<span class="n">Date</span><span class="w"> </span><span class="n">revisionDate</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SimpleDateFormatUtil</span><span class="p">.</span><span class="na">getRevisionFormat</span><span class="p">().</span><span class="na">parse</span><span class="p">(</span><span class="s">&quot;2015-09-02&quot;</span><span class="p">);</span>
<span class="n">Module</span><span class="w"> </span><span class="n">exampleModule</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">schemaContext</span><span class="p">.</span><span class="na">findModuleByName</span><span class="p">(</span><span class="s">&quot;example-module&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">revisionDate</span><span class="p">);</span>
</pre></div>
</div>
<p>In the second case, you have to provide module namespace in form of an
URI object.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Module</span><span class="w"> </span><span class="n">exampleModule</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">schema</span><span class="p">.</span><span class="na">findModuleByNamespace</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">URI</span><span class="p">(</span><span class="s">&quot;opendaylight.org/example-module&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>In the third case, you provide both module namespace and revision date
as arguments.</p>
<p>Once you have a Module object, you can access its contents as they are
defined in YANG Model API. One way to do this is to use method like
<code class="docutils literal notranslate"><span class="pre">getIdentities()</span></code> or <code class="docutils literal notranslate"><span class="pre">getRpcs()</span></code> which will give you a Set of objects.
Otherwise you can access a DataSchemaNode directly via the method
<code class="docutils literal notranslate"><span class="pre">getDataChildByName()</span></code> which takes a <code class="docutils literal notranslate"><span class="pre">QName</span></code> object as its only argument.
Here are a few examples.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Set</span><span class="o">&lt;</span><span class="n">AugmentationSchema</span><span class="o">&gt;</span><span class="w"> </span><span class="n">augmentationSchemas</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exampleModule</span><span class="p">.</span><span class="na">getAugmentations</span><span class="p">();</span>
<span class="n">Set</span><span class="o">&lt;</span><span class="n">ModuleImport</span><span class="o">&gt;</span><span class="w"> </span><span class="n">moduleImports</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">exampleModule</span><span class="p">.</span><span class="na">getImports</span><span class="p">();</span>

<span class="n">ChoiceSchemaNode</span><span class="w"> </span><span class="n">choiceSchemaNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">ChoiceSchemaNode</span><span class="p">)</span><span class="w"> </span><span class="n">exampleModule</span><span class="p">.</span><span class="na">getDataChildByName</span><span class="p">(</span><span class="n">QName</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="n">exampleModule</span><span class="p">.</span><span class="na">getQNameModule</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;example-choice&quot;</span><span class="p">));</span>

<span class="n">ContainerSchemaNode</span><span class="w"> </span><span class="n">containerSchemaNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">ContainerSchemaNode</span><span class="p">)</span><span class="w"> </span><span class="n">exampleModule</span><span class="p">.</span><span class="na">getDataChildByName</span><span class="p">(</span><span class="n">QName</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="n">exampleModule</span><span class="p">.</span><span class="na">getQNameModule</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;example-container&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>The YANG statement parser can work in three modes:</p>
<ul class="simple">
<li><p>default mode</p></li>
<li><p>mode with active resolution of if-feature statements</p></li>
<li><p>mode with active semantic version processing</p></li>
</ul>
<p>The default mode is active when you initialize the parsing cycle as
usual by calling the method <code class="docutils literal notranslate"><span class="pre">newBuild()</span></code> without passing any arguments to
it. The second and third mode can be activated by invoking the <code class="docutils literal notranslate"><span class="pre">newBuild()</span></code>
with a special argument. You can either activate just one of
them or both by passing proper arguments. Let us explain how these modes
work.</p>
<p>Mode with active resolution of if-features makes yang statements
containing an if-feature statement conditional based on the supported
features. These features are provided in the form of a <code class="docutils literal notranslate"><span class="pre">QName-based</span></code>
<code class="docutils literal notranslate"><span class="pre">java.util.Set</span></code> object. In the example below, only two
features are supported: example-feature-1 and example-feature-2. The
Set which contains this information is passed to the method
<code class="docutils literal notranslate"><span class="pre">newBuild()</span></code> and the mode is activated.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Set</span><span class="o">&lt;</span><span class="n">QName</span><span class="o">&gt;</span><span class="w"> </span><span class="n">supportedFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="p">.</span><span class="na">of</span><span class="p">(</span>
<span class="w">    </span><span class="n">QName</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="s">&quot;example-namespace&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2016-08-31&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;example-feature-1&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">QName</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="s">&quot;example-namespace&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2016-08-31&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;example-feature-2&quot;</span><span class="p">));</span>

<span class="n">CrossSourceStatementReactor</span><span class="p">.</span><span class="na">BuildAction</span><span class="w"> </span><span class="n">reactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YangInferencePipeline</span><span class="p">.</span><span class="na">RFC6020_REACTOR</span><span class="p">.</span><span class="na">newBuild</span><span class="p">(</span><span class="n">supportedFeatures</span><span class="p">);</span>
</pre></div>
</div>
<p>In case when no features should be supported, you should provide an
empty <code class="docutils literal notranslate"><span class="pre">Set&lt;QName&gt;</span></code> object.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">Set</span><span class="o">&lt;</span><span class="n">QName</span><span class="o">&gt;</span><span class="w"> </span><span class="n">supportedFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="p">.</span><span class="na">of</span><span class="p">();</span>

<span class="n">CrossSourceStatementReactor</span><span class="p">.</span><span class="na">BuildAction</span><span class="w"> </span><span class="n">reactor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YangInferencePipeline</span><span class="p">.</span><span class="na">RFC6020_REACTOR</span><span class="p">.</span><span class="na">newBuild</span><span class="p">(</span><span class="n">supportedFeatures</span><span class="p">);</span>
</pre></div>
</div>
<p>When this mode is not activated, all features in the processed YANG
sources are supported.</p>
<p>Mode with active semantic version processing changes the way how YANG
import statements work - each module import is processed based on the
specified semantic version statement and the revision-date statement is
ignored. In order to activate this mode, you have to provide
StatementParserMode.SEMVER_MODE enum constant as argument to the method
<code class="docutils literal notranslate"><span class="pre">newBuild()</span></code>.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">CrossSourceStatementReactor</span><span class="p">.</span><span class="na">BuildAction</span><span class="w"> </span><span class="n">reactor</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">YangInferencePipeline</span><span class="p">.</span><span class="na">RFC6020_REACTOR</span><span class="p">.</span><span class="na">newBuild</span><span class="p">(</span><span class="n">StatementParserMode</span><span class="p">.</span><span class="na">SEMVER_MODE</span><span class="p">);</span>
</pre></div>
</div>
<p>Before you use a semantic version statement in a YANG module, you need
to define an extension for it so that the YANG statement parser can
recognize it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">semantic</span><span class="o">-</span><span class="n">version</span> <span class="p">{</span>
    <span class="n">namespace</span> <span class="s2">&quot;urn:opendaylight:yang:extension:semantic-version&quot;</span><span class="p">;</span>
    <span class="n">prefix</span> <span class="n">sv</span><span class="p">;</span>
    <span class="n">yang</span><span class="o">-</span><span class="n">version</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">revision</span> <span class="mi">2016</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">02</span> <span class="p">{</span>
        <span class="n">description</span> <span class="s2">&quot;Initial version&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sv</span><span class="p">:</span><span class="n">semantic</span><span class="o">-</span><span class="n">version</span> <span class="s2">&quot;0.0.1&quot;</span><span class="p">;</span>

    <span class="n">extension</span> <span class="n">semantic</span><span class="o">-</span><span class="n">version</span> <span class="p">{</span>
        <span class="n">argument</span> <span class="s2">&quot;semantic-version&quot;</span> <span class="p">{</span>
            <span class="n">yin</span><span class="o">-</span><span class="n">element</span> <span class="n">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example above, you see a YANG module which defines semantic
version as an extension. This extension can be imported to other modules
in which we want to utilize the semantic versioning concept.</p>
<p>Below is a simple example of the semantic versioning usage. With
semantic version processing mode being active, the foo module imports
the bar module based on its semantic version. Notice how both modules
import the module with the semantic-version extension.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="n">namespace</span> <span class="n">foo</span><span class="p">;</span>
    <span class="n">prefix</span> <span class="n">foo</span><span class="p">;</span>
    <span class="n">yang</span><span class="o">-</span><span class="n">version</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">semantic</span><span class="o">-</span><span class="n">version</span> <span class="p">{</span> <span class="n">prefix</span> <span class="n">sv</span><span class="p">;</span> <span class="n">revision</span><span class="o">-</span><span class="n">date</span> <span class="mi">2016</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">02</span><span class="p">;</span> <span class="n">sv</span><span class="p">:</span><span class="n">semantic</span><span class="o">-</span><span class="n">version</span> <span class="s2">&quot;0.0.1&quot;</span><span class="p">;</span> <span class="p">}</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">bar</span> <span class="p">{</span> <span class="n">prefix</span> <span class="n">bar</span><span class="p">;</span> <span class="n">sv</span><span class="p">:</span><span class="n">semantic</span><span class="o">-</span><span class="n">version</span> <span class="s2">&quot;0.1.2&quot;</span><span class="p">;}</span>

    <span class="n">revision</span> <span class="s2">&quot;2016-02-01&quot;</span> <span class="p">{</span>
        <span class="n">description</span> <span class="s2">&quot;Initial version&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sv</span><span class="p">:</span><span class="n">semantic</span><span class="o">-</span><span class="n">version</span> <span class="s2">&quot;0.1.1&quot;</span><span class="p">;</span>

    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">bar</span> <span class="p">{</span>
    <span class="n">namespace</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">prefix</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">yang</span><span class="o">-</span><span class="n">version</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">semantic</span><span class="o">-</span><span class="n">version</span> <span class="p">{</span> <span class="n">prefix</span> <span class="n">sv</span><span class="p">;</span> <span class="n">revision</span><span class="o">-</span><span class="n">date</span> <span class="mi">2016</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">02</span><span class="p">;</span> <span class="n">sv</span><span class="p">:</span><span class="n">semantic</span><span class="o">-</span><span class="n">version</span> <span class="s2">&quot;0.0.1&quot;</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">revision</span> <span class="s2">&quot;2016-01-01&quot;</span> <span class="p">{</span>
        <span class="n">description</span> <span class="s2">&quot;Initial version&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sv</span><span class="p">:</span><span class="n">semantic</span><span class="o">-</span><span class="n">version</span> <span class="s2">&quot;0.1.2&quot;</span><span class="p">;</span>

    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Every semantic version must have the following form: x.y.z. The x
corresponds to a major version, the y corresponds to a minor version and
the z corresponds to a patch version. If no semantic version is
specified in a module or an import statement, then the default one is
used - 0.0.0.</p>
<p>A major version number of 0 indicates that the model is still in
development and is subject to change.</p>
<p>Following a release of major version 1, all modules will increment major
version number when backwards incompatible changes to the model are
made.</p>
<p>The minor version is changed when features are added to the model that
do not impact current clients use of the model.</p>
<p>The patch version is incremented when non-feature changes (such as
bugfixes or clarifications of human-readable descriptions that do not
impact model functionality) are made that maintain backwards
compatibility.</p>
<p>When importing a module with activated semantic version processing mode,
only the module with the newest (highest) compatible semantic version is
imported. Two semantic versions are compatible when all of the following
conditions are met:</p>
<ul class="simple">
<li><p>the major version in the import statement and major version in the
imported module are equal. For instance, 1.5.3 is compatible with
1.5.3, 1.5.4, 1.7.2, etc., but it is not compatible with 0.5.2 or
2.4.8, etc.</p></li>
<li><p>the combination of minor version and patch version in the import
statement is not higher than the one in the imported module. For
instance, 1.5.2 is compatible with 1.5.2, 1.5.4, 1.6.8 etc. In fact,
1.5.2 is also compatible with versions like 1.5.1, 1.4.9 or 1.3.7 as
they have equal major version. However, they will not be imported
because their minor and patch version are lower (older).</p></li>
</ul>
<p>If the import statement does not specify a semantic version, then the
default one is chosen - 0.0.0. Thus, the module is imported only if it
has a semantic version compatible with the default one, for example
0.0.0, 0.1.3, 0.3.5 and so on.</p>
</section>
<section id="working-with-yang-data">
<h3>Working with YANG data<a class="headerlink" href="#working-with-yang-data" title="Link to this heading">¶</a></h3>
<p>If you want to work with YANG data, you are going to need NormalizedNode
objects that are specified in the YANG data API. NormalizedNode is an
interface at the top of the YANG data hierarchy. It is extended through
sub-interfaces which define the behavior of specific NormalizedNode
types like AnyXmlNode, ChoiceNode, LeafNode, ContainerNode, etc.
Concrete implementations of these interfaces are defined in
<code class="docutils literal notranslate"><span class="pre">yang-data-impl</span></code> module. Once you have one or more NormalizedNode
instances, you can perform CRUD operations on YANG data tree which is an
in-memory database designed to store normalized nodes in a tree-like
structure.</p>
<p>In some cases it, is clear which NormalizedNode type belongs to which
yang statement (e.g. AnyXmlNode, ChoiceNode, LeafNode). However, there
are some normalized nodes which are named differently from their yang
counterparts. They are listed below:</p>
<table class="docutils align-default" id="id4">
<caption><span class="caption-text"><strong>Normalized Nodes</strong></span><a class="headerlink" href="#id4" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Node</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>LeafSetNode</strong></p></td>
<td><p>Leaf-list</p></td>
</tr>
<tr class="row-odd"><td><p><strong>OrderedLeafSetNode</strong></p></td>
<td><p>Leaf-list that is ordered-by user</p></td>
</tr>
<tr class="row-even"><td><p><strong>LeafSetEntryNode</strong></p></td>
<td><p>Concrete entry in a leaf-list</p></td>
</tr>
<tr class="row-odd"><td><p><strong>MapNode</strong></p></td>
<td><p>Keyed list</p></td>
</tr>
<tr class="row-even"><td><p><strong>OrderedMapNode</strong></p></td>
<td><p>Keyed list that is ordered-by user</p></td>
</tr>
<tr class="row-odd"><td><p><strong>MapEntryNode</strong></p></td>
<td><p>Concrete entry in a keyed list</p></td>
</tr>
<tr class="row-even"><td><p><strong>UnkeyedListNode</strong></p></td>
<td><p>Unkeyed list</p></td>
</tr>
<tr class="row-odd"><td><p><strong>UnkeyedListEntryNode</strong></p></td>
<td><p>Concrete entry in an unkeyed list</p></td>
</tr>
</tbody>
</table>
<p>To create a concrete NormalizedNode object, use the utility class Builders
or ImmutableNodes. These classes can be found in <cite>yang-data-impl</cite> module and
they provide methods for building each type of normalized node. Here is a
simple example of building a normalized node:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">// example 1</span>
<span class="n">ContainerNode</span><span class="w"> </span><span class="n">containerNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Builders</span><span class="p">.</span><span class="na">containerBuilder</span><span class="p">().</span><span class="na">withNodeIdentifier</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifier</span><span class="p">(</span><span class="n">QName</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="n">moduleQName</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;example-container&quot;</span><span class="p">)).</span><span class="na">build</span><span class="p">();</span>

<span class="c1">// example 2</span>
<span class="n">ContainerNode</span><span class="w"> </span><span class="n">containerNode2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Builders</span><span class="p">.</span><span class="na">containerBuilder</span><span class="p">(</span><span class="n">containerSchemaNode</span><span class="p">).</span><span class="na">build</span><span class="p">();</span>
</pre></div>
</div>
<p>Both examples produce the same result. NodeIdentifier is one of the four
types of YangInstanceIdentifier (these types are described in the
Javadoc of YangInstanceIdentifier). The purpose of
YangInstanceIdentifier is to uniquely identify a particular node in the
data tree. In the first example, you have to add NodeIdentifier before
building the resulting node. In the second example it is also added
using the provided ContainerSchemaNode object.</p>
<p>ImmutableNodes class offers similar builder methods and also adds an
overloaded method called <code class="docutils literal notranslate"><span class="pre">fromInstanceId()</span></code> which allows you to create a
NormalizedNode object based on YangInstanceIdentifier and SchemaContext.
Below is an example which shows the use of this method.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifier</span><span class="w"> </span><span class="n">contId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifier</span><span class="p">(</span><span class="n">QName</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="n">moduleQName</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;example-container&quot;</span><span class="p">);</span>

<span class="n">NormalizedNode</span><span class="o">&lt;?</span><span class="p">,</span><span class="w"> </span><span class="o">?&gt;</span><span class="w"> </span><span class="n">contNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ImmutableNodes</span><span class="p">.</span><span class="na">fromInstanceId</span><span class="p">(</span><span class="n">schemaContext</span><span class="p">,</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="n">contId</span><span class="p">));</span>
</pre></div>
</div>
<p>Let us show a more complex example of creating a NormalizedNode. First,
consider the following YANG module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">example</span><span class="o">-</span><span class="n">module</span> <span class="p">{</span>
    <span class="n">namespace</span> <span class="s2">&quot;opendaylight.org/example-module&quot;</span><span class="p">;</span>
    <span class="n">prefix</span> <span class="s2">&quot;example&quot;</span><span class="p">;</span>

    <span class="n">container</span> <span class="n">parent</span><span class="o">-</span><span class="n">container</span> <span class="p">{</span>
        <span class="n">container</span> <span class="n">child</span><span class="o">-</span><span class="n">container</span> <span class="p">{</span>
            <span class="nb">list</span> <span class="n">parent</span><span class="o">-</span><span class="n">ordered</span><span class="o">-</span><span class="nb">list</span> <span class="p">{</span>
                <span class="n">ordered</span><span class="o">-</span><span class="n">by</span> <span class="n">user</span><span class="p">;</span>

                <span class="n">key</span> <span class="s2">&quot;parent-key-leaf&quot;</span><span class="p">;</span>

                <span class="n">leaf</span> <span class="n">parent</span><span class="o">-</span><span class="n">key</span><span class="o">-</span><span class="n">leaf</span> <span class="p">{</span>
                    <span class="nb">type</span> <span class="n">string</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">leaf</span> <span class="n">parent</span><span class="o">-</span><span class="n">ordinary</span><span class="o">-</span><span class="n">leaf</span> <span class="p">{</span>
                    <span class="nb">type</span> <span class="n">string</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nb">list</span> <span class="n">child</span><span class="o">-</span><span class="n">ordered</span><span class="o">-</span><span class="nb">list</span> <span class="p">{</span>
                    <span class="n">ordered</span><span class="o">-</span><span class="n">by</span> <span class="n">user</span><span class="p">;</span>

                    <span class="n">key</span> <span class="s2">&quot;child-key-leaf&quot;</span><span class="p">;</span>

                    <span class="n">leaf</span> <span class="n">child</span><span class="o">-</span><span class="n">key</span><span class="o">-</span><span class="n">leaf</span> <span class="p">{</span>
                        <span class="nb">type</span> <span class="n">string</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="n">leaf</span> <span class="n">child</span><span class="o">-</span><span class="n">ordinary</span><span class="o">-</span><span class="n">leaf</span> <span class="p">{</span>
                        <span class="nb">type</span> <span class="n">string</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the following example, two normalized nodes based on the module above
are written to and read from the data tree.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">TipProducingDataTree</span><span class="w"> </span><span class="n">inMemoryDataTree</span><span class="w"> </span><span class="o">==</span><span class="w">     </span><span class="n">InMemoryDataTreeFactory</span><span class="p">.</span><span class="na">getInstance</span><span class="p">().</span><span class="na">create</span><span class="p">(</span><span class="n">TreeType</span><span class="p">.</span><span class="na">OPERATIONAL</span><span class="p">);</span>
<span class="n">inMemoryDataTree</span><span class="p">.</span><span class="na">setSchemaContext</span><span class="p">(</span><span class="n">schemaContext</span><span class="p">);</span>

<span class="c1">// first data tree modification</span>
<span class="n">MapEntryNode</span><span class="w"> </span><span class="n">parentOrderedListEntryNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Builders</span><span class="p">.</span><span class="na">mapEntryBuilder</span><span class="p">().</span><span class="na">withNodeIdentifier</span><span class="p">(</span>
<span class="k">new</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifierWithPredicates</span><span class="p">(</span>
<span class="n">parentOrderedListQName</span><span class="p">,</span><span class="w"> </span><span class="n">parentKeyLeafQName</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pkval1&quot;</span><span class="p">))</span>
<span class="p">.</span><span class="na">withChild</span><span class="p">(</span><span class="n">Builders</span><span class="p">.</span><span class="na">leafBuilder</span><span class="p">().</span><span class="na">withNodeIdentifier</span><span class="p">(</span>
<span class="k">new</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifier</span><span class="p">(</span><span class="n">parentOrdinaryLeafQName</span><span class="p">))</span>
<span class="p">.</span><span class="na">withValue</span><span class="p">(</span><span class="s">&quot;plfval1&quot;</span><span class="p">).</span><span class="na">build</span><span class="p">()).</span><span class="na">build</span><span class="p">();</span>

<span class="n">OrderedMapNode</span><span class="w"> </span><span class="n">parentOrderedListNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Builders</span><span class="p">.</span><span class="na">orderedMapBuilder</span><span class="p">().</span><span class="na">withNodeIdentifier</span><span class="p">(</span>
<span class="k">new</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifier</span><span class="p">(</span><span class="n">parentOrderedListQName</span><span class="p">))</span>
<span class="p">.</span><span class="na">withChild</span><span class="p">(</span><span class="n">parentOrderedListEntryNode</span><span class="p">).</span><span class="na">build</span><span class="p">();</span>

<span class="n">ContainerNode</span><span class="w"> </span><span class="n">parentContainerNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Builders</span><span class="p">.</span><span class="na">containerBuilder</span><span class="p">().</span><span class="na">withNodeIdentifier</span><span class="p">(</span>
<span class="k">new</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifier</span><span class="p">(</span><span class="n">parentContainerQName</span><span class="p">))</span>
<span class="p">.</span><span class="na">withChild</span><span class="p">(</span><span class="n">Builders</span><span class="p">.</span><span class="na">containerBuilder</span><span class="p">().</span><span class="na">withNodeIdentifier</span><span class="p">(</span>
<span class="k">new</span><span class="w"> </span><span class="n">NodeIdentifier</span><span class="p">(</span><span class="n">childContainerQName</span><span class="p">)).</span><span class="na">withChild</span><span class="p">(</span><span class="n">parentOrderedListNode</span><span class="p">).</span><span class="na">build</span><span class="p">()).</span><span class="na">build</span><span class="p">();</span>

<span class="n">YangInstanceIdentifier</span><span class="w"> </span><span class="n">path1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">parentContainerQName</span><span class="p">);</span>

<span class="n">DataTreeModification</span><span class="w"> </span><span class="n">treeModification</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">inMemoryDataTree</span><span class="p">.</span><span class="na">takeSnapshot</span><span class="p">().</span><span class="na">newModification</span><span class="p">();</span>
<span class="n">treeModification</span><span class="p">.</span><span class="na">write</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span><span class="w"> </span><span class="n">parentContainerNode</span><span class="p">);</span>

<span class="c1">// second data tree modification</span>
<span class="n">MapEntryNode</span><span class="w"> </span><span class="n">childOrderedListEntryNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Builders</span><span class="p">.</span><span class="na">mapEntryBuilder</span><span class="p">().</span><span class="na">withNodeIdentifier</span><span class="p">(</span>
<span class="k">new</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifierWithPredicates</span><span class="p">(</span>
<span class="n">childOrderedListQName</span><span class="p">,</span><span class="w"> </span><span class="n">childKeyLeafQName</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;chkval1&quot;</span><span class="p">))</span>
<span class="p">.</span><span class="na">withChild</span><span class="p">(</span><span class="n">Builders</span><span class="p">.</span><span class="na">leafBuilder</span><span class="p">().</span><span class="na">withNodeIdentifier</span><span class="p">(</span>
<span class="k">new</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifier</span><span class="p">(</span><span class="n">childOrdinaryLeafQName</span><span class="p">))</span>
<span class="p">.</span><span class="na">withValue</span><span class="p">(</span><span class="s">&quot;chlfval1&quot;</span><span class="p">).</span><span class="na">build</span><span class="p">()).</span><span class="na">build</span><span class="p">();</span>

<span class="n">OrderedMapNode</span><span class="w"> </span><span class="n">childOrderedListNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Builders</span><span class="p">.</span><span class="na">orderedMapBuilder</span><span class="p">().</span><span class="na">withNodeIdentifier</span><span class="p">(</span>
<span class="k">new</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">NodeIdentifier</span><span class="p">(</span><span class="n">childOrderedListQName</span><span class="p">))</span>
<span class="p">.</span><span class="na">withChild</span><span class="p">(</span><span class="n">childOrderedListEntryNode</span><span class="p">).</span><span class="na">build</span><span class="p">();</span>

<span class="n">ImmutableMap</span><span class="p">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">QName</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ImmutableMap</span><span class="p">.</span><span class="na">builder</span><span class="p">();</span>
<span class="n">ImmutableMap</span><span class="o">&lt;</span><span class="n">QName</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">keys</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">parentKeyLeafQName</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pkval1&quot;</span><span class="p">).</span><span class="na">build</span><span class="p">();</span>

<span class="n">YangInstanceIdentifier</span><span class="w"> </span><span class="n">path2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">YangInstanceIdentifier</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">parentContainerQName</span><span class="p">).</span><span class="na">node</span><span class="p">(</span><span class="n">childContainerQName</span><span class="p">)</span>
<span class="p">.</span><span class="na">node</span><span class="p">(</span><span class="n">parentOrderedListQName</span><span class="p">).</span><span class="na">node</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">NodeIdentifierWithPredicates</span><span class="p">(</span><span class="n">parentOrderedListQName</span><span class="p">,</span><span class="w"> </span><span class="n">keys</span><span class="p">)).</span><span class="na">node</span><span class="p">(</span><span class="n">childOrderedListQName</span><span class="p">);</span>

<span class="n">treeModification</span><span class="p">.</span><span class="na">write</span><span class="p">(</span><span class="n">path2</span><span class="p">,</span><span class="w"> </span><span class="n">childOrderedListNode</span><span class="p">);</span>
<span class="n">treeModification</span><span class="p">.</span><span class="na">ready</span><span class="p">();</span>
<span class="n">inMemoryDataTree</span><span class="p">.</span><span class="na">validate</span><span class="p">(</span><span class="n">treeModification</span><span class="p">);</span>
<span class="n">inMemoryDataTree</span><span class="p">.</span><span class="na">commit</span><span class="p">(</span><span class="n">inMemoryDataTree</span><span class="p">.</span><span class="na">prepare</span><span class="p">(</span><span class="n">treeModification</span><span class="p">));</span>

<span class="n">DataTreeSnapshot</span><span class="w"> </span><span class="n">snapshotAfterCommits</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">inMemoryDataTree</span><span class="p">.</span><span class="na">takeSnapshot</span><span class="p">();</span>
<span class="n">Optional</span><span class="o">&lt;</span><span class="n">NormalizedNode</span><span class="o">&lt;?</span><span class="p">,</span><span class="w"> </span><span class="o">?&gt;&gt;</span><span class="w"> </span><span class="n">readNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">snapshotAfterCommits</span><span class="p">.</span><span class="na">readNode</span><span class="p">(</span><span class="n">path1</span><span class="p">);</span>
<span class="n">Optional</span><span class="o">&lt;</span><span class="n">NormalizedNode</span><span class="o">&lt;?</span><span class="p">,</span><span class="w"> </span><span class="o">?&gt;&gt;</span><span class="w"> </span><span class="n">readNode2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">snapshotAfterCommits</span><span class="p">.</span><span class="na">readNode</span><span class="p">(</span><span class="n">path2</span><span class="p">);</span>
</pre></div>
</div>
<p>First comes the creation of in-memory data tree instance. The schema
context (containing the model mentioned above) of this tree is set.
After that, two normalized nodes are built. The first one consists of a
parent container, a child container and a parent ordered list which
contains a key leaf and an ordinary leaf. The second normalized node is
a child ordered list that also contains a key leaf and an ordinary leaf.</p>
<p>In order to add a child node to a node, method <code class="docutils literal notranslate"><span class="pre">withChild()</span></code> is used. It
takes a NormalizedNode as argument. When creating a list entry,
YangInstanceIdentifier.NodeIdentifierWithPredicates should be used as
its identifier. Its arguments are the <code class="docutils literal notranslate"><span class="pre">QName</span></code> of the list, <code class="docutils literal notranslate"><span class="pre">QName</span></code> of the
list key and the value of the key. Method <code class="docutils literal notranslate"><span class="pre">withValue()</span></code> specifies a value
for the ordinary leaf in the list.</p>
<p>Before writing a node to the data tree, a path (YangInstanceIdentifier)
which determines its place in the data tree needs to be defined. The
path of the first normalized node starts at the parent container. The
path of the second normalized node points to the child ordered list
contained in the parent ordered list entry specified by the key value
<code class="docutils literal notranslate"><span class="pre">&quot;pkval1&quot;</span></code>.</p>
<p>Write operation is performed with both normalized nodes mentioned
earlier. It consists of several steps. The first step is to instantiate a
DataTreeModification object based on a DataTreeSnapshot.
DataTreeSnapshot gives you the current state of the data tree. Then
comes the write operation which writes a normalized node at the provided
path in the data tree. After doing both write operations, method ready()
has to be called, marking the modification as ready for application to
the data tree. No further operations within the modification are
allowed. The modification is then validated - checked whether it can be
applied to the data tree. Finally, we commit it to the data tree.</p>
<p>Now you can access the written nodes. In order to do this, you must
create a new DataTreeSnapshot instance and call the method <code class="docutils literal notranslate"><span class="pre">readNode()</span></code>
with path argument pointing to a node in the tree.</p>
</section>
<section id="serialization-deserialization-of-yang-data">
<h3>Serialization / deserialization of YANG data<a class="headerlink" href="#serialization-deserialization-of-yang-data" title="Link to this heading">¶</a></h3>
<p>If you want to deserialize YANG-modeled data that has the form of an
XML document, you can use the XML parser found in the module
<code class="docutils literal notranslate"><span class="pre">yang-data-codec-xml</span></code>. The parser walks through the XML document
containing YANG-modeled data based on the provided SchemaContext and
emits node events into a NormalizedNodeStreamWriter. The parser
disallows multiple instances of the same element except for leaf-list
and list entries. The parser also expects that the YANG-modeled data in
the XML source are wrapped in a root element. Otherwise it will not work
correctly.</p>
<p>Here is an example of using the XML parser.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">InputStream</span><span class="w"> </span><span class="n">resourceAsStream</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ExampleClass</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getResourceAsStream</span><span class="p">(</span><span class="s">&quot;/example-module.yang&quot;</span><span class="p">);</span>

<span class="n">XMLInputFactory</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XMLInputFactory</span><span class="p">.</span><span class="na">newInstance</span><span class="p">();</span>
<span class="n">XMLStreamReader</span><span class="w"> </span><span class="n">reader</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">factory</span><span class="p">.</span><span class="na">createXMLStreamReader</span><span class="p">(</span><span class="n">resourceAsStream</span><span class="p">);</span>

<span class="n">NormalizedNodeResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NormalizedNodeResult</span><span class="p">();</span>
<span class="n">NormalizedNodeStreamWriter</span><span class="w"> </span><span class="n">streamWriter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ImmutableNormalizedNodeStreamWriter</span><span class="p">.</span><span class="na">from</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

<span class="n">XmlParserStream</span><span class="w"> </span><span class="n">xmlParser</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">XmlParserStream</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="n">streamWriter</span><span class="p">,</span><span class="w"> </span><span class="n">schemaContext</span><span class="p">);</span>
<span class="n">xmlParser</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>

<span class="n">NormalizedNode</span><span class="o">&lt;?</span><span class="p">,</span><span class="w"> </span><span class="o">?&gt;</span><span class="w"> </span><span class="n">transformedInput</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="na">getResult</span><span class="p">();</span>
</pre></div>
</div>
<p>The XML parser utilizes the <code class="docutils literal notranslate"><span class="pre">javax.xml.stream.XMLStreamReader</span></code> for parsing
an XML document. First, you should create an instance of this reader
using XMLInputFactory and then load an XML document (in the form of
InputStream object) into it.</p>
<p>In order to emit node events while parsing the data you need to
instantiate a NormalizedNodeStreamWriter. This writer is actually an
interface and therefore you need to use a concrete implementation of it.
In this example it is the ImmutableNormalizedNodeStreamWriter, which
constructs immutable instances of NormalizedNodes.</p>
<p>There are two ways how to create an instance of this writer using the
static overloaded method from(). One version of this method takes a
NormalizedNodeResult as argument. This object type is a result holder in
which the resulting NormalizedNode will be stored. The other version
takes a NormalizedNodeContainerBuilder as argument. All created nodes
will be written to this builder.</p>
<p>Next step is to create an instance of the XML parser. The parser itself
is represented by a class named XmlParserStream. You can use one of two
versions of the static overloaded method create() to construct this
object. One version accepts a NormalizedNodeStreamWriter and a
SchemaContext as arguments, the other version takes the same arguments
plus a SchemaNode. Node events are emitted to the writer. The
SchemaContext is used to check if the YANG data in the XML source comply
with the provided YANG model(s). The last argument, a SchemaNode object,
describes the node that is the parent of nodes defined in the XML data.
If you do not provide this argument, the parser sets the SchemaContext
as the parent node.</p>
<p>The parser is now ready to walk through the XML. Parsing is initiated by
calling the method parse() on the XmlParserStream object with
XMLStreamReader as its argument.</p>
<p>Finally, you can access the result of parsing - a tree of NormalizedNodes
contains the data as they are defined in the parsed XML document - by
calling the method <code class="docutils literal notranslate"><span class="pre">getResult()</span></code> on the NormalizedNodeResult object.</p>
</section>
</section>
</section>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/developer-guides/yang-tools.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2016-2026, OpenDaylight Project.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 8.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>